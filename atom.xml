<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浮梦之殇</title>
  
  
  <link href="/it233.github.io/atom.xml" rel="self"/>
  
  <link href="https://it233.github.io/"/>
  <updated>2018-11-28T06:35:50.590Z</updated>
  <id>https://it233.github.io/</id>
  
  <author>
    <name>漠</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jpa自动映射java实体类与数据库表</title>
    <link href="https://it233.github.io/2018/11/28/jpa%E8%87%AA%E5%8A%A8%E6%98%A0%E5%B0%84java%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8/"/>
    <id>https://it233.github.io/2018/11/28/jpa自动映射java实体类与数据库表/</id>
    <published>2018-11-28T06:29:10.000Z</published>
    <updated>2018-11-28T06:35:50.590Z</updated>
    
    <content type="html"><![CDATA[<p>​    之前有说过jpa不实用实体类，那是某种特殊情况的时候的需要</p><p>​    而大多数的时候，我们后端代码还是需要有与数据库对应的实体类的</p><p>​    这样不但方便后端进行管理数据，而且更易于使用jpa框架</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    之前有说过jpa不实用实体类，那是某种特殊情况的时候的需要&lt;/p&gt;
&lt;p&gt;​    而大多数的时候，我们后端代码还是需要有与数据库对应的实体类的&lt;/p&gt;
&lt;p&gt;​    这样不但方便后端进行管理数据，而且更易于使用jpa框架&lt;/p&gt;

      
    
    </summary>
    
      <category term="java" scheme="https://it233.github.io/categories/java/"/>
    
      <category term="框架" scheme="https://it233.github.io/categories/java/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="JPA" scheme="https://it233.github.io/categories/java/%E6%A1%86%E6%9E%B6/JPA/"/>
    
    
      <category term="学习" scheme="https://it233.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>canvas-camera</title>
    <link href="https://it233.github.io/2018/11/21/canvas-camera/"/>
    <id>https://it233.github.io/2018/11/21/canvas-camera/</id>
    <published>2018-11-21T09:19:16.000Z</published>
    <updated>2018-11-28T06:41:26.323Z</updated>
    
    <content type="html"><![CDATA[<p>这里是运用canvas来实现电脑摄像头拍照的功能的js代码。</p><p>纯属个人兴趣</p><p>以下是个人封装的js，好坏皆是如此</p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 调用摄像头</span></span><br><span class="line"><span class="comment"> * 传入参数：必须</span></span><br><span class="line"><span class="comment"> * canvas：画布，传入的参数为id,class,name或者tagName四选一，注意：只需要传入名称即可,不需要符号，</span></span><br><span class="line"><span class="comment"> *              例如:&lt;canvas id = "myCanvas"&gt;&lt;/canvas&gt;,那么入参就是myCanvas</span></span><br><span class="line"><span class="comment"> * video：影像，传入id，class，name，或者tagName四选一</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 传入参数：非必须</span></span><br><span class="line"><span class="comment"> * open ：打开摄像头功能的按钮id，class，Name</span></span><br><span class="line"><span class="comment"> * snap ： 拍摄功能的按钮id，class或者name</span></span><br><span class="line"><span class="comment"> * close： 关闭摄像头功能的按钮id，class或者name</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：如果不传入按钮功能，会有open，snap，close三个function来提供相应的功能，可以直接使用canCamera.open()等来调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 同时，提供链式调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 调用示例：</span></span><br><span class="line"><span class="comment"> *      var cc = canCamera(&#123;</span></span><br><span class="line"><span class="comment"> *          canvas:"myCanvas",</span></span><br><span class="line"><span class="comment"> *          video:"myVideo",</span></span><br><span class="line"><span class="comment"> *          open:"start",</span></span><br><span class="line"><span class="comment"> *          snap:"getPhotoBtn",</span></span><br><span class="line"><span class="comment"> *          close:"closeBtn"</span></span><br><span class="line"><span class="comment"> *      &#125;)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 或者：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  var cc = canCamera(&#123;</span></span><br><span class="line"><span class="comment"> *          canvas:"myCanvas",</span></span><br><span class="line"><span class="comment"> *          video:"myVideo"</span></span><br><span class="line"><span class="comment"> *      &#125;)</span></span><br><span class="line"><span class="comment"> *    //绑定按钮点击事件</span></span><br><span class="line"><span class="comment"> *    document.getElementById("start").addEventListener('click',cc.open);</span></span><br><span class="line"><span class="comment"> *    document.getElementById("getPhotoBtn").addEventListener('click',cc.snap);</span></span><br><span class="line"><span class="comment"> *    document.getElementById("closeBtn").addEventListener('click',cc.close);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window, document</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> canCamera = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> $<span class="keyword">this</span> = canCamera</span><br><span class="line">        $<span class="keyword">this</span>.canvas = <span class="built_in">document</span>.getElementById(obj.canvas)</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByName(obj.canvas)[<span class="number">0</span>]</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByClassName(obj.canvas)[<span class="number">0</span>]</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByTagName(obj.canvas)[<span class="number">0</span>]</span><br><span class="line">        $<span class="keyword">this</span>.video = <span class="built_in">document</span>.getElementById(obj.video)</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByName(obj.video)[<span class="number">0</span>]</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByClassName(obj.video)[<span class="number">0</span>]</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByTagName(obj.video)[<span class="number">0</span>]</span><br><span class="line">        $<span class="keyword">this</span>.openBtn = <span class="built_in">document</span>.getElementById(obj.open)</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByName(obj.open)[<span class="number">0</span>]</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByClassName(obj.open)[<span class="number">0</span>]</span><br><span class="line">        $<span class="keyword">this</span>.snapBtn = <span class="built_in">document</span>.getElementById(obj.snap)</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByName(obj.snap)[<span class="number">0</span>]</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByClassName(obj.snap)[<span class="number">0</span>]</span><br><span class="line">        $<span class="keyword">this</span>.closeBtn = <span class="built_in">document</span>.getElementById(obj.close)</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByName(obj.close)[<span class="number">0</span>]</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByClassName(obj.close)[<span class="number">0</span>]</span><br><span class="line">        $<span class="keyword">this</span>.context = $<span class="keyword">this</span>.canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">        $<span class="keyword">this</span>.MediaStreamTrack = <span class="literal">null</span></span><br><span class="line">        $<span class="keyword">this</span>.open = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            $<span class="keyword">this</span>.video.style.display = <span class="string">"block"</span>;</span><br><span class="line">            $<span class="keyword">this</span>.canvas.style.display = <span class="string">"none"</span>;</span><br><span class="line">            <span class="keyword">if</span> (navigator.mediaDevices &amp;&amp; navigator.mediaDevices.getUserMedia) &#123;</span><br><span class="line">                navigator.mediaDevices.getUserMedia(&#123;</span><br><span class="line">                    <span class="string">"video"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</span><br><span class="line">                    $<span class="keyword">this</span>.MediaStreamTrack = <span class="keyword">typeof</span> stream.stop === <span class="string">'function'</span> ? stream : stream.getTracks()[<span class="number">1</span>];</span><br><span class="line">                    $<span class="keyword">this</span>.video.srcObject = stream;</span><br><span class="line">                    $<span class="keyword">this</span>.video.play();</span><br><span class="line">                &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(err);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.getMedia) &#123;</span><br><span class="line">                navigator.getMedia(&#123;</span><br><span class="line">                    <span class="string">"video"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(stream);</span><br><span class="line">                    $<span class="keyword">this</span>.MediaStreamTrack = stream.getTracks()[<span class="number">1</span>];</span><br><span class="line">                    $<span class="keyword">this</span>.video.srcObject = (<span class="built_in">window</span>.webkitURL).createObjectURL(stream);</span><br><span class="line">                    $<span class="keyword">this</span>.video.play();</span><br><span class="line">                &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(err);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alert(<span class="string">"浏览器不支持！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> $<span class="keyword">this</span></span><br><span class="line">        &#125;;</span><br><span class="line">        $<span class="keyword">this</span>.snap = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> w = $<span class="keyword">this</span>.video.offsetWidth,</span><br><span class="line">                h = $<span class="keyword">this</span>.video.offsetHeight;</span><br><span class="line">            $<span class="keyword">this</span>.video.style.display = <span class="string">"none"</span>;</span><br><span class="line">            $<span class="keyword">this</span>.canvas.style.display = <span class="string">"block"</span>;</span><br><span class="line">            $<span class="keyword">this</span>.context.drawImage($<span class="keyword">this</span>.video, <span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">            <span class="keyword">return</span> $<span class="keyword">this</span></span><br><span class="line">        &#125;;</span><br><span class="line">        $<span class="keyword">this</span>.close = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            $<span class="keyword">this</span>.MediaStreamTrack &amp;&amp; $<span class="keyword">this</span>.MediaStreamTrack.stop();</span><br><span class="line">            <span class="keyword">return</span> $<span class="keyword">this</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> ($<span class="keyword">this</span>.openBtn)</span><br><span class="line">            $<span class="keyword">this</span>.openBtn.addEventListener(<span class="string">'click'</span>, $<span class="keyword">this</span>.open);</span><br><span class="line">        <span class="keyword">if</span> ($<span class="keyword">this</span>.snapBtn)</span><br><span class="line">            $<span class="keyword">this</span>.snapBtn.addEventListener(<span class="string">'click'</span>, $<span class="keyword">this</span>.snap);</span><br><span class="line">        <span class="keyword">if</span> ($<span class="keyword">this</span>.closeBtn)</span><br><span class="line">            $<span class="keyword">this</span>.closeBtn.addEventListener(<span class="string">'click'</span>, $<span class="keyword">this</span>.close);</span><br><span class="line">        <span class="built_in">window</span>.canCamera = canCamera || <span class="keyword">new</span> canCamera()</span><br><span class="line">        <span class="keyword">return</span> $<span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.canCamera = canCamera || <span class="keyword">new</span> canCamera()</span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里是运用canvas来实现电脑摄像头拍照的功能的js代码。&lt;/p&gt;
&lt;p&gt;纯属个人兴趣&lt;/p&gt;
&lt;p&gt;以下是个人封装的js，好坏皆是如此&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="前端" scheme="https://it233.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://it233.github.io/categories/%E5%89%8D%E7%AB%AF/js/"/>
    
      <category term="HFJs" scheme="https://it233.github.io/categories/%E5%89%8D%E7%AB%AF/js/HFJs/"/>
    
    
      <category term="兴趣" scheme="https://it233.github.io/tags/%E5%85%B4%E8%B6%A3/"/>
    
  </entry>
  
  <entry>
    <title>前端画图Canvas简单运用</title>
    <link href="https://it233.github.io/2018/11/19/%E5%89%8D%E7%AB%AF%E7%94%BB%E5%9B%BECanvas%E7%AE%80%E5%8D%95%E8%BF%90%E7%94%A8/"/>
    <id>https://it233.github.io/2018/11/19/前端画图Canvas简单运用/</id>
    <published>2018-11-19T08:40:30.000Z</published>
    <updated>2018-11-28T07:09:12.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><ul><li>朋友遇到的情况，属于前端的问题，是需要打开摄像头来拍照，关于这个问题，他找到了我让我来帮他解决，不过由于我的前端也是属于那种半吊子水平，所以在过程中也是参考了网上的不少资料和案例，不过还好的是因此也了解了不少知识，所以准备整理一下，做个记录</li><li>这篇主要是前端canvas画布功能，可能知识不够全面，但是要实现拍照应该是没问题了</li><li>除了参照图像资源进行利用canvas画图之外，canvas还有很多功能提供，方便我们直接在页面上进行手工绘画，这些功能这里就不展示了，因为我也忘记了，只是之前刚学前端的时候有捣弄过，不过现在主要做后台开发，所以前端水平就一般般</li></ul><h1 id="二、画图"><a href="#二、画图" class="headerlink" title="二、画图"></a>二、画图</h1><ul><li>在实现拍照之前，先来详细了解一下canvas画图功能，这样对于后面拍照会更简单一点</li></ul><h2 id="页面准备"><a href="#页面准备" class="headerlink" title="页面准备"></a>页面准备</h2><ul><li>实现canvas画图功能，我们需要准备一张图片，为了试验效果，我就随便截了一张桌面的图片</li><li>在页面中我们要放置一张图片(当然，也可以不用展示在页面上，这个js代码中会扩展)，所以需要img标签元素</li><li>想要进行在页面画图，我们还要通过canvas标签元素获得context(简称，后面展示全部)来帮我们实现这个功能</li><li>然后，为了进行测试，我们加一个按钮，当点击按钮的时候，我们将展示的图片画出来</li></ul><h2 id="html代码"><a href="#html代码" class="headerlink" title="html代码"></a>html代码</h2><ul><li><p>我们需要的html代码很简单，只有三个元素：img、canvas、button</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../imgs/0.png"</span> <span class="attr">id</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">height</span>=<span class="string">"400"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">id</span>=<span class="string">"canvas1"</span> <span class="attr">style</span>=<span class="string">"border: 1px solid gray"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"draw"</span>&gt;</span>画图<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="js代码及详解"><a href="#js代码及详解" class="headerlink" title="js代码及详解"></a>js代码及详解</h2><h3 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h3><ul><li>在上代码之前， 先来说一下流程</li><li>我们想要参照img元素中的图片资源，利用canvas来将其画出来<ul><li>那么首先我们就需要找到img元素中的图片，</li><li>其次还要有canvas画图的对象，</li><li>然后获得canvas的Context</li><li>最后配置Context的环境将img图片画出来</li></ul></li><li>总体简单来说就这四步，下面直接上代码，然后再解释：</li></ul><h3 id="js代码"><a href="#js代码" class="headerlink" title="js代码"></a>js代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"ckbtn"</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">"img"</span>);</span><br><span class="line">        <span class="keyword">var</span> cv = <span class="built_in">document</span>.getElementById(<span class="string">'canvas1'</span>);</span><br><span class="line">        <span class="keyword">var</span> ct = cv.getContext(<span class="string">"2d"</span>);</span><br><span class="line">        ct.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">400</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="js代码详细解释（以及踩过的坑和未踩过的坑）"><a href="#js代码详细解释（以及踩过的坑和未踩过的坑）" class="headerlink" title="js代码详细解释（以及踩过的坑和未踩过的坑）"></a>js代码详细解释（以及踩过的坑和未踩过的坑）</h3><ul><li><p>注意点1、window.onload</p><ul><li>这个window.onload不用多解释，就是在页面加载完成之后再执行funciton中的这段代码</li><li>为什么一定要这么做呢？</li><li>那是因为我们现在使用的页面元素，如果没有这个onload保证页面先加载完成，有可能会出现这种情况：<ul><li>canvas元素找不到，所以我们获取其dom对象的时候有可能会出现undefined</li><li>如果canvas出现undefined的话，那么我们必然无法获得该画布下的Context，也就无法实现画图功能</li><li>除此之外，运气好，我们canvas画布放的比较靠前，能够找得到，不过我们知道，图片属于外部静态资源，加载可能没有html原生代码快，这个时候，如果我们图片没有加载完成，也可能会出现画图失败<ul><li>举个例子，假如有一个画家，他要为一个人画一幅像，但是不巧的是，这个人突然临时有事，不能准时到，那么在这个人还没有到达之前，这个画家怎么去画这幅画？他拿什么做参考呢？</li></ul></li><li>再者呢，我们又要绑定按钮，所以onload最好是加上</li></ul></li><li>这里说了那么多，我们能够知道，如果我们看着代码没有错误，并且没有报错，那么很可能是图片没有加载完成，导致没法画出图片（之后还有一个可能的原因，在注意点2）</li></ul></li><li><p>注意点2、canvas元素</p><ul><li>这里要注意的是，我们所说的canvas画图，其实canvas只是一个画布,隐约记得曾经学的时候，好像还有画笔什么来着，记不清了，不纠结了、</li><li>真正实现画图功能的，是画笔而不是画布，而之前说的Context，是一种环境，<ul><li>这里打个比方，canvas是画布，就是画家使用的画板，就是我们要画出的画的容器</li><li>那个画笔是什么来着，就是用来进行绘画的，之前说的能够手工绘画也是控制画笔在页面上进行绘画</li><li>而context，是环境，就好比我们画家用画笔在画布上绘画所需要的因素，在这里我个人将它理解为了画家，因为context提供了画图很多方法来满足画图的需要。就像一个画家一样具备的能力</li><li>这里简单展示一下context，关于context这个对象具体的代码有点多，有兴趣的可以自己研究</li></ul></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getContext(<span class="string">contextId:</span> <span class="string">"2d"</span>, contextAttributes?: Canvas2DContextAttributes): CanvasRenderingContext2D | <span class="literal">null</span>;</span><br><span class="line">getContext(<span class="string">contextId:</span> <span class="string">"webgl"</span> | <span class="string">"experimental-webgl"</span>, contextAttributes?: WebGLContextAttributes): WebGLRenderingContext | <span class="literal">null</span>;</span><br><span class="line">getContext(<span class="string">contextId:</span> string, contextAttributes?: &#123;&#125;): CanvasRenderingContext2D | WebGLRenderingContext | <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li>这里并不是很详细地解释了canvas，所以我们知道，canvas是容器，这里也会有一个小问题，不知道有没有人遇到过。（在做摄像头拍照的时候遇到了小问题，所以回头研究了canvas）<ul><li>如果我们为了美观，不展示canvas来占空间，而设置为了display:none，那么会发生什么情况？</li><li>另外，如果我们设置了canvas的长宽都为0，会是什么情况？</li></ul></li><li>对于以上两点，在下面会案例展示结果，先猜一下吧</li></ul></li><li><p>注意点3、2维和3维画图</p><ul><li><p>通过上面的getContext()方法，能够看得出来，我们假如传入的是“2d”这个字符串，那么就会获得CanvasRenderingContext2D这个对象</p></li><li><p>在没有看过这些代码之前，我也曾一度认为，有2d就有3d，果断丢个”3d”参数进去，哈哈，获得null，那么我们肯定觉得不合理，有2d画图就应该能画3d的啊，其实webgl就是用来画3d的，不过我不会，也不了解</p></li><li><p>不过有一点需要注意了，接下来图文解释更清晰</p><ul><li><p>首先我获得canvas之后，通过传入参数3d</p></li><li><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">cv</span> = document.getElementById('canvas1');</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="built_in">cv</span>)</span><br><span class="line">        <span class="built_in">var</span> ct = <span class="built_in">cv</span>.getContext(<span class="string">"3d"</span>);</span><br><span class="line">        console.<span class="built_in">log</span>(ct)</span><br></pre></td></tr></table></figure></li><li><p>获得的结果为null</p></li><li><p><img src="/2018/11/19/前端画图Canvas简单运用/0.png" alt=""></p></li><li><p>然而我们如果传入的是”2d”或者”webgl”的话，确实能够获得context的</p></li><li><p><img src="/2018/11/19/前端画图Canvas简单运用/2d.png" alt=""></p></li><li><p><img src="/2018/11/19/前端画图Canvas简单运用/webgl.png" alt=""></p></li><li><p>注意了：如果我们先入参2d获得返回对象保存在一个变量中，然后再入参webgl保存在另一个变量中，会是什么结果？</p></li><li><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">cv</span> = document.getElementById('canvas1');</span><br><span class="line">       console.<span class="built_in">log</span>(<span class="built_in">cv</span>)</span><br><span class="line">       <span class="built_in">var</span> ct2d = <span class="built_in">cv</span>.getContext(<span class="string">"2d"</span>);</span><br><span class="line">       <span class="built_in">var</span> ctwebgl = <span class="built_in">cv</span>.getContext(<span class="string">"webgl"</span>)</span><br><span class="line">       console.<span class="built_in">log</span>(<span class="string">"ct2d:"</span>+ct2d)</span><br><span class="line">       console.<span class="built_in">log</span>(<span class="string">"ctwebgl:"</span>+ctwebgl)</span><br></pre></td></tr></table></figure> <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 结果就是先获得的context占据这个画布，再设置另一个则没用了，直接为null。而官方原注释并没有解释为何，我们可以从官方注释中得到的信息，就是：</span><br><span class="line"></span><br><span class="line">- 返回一个对象，该对象提供绘制和操作文档中画布元素上的图像和图形的方法和属性。上下文对象包括关于颜色、线宽、字体和其他可以在画布上绘制的图形参数的信息。</span><br><span class="line"></span><br><span class="line">    @param上下文要创建的画布类型的标识符(ID)。Internet Explorer <span class="number">9</span>和Internet Explorer <span class="number">10</span>仅支持使用canvas.getContext(“<span class="number">2</span>d”)的<span class="number">2</span>d环境;IE11预览还支持<span class="number">3</span>d或WebGL上下文使用canvas.getContext(“实验- WebGL”);</span><br><span class="line"></span><br><span class="line">- 好像并没有什么文字能解释为什么只能获得一次？那么我们就只能从代码中分析了，请移至注意点<span class="number">2</span>查看代码，这里不贴了</span><br><span class="line"></span><br><span class="line">- w3school中也没有过多解释，不过这里依然不妨碍理解，这个方法大致为以下情况：</span><br><span class="line"></span><br><span class="line">- 根据入参来匹配<span class="number">2</span>d或者webgl，如果是，那么会先去看contextAttributes，如果已经有值了（上次一调用之后会将<span class="number">2</span>d或者webgl相应对象存下来，猜测），那么直接返回null，这就导致如果第一次已经拿到<span class="number">2</span>d的对象了，那么下面再入参webgl调用，获得的就是null，而为什么不是返回上一次的，就是函数返回值的问题吧，看前两个getContext，返回值要么是对应的<span class="number">2</span>d或webgl对象，要么是null。这就是说参数匹配到之后，就会执行相应的函数，而<span class="string">"2d"</span>只会返回<span class="number">2</span>d对象或者null，webgl也是一样。最后一个方法，是在参数不匹配<span class="number">2</span>d或者webgl的时候，会先去返回<span class="number">2</span>d，如果没有，再考虑webgl，最后二者都没有，就返回null</span><br><span class="line"></span><br><span class="line">- 其实，之上一点的看法，最后理解根本无法实践，因为按照最后的说法，我们必须要传一个参数过去，而如果我们先传过去<span class="number">2</span>d，那么获得<span class="number">2</span>d对象，这时候再去调用getContext实践，不好意思，之前已经设置过<span class="number">2</span>d了，其他的我不会给你了。就好比一个画板，其中A画家先去使用了，那么不好意思，不管你后来再来的其他任何人，都不会得到使用权。不过如果再次传入<span class="number">2</span>d，还是能够获得<span class="number">2</span>d对象，这个只能解释为A画家中途休息，休息完之后依旧拥有该画板的使用权。以至于最后的猜想也没法实现验证。因为我除了传入<span class="number">2</span>d参数，其他任何参数都会直接获得null</span><br><span class="line"></span><br><span class="line">- 而且这看到的只是interface中的代码，没有具体实现的逻辑代码，一切靠猜测，所以可能会很大的冲突，不过结果肯定是一样的，因为就是通过结果来进行推测的逻辑。如果有人比较了解这方面的东西，希望能够告知以便相互学习</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>注意点4：这里不叫注意点，应该是知识点</p><ul><li><p>drawImage（r,x,y,w,h）参数：</p><ul><li>r：代表的是图像源头</li><li>x：表示在画布中x坐标轴的偏移量</li><li>y：y坐标轴偏移量</li><li>w：画出的图片的宽度</li><li><p>h：高度</p><pre><code>、结果实例    </code></pre></li></ul></li></ul></li></ul><h2 id="参照页面img元素画图"><a href="#参照页面img元素画图" class="headerlink" title="参照页面img元素画图"></a>参照页面img元素画图</h2><ul><li>这里就丢两张图， 反正该解释的上面已经解释了</li><li><img src="/2018/11/19/前端画图Canvas简单运用/draw0.png" alt=""></li><li><img src="/2018/11/19/前端画图Canvas简单运用/draw1.png" alt=""></li></ul><h2 id="不参照页面img元素画图"><a href="#不参照页面img元素画图" class="headerlink" title="不参照页面img元素画图"></a>不参照页面img元素画图</h2><ul><li><p>在前面说过，我们不将图片展示在页面上来将图片画出来，不过我们要遵循的步骤依旧是一样的</p></li><li><p>只不过第一步找参考图片不是在页面中寻找了，而是在js代码中，也就是我们要手动创建一个img元素dom对象，然后指定其图片</p></li><li><p>代码：</p></li><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>)</span><br><span class="line">       img.src=<span class="string">"../imgs/0.png"</span></span><br><span class="line">       <span class="built_in">document</span>.getElementById(<span class="string">"draw"</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">var</span> cv = <span class="built_in">document</span>.getElementById(<span class="string">'canvas1'</span>);</span><br><span class="line">           <span class="keyword">var</span> ct = cv.getContext(<span class="string">"2d"</span>);</span><br><span class="line">           ct.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="literal">- 结果图：</span></span><br><span class="line"></span><br><span class="line"><span class="literal">- ![](前端画图Canvas简单运用\draw2.png)</span></span><br><span class="line"></span><br><span class="line"><span class="literal">- 以上展示了如何利用canvas画图，其中有理解错误的地方，也就这样了。下面来看一下怎么将这张canvas中的图片保存下来，这个后面会用到</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 四、canvas补充</span></span><br><span class="line"></span><br><span class="line"><span class="literal">- 上面说到的两个问题，在这里进行补充示例说明结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 问题1：canvas设置为display:none的情况会如何</span></span><br><span class="line"></span><br><span class="line"><span class="literal">- 首先看一下代码：</span></span><br><span class="line"></span><br><span class="line"><span class="literal">- html：直接设置canvas样式为display:none</span></span><br><span class="line"></span><br><span class="line"><span class="literal">-</span></span><br></pre></td></tr></table></figure><p><canvas height="400" width="200" id="canvas1" style="border: 1px solid gray;display:none;"></canvas><br><br><br><button id="draw">画图</button><br><button id="show">展示</button></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="deletion">- 结果可想而知，页面上什么都没有只有两个个按钮</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">- ![](前端画图Canvas简单运用\test0.png)</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">- js代码：思路是，点击画图将图片画到canvas中，在点击展示改变canvas的样式为block，看看有没有图片</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-</span></span><br></pre></td></tr></table></figure><p>//画图按钮<br>var img = document.createElement(“img”)<br>img.src=”../imgs/0.png”<br>document.getElementById(“draw”).addEventListener(‘click’, function () {</p><pre><code>var cv = document.getElementById(&apos;canvas1&apos;);var ct = cv.getContext(&quot;2d&quot;);ct.drawImage(img, 0, 0, 200, 200);</code></pre><p>});<br>//展示按钮<br>document.getElementById(“show”).addEventListener(‘click’,function () {</p><pre><code>document.getElementById(&quot;canvas1&quot;).style.display= &apos;block&apos;;</code></pre><p>})</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="literal">- 结果：</span></span><br><span class="line"></span><br><span class="line"><span class="literal">- ![](前端画图Canvas简单运用\test1.png)</span></span><br><span class="line"></span><br><span class="line"><span class="literal">- 啊哈，有图片耶！那么我们来看看第二种情况</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 问题2：canvas设置为长宽都为0的情况会如何</span></span><br><span class="line"></span><br><span class="line"><span class="literal">- 思路同上一个，直接贴代码和效果</span></span><br><span class="line"></span><br><span class="line"><span class="literal">-</span></span><br></pre></td></tr></table></figure><p><canvas height="0" width="0" id="canvas1" style="border: 1px solid gray;"></canvas><br><br><br><button id="draw">画图</button><br><button id="show">展示</button></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="deletion">-</span></span><br></pre></td></tr></table></figure><p>  //画图按钮</p><pre><code>var img = document.createElement(&quot;img&quot;)img.src = &quot;../imgs/0.png&quot;document.getElementById(&quot;draw&quot;).addEventListener(&apos;click&apos;, function () {    var cv = document.getElementById(&apos;canvas1&apos;);    var ct = cv.getContext(&quot;2d&quot;);    ct.drawImage(img, 0, 0, 200, 200);});//展示按钮document.getElementById(&quot;show&quot;).addEventListener(&apos;click&apos;, function () {    document.getElementById(&quot;canvas1&quot;).style.width = &apos;200px&apos;;    document.getElementById(&quot;canvas1&quot;).style.height = &apos;400px&apos;;})</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p><img src="/2018/11/19/前端画图Canvas简单运用/test2.png" alt=""></p></li><li><p>没有图片唉！</p></li></ul><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>我们将canvas设置为display:none，但是该元素还是存在页面中的，并且占有一定的面积，只是因为设置为不显示，所以视觉上并没有占用页面的空间。</li><li>之前说过，canvas是画布，画图是将图片画在canvas元素上，那么既然存在，不管别人看不看得到，我们画图的时候没有影响</li><li>而将canvas宽高设置为0，那么该元素虽然依旧存在页面中，但是一个没有任何大小的元素，真正的意义是依旧存在页面中吗？谁能将一幅画画在面积为0的画板上呢？</li><li>所以，对于canvas的理解，就是这样，它就是一个容器，就是用来存放画出来的图像的一个容器。</li></ul><h1 id="五、canvas图片下载"><a href="#五、canvas图片下载" class="headerlink" title="五、canvas图片下载"></a>五、canvas图片下载</h1><ul><li>针对与摄像头拍照，我们需要将”拍”的照片保存下来，其实就是将canvas中画出来的图像保存下来，</li><li>然后目前的情况也就是我们只是拥有一个存在于页面有展示效果的视觉图像而已，以及一个保存这个图像的元素</li><li>那么我们如何将这个元素中的画面以图片文件形式保存下来呢？</li><li>其实很简单，有以下几步</li></ul><p>##　１、获得图片文件形式</p><ul><li><p>文件，其实也是一组数据，我们只要拿到这组数据就能实现文件下载</p><ul><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">'canvas1'</span>);</span><br><span class="line"><span class="comment">//获得图片的base64加密字符串</span></span><br><span class="line"><span class="keyword">var</span> imgdata = ctx.toDataURL(<span class="string">"image/png"</span>, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过ctx.toDataURL方法能够将canvas元素中的图像元素转成文件数据路径</p></li></ul></li><li><p>接下来，有了文件数据路径。我们可以通过a标签来进行下载该文件</p><ul><li><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置文件名字，并生成a标签链接文件直接执行鼠标点击事件进行下载</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">type</span> = <span class="string">'jpg'</span></span><br><span class="line"><span class="keyword">var</span> filename = <span class="string">'canvas画图.'</span> + <span class="keyword">type</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line"><span class="comment">//设置a链接元素为文件数据路径，点击时候就能直接下载</span></span><br><span class="line">a.href = imgdata;</span><br><span class="line">a.download = filename;</span><br><span class="line"><span class="comment">//然后生成鼠标点击事件</span></span><br><span class="line"><span class="comment">// a.click()</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">'MouseEvents'</span>);</span><br><span class="line">event.initMouseEvent(<span class="string">'click'</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="built_in">window</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//执行a标签元素的鼠标点击事件，就相当于是在页面中用鼠标点击了a链接，实现下载</span></span><br><span class="line">a.dispatchEvent(event);</span><br></pre></td></tr></table></figure></li><li><p>说明一下：其实从10行开始到结束的代码，效果等同于第九行的a.click()，就是为了能够不实用鼠标点击页面元素而实现a的点击事件</p></li><li><p><img src="/2018/11/19/前端画图Canvas简单运用/down0.png" alt=""></p></li><li><p><img src="/2018/11/19/前端画图Canvas简单运用/down1.png" alt=""></p></li><li><p>到此，我们就把canvas中的图像保存下来了，有人应该注意到，png格式，对于没有被填充的canvas范围，在图片中是透明背景。</p></li><li><p>除了png格式，还支持jpg、bmp、gif等格式，视自己的需求来吧</p></li></ul></li></ul><h1 id="六、摄像头拍照"><a href="#六、摄像头拍照" class="headerlink" title="六、摄像头拍照"></a>六、摄像头拍照</h1><ul><li>其实摄像头拍照功能，我们也能够利用canvas画图来实现</li><li>按照我们之前说的，利用canvas只要能够将画面元素拿到，就能够将该元素区域中的图像画到canvas中，然后下载</li><li>上面已经说了后面的步骤，所以我们要利用摄像头中拍照，那么到目前我们要解决的事情就只有两个了：<ul><li>1、拿到摄像头中拍摄到的画面展示在页面中</li><li>2、将页面中展示摄像头页面的元素获取到，给canvas画下来</li></ul></li></ul><h2 id="打开摄像头"><a href="#打开摄像头" class="headerlink" title="打开摄像头"></a>打开摄像头</h2><h3 id="先贴代码，然后再解释"><a href="#先贴代码，然后再解释" class="headerlink" title="先贴代码，然后再解释"></a>先贴代码，然后再解释</h3><ul><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">navigator.mediaDevices.getUserMedia(&#123;</span><br><span class="line">                    <span class="string">"video"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(stream);</span><br><span class="line">                    $<span class="keyword">this</span>.MediaStreamTrack = <span class="keyword">typeof</span> stream.stop === <span class="string">'function'</span> ? stream : stream.getTracks()[<span class="number">1</span>];</span><br><span class="line">                    $<span class="keyword">this</span>.video.srcObject = stream;</span><br><span class="line">                    $<span class="keyword">this</span>.video.play();</span><br><span class="line">                &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(err);</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><h4 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h4><ul><li><p>Navigator 对象包含有关浏览器的信息 ，</p></li><li><p>注释：没有应用于 navigator 对象的公开标准，不过所有浏览器都支持该对象 </p></li><li><p>描述：Navigator 对象包含的属性描述了正在使用的浏览器。可以使用这些属性进行平台专用的配置。</p><p>虽然这个对象的名称显而易见的是 Netscape 的 Navigator 浏览器，但其他实现了 JavaScript 的浏览器也支持这个对象。</p><p>Navigator 对象的实例是唯一的，可以用 Window 对象的 navigator 属性来引用它。</p><p>对于这个对象，可以去网上查查，今天我们关注的并不是它</p></li></ul><h4 id="mediaDevices"><a href="#mediaDevices" class="headerlink" title="mediaDevices"></a>mediaDevices</h4><ul><li><p>上面说的Navigator对象很牛逼，牛逼到我们能够获得当前所使用环境的很多信息，包括浏览器，当前系统等等</p></li><li><p>而mediaDevices，则是一个API接口，该接口提供了访问链接媒体输入的设备，如我们使用的摄像头、照相机和麦克风，以及屏幕共享等。 这些媒体输入设备,都能通过该接口来访问链接以便调用</p></li><li><p>链接可以去网站上看看详细的文档资料</p><p>​    <a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/</a></p><p>进去后点击左上角技术&gt;&gt;&gt;API/dom  </p><p>能够查看所有的API文档，然后找到mediaDevices和Navigator自行学习</p></li><li><p>有了mediaDevices，只是给我们提供了媒体输入设备链接，而我们要使用设备，还需要一个方法，没错，就是代码中的getUserMedia()</p></li></ul><h4 id="mediaDevices-getUserMedia"><a href="#mediaDevices-getUserMedia" class="headerlink" title="mediaDevices.getUserMedia()"></a>mediaDevices.getUserMedia()</h4><ul><li><p>该方法会使用户给予使用媒体输入的许可 ，媒体输入会产生一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaStream" target="_blank" rel="noopener"><code>MediaStream</code></a>，里面包含了请求的媒体类型的轨道 。</p></li><li><p>MediaStream是一个流，这个流可以包括视频轨道（来自硬件或者虚拟视频源，比如相机、视频采集设备和屏幕共享服务等等 ）、音频轨道（同样来自硬件或虚拟音频源，比如麦克风、A/D转换器等等 ），也可能是其他轨道</p></li><li><p>这个函数的参数也比较简单，就是一个对象，这个对象就是表示我们要请求使用的媒体</p><ul><li><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;</span> <span class="attr">audio:</span> <span class="literal">true</span><span class="string">,</span> <span class="attr">video:</span> <span class="literal">true</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>上面这个代码表示没有任何要求，只要使用音频和视频的媒体</p></li><li><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="attr">  audio:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">  video:</span> <span class="string">&#123;</span> <span class="attr">width:</span> <span class="number">1280</span><span class="string">,</span> <span class="attr">height:</span> <span class="number">720</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>而这上面代码是说，我要使用音频和视频媒体输入设备，但是视频设配我要1280x720的分辨率</p></li><li><p>等等，这些参数我们可以灵活使用，而这些东西在上面分享的url里面都有，可以自行去看文档学习</p></li></ul></li><li><p>说完参数，那么来看一下返回值：Promise</p><ul><li>其实这个对象没多大深度，就是表示异步操作最终完成或者失败的对象 </li><li>也就是说，我们请求使用设备，成功了，这个对象就表示成功了，失败了，就表示失败了</li><li>它的本质就是一个绑定了回调函数的对象，而不是将回调函数传入函数内部</li><li>所以我们用.then(function(){})来执行请求设备许可后的处理方法</li><li>而如果请求失败或者设备不可用。会回调<code>PermissionDeniedError</code>  或者<code>NotFoundError</code>  ，我们用链式调用.catch(function(){})来处理异常</li><li>注意：有可能这个对象既不返回允许，也不返回拒绝，因为用户不是百分百会选择允许使用或者拒绝使用，也可能用户什么都不选</li><li>好了，闲话不多说，简单聊一聊，具体的去看文档资料学习吧</li><li>接下来说一下获得使用设备的许可之后，我们怎么做</li></ul></li></ul><h4 id="Promise-then-function-回调"><a href="#Promise-then-function-回调" class="headerlink" title="Promise.then(function(){})回调"></a>Promise.then(function(){})回调</h4><ul><li>刚刚说过，在then绑定一个回调函数，可以用来处理获得许可后的方法，那么我们就来看一下这里的代码</li><li>这里，表示我们取得使用权，那么我们就只需要处理反馈给我们的stream(流)就可以了</li><li>然后，我们获得视频轨道（后面我们需要关闭摄像头的），当然，在代码中我们为了严谨，还是做了一步判断，就简单来谈一下吧<ul><li>$this.MediaStreamTrack = typeof stream.stop === ‘function’ ? stream : stream.getTracks()[1];</li><li>这个我们先判断返回的流stream是不是一个函数，如果是的话，那么有可能这个流里面包含的不仅仅是一个视频轨道，所以在这进行了判断，更为严谨。三元表达式就不解释了吧。</li></ul></li><li>处理完stream之后，就非常简单了，我们想要在页面上展示视频，就是使用video，那么通过document获得页面元素video的dom对象video（因为懒得想名字了，就直接var video了。别误会它是什么东西，就是通过id获取的页面元素）</li><li>$this.video.srcObject = stream;</li><li>然后，就给video这个对象的srcObject赋值为当前的stream，完美搞定<ul><li>这里需要注意一下，有的帖子中写的是video.src = stream，可坑死了</li><li>因为之前没写过，所以刚开始就直接赋值的别人的代码，结果没画面，但是摄像头打开了</li><li>就是因为属性不是src，而是srcObject</li><li>于是乎，就去了上边链接的网站上看了很久文档，才慢慢搞明白怎么回事，然后自己封装成了自己的组件，以备不时之需，嘿嘿嘿</li></ul></li><li>虽说路径已经配好了，不过不觉得还差点什么吗？没错，video没有开始播放啊，不解释了，.play()</li></ul><h2 id="拍照"><a href="#拍照" class="headerlink" title="拍照"></a>拍照</h2><ul><li><p>ok，摄像头画面我们有了，那么就该”拍照”了吧，为什么把拍照两个字用引号引起来？还不懂吗？因为压根就不是拍照，而是canvas画图</p></li><li><p>这一步就非常简单了，照旧，在页面上添加一个 拍照 按钮，然后点击事件里面代码如下：</p><ul><li><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">this</span>.context.drawImage($<span class="keyword">this</span>.video, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">400</span>);</span><br></pre></td></tr></table></figure></li><li><p>一行代码搞定，就是直接将video像之前的img一样，直接放进去就OK了</p></li></ul></li></ul><h2 id="关闭摄像头"><a href="#关闭摄像头" class="headerlink" title="关闭摄像头"></a>关闭摄像头</h2><ul><li>记得关闭摄像头</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">this</span>.MediaStreamTrack.<span class="built_in">stop</span>();</span><br></pre></td></tr></table></figure><h2 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h2><h3 id="画面出不来"><a href="#画面出不来" class="headerlink" title="画面出不来"></a>画面出不来</h3><ul><li><p>别急别急，有可能是浏览器不兼容的问题</p></li><li><p>那么我们通过Navigator.mediaDevices来请求摄像头，可能因为浏览器问题而出现错误，别急，我们还有另一种办法</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">navigator.getMedia(&#123;</span><br><span class="line">                    <span class="string">"video"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(stream);</span><br><span class="line">                    $<span class="keyword">this</span>.MediaStreamTrack = stream.getTracks()[<span class="number">1</span>];</span><br><span class="line">                    $<span class="keyword">this</span>.video.srcObject = (<span class="built_in">window</span>.webkitURL).createObjectURL(stream);</span><br><span class="line">                    $<span class="keyword">this</span>.video.play();</span><br><span class="line">                &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(err);</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure></li><li><p>不过这种就是会返回一个函数</p></li></ul><h3 id="拍照无效果？"><a href="#拍照无效果？" class="headerlink" title="拍照无效果？"></a>拍照无效果？</h3><ul><li>这个不解释了，有这个问题很大部分应该就是画图中出现的那两个问题吧，如果当时你不知道为什么会出现那两种情况，那么当你做到摄像头拍照的时候就有可能会遇到了</li><li>好了，这个不解释，但是下面我们来完善一下页面，并且看看为什么会出现之前提出的两个问题</li></ul><h1 id="七、完善"><a href="#七、完善" class="headerlink" title="七、完善"></a>七、完善</h1><h2 id="页面效果完善"><a href="#页面效果完善" class="headerlink" title="页面效果完善"></a>页面效果完善</h2><ul><li>嘿嘿，说到这，我要提要求了，我们一般摄像头拍摄，是不是有需要弹出层的？有需要将影像固定在某个区域的，反正肯定不会是在页面最左上角吧？那样丑死了。</li><li>ok，那么我们就来看一下吧。最简单的思路就是，将video元素和canvas元素共同放在同一个容器中，这样不管需求想要将影像在哪呈现，只要把这个容器拿过去就OK了，里面什么都不需要动。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> id=<span class="string">"camera"</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> id=<span class="string">"contentHolder"</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">video</span> id=<span class="string">"video"</span> <span class="attribute">width</span>=<span class="string">"640"</span> height=<span class="string">"480"</span> autoplay&gt;&lt;/video&gt;</span><br><span class="line">&lt;<span class="selector-tag">canvas</span>  id=<span class="string">"canvas"</span> <span class="attribute">width</span>=<span class="string">"640"</span> height=<span class="string">"480"</span>&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> id=<span class="string">"buttons"</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">button</span> id=<span class="string">"btn_snap"</span> class=<span class="string">"btn btn_blue"</span>&gt;拍照&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li><p>ok，我的页面（老脸很红，这明明是朋友发来的页面）时这个样子滴，一个大的容器id = “camera”，而里面分两块div，一个是contentHolder用来呈现影响video以及拍照后保存画面的vanvas，另一个是存放按钮</p></li><li><p>我草，为什么会这样</p><p><img src="/2018/11/19/前端画图Canvas简单运用/h0.png" alt=""></p><ul><li>为什么？</li></ul><p><img src="/2018/11/19/前端画图Canvas简单运用/h1.png" alt=""></p></li></ul><ul><li>现在能够看到，原来是canvas，当初我们实验的时候没考虑过页面美化的问题吧？那么这个canvas怎么办？</li><li>很简单啦，将canvas设置为none不就行了？</li><li>但是，千万别傻傻地将canvas设置宽高为0，然后再改回来，这样没法画图的，上面的实验也说过了</li></ul><h2 id="js完善"><a href="#js完善" class="headerlink" title="js完善"></a>js完善</h2><ul><li><p>ok，如果按照之前设置为none之后，那么后面可能会没有画面，这个没关系，还记的之前的canvas补充里面的实验吗？就那么解决</p></li><li><p>但是还是有点担心，在将canvas设置为display:block之前，千万别忘记吧video设置为display:none，因为我们的容器只能同时容纳其中一个的大小，是为了美观，同时也是为了造成一种假象，那就是视频和拍照都在同一个容器里面，其实是两个元素（video和canvas）进行切换的</p></li><li><p>代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">this</span>.video.style.display = <span class="string">"none"</span>;</span><br><span class="line">$<span class="keyword">this</span>.canvas.style.display = <span class="string">"block"</span>;</span><br><span class="line">$<span class="keyword">this</span>.context.drawImage($<span class="keyword">this</span>.video, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">400</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul><li>最后就是个人封装的组件，代码就不贴在这了，单独贴到一个文章中吧</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;朋友遇到的情况，属于前端的问题，是需要打开摄像头来拍照，关于这个问题，他找到了我让我来帮他解决，不过由于我的前端
      
    
    </summary>
    
      <category term="前端" scheme="https://it233.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://it233.github.io/categories/%E5%89%8D%E7%AB%AF/js/"/>
    
    
      <category term="实录" scheme="https://it233.github.io/tags/%E5%AE%9E%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>java详解jvm工作原理和流程</title>
    <link href="https://it233.github.io/2018/11/15/java%E8%AF%A6%E8%A7%A3jvm%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://it233.github.io/2018/11/15/java详解jvm工作原理和流程/</id>
    <published>2018-11-15T07:39:33.000Z</published>
    <updated>2018-11-16T02:00:52.069Z</updated>
    
    <content type="html"><![CDATA[<p>【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！</p><hr><p>[TOC]</p><h1 id="一、浅说java"><a href="#一、浅说java" class="headerlink" title="一、浅说java"></a>一、浅说java</h1><p>说起java,人们首先想到的是java编程语言,然而事实上,Java是一种技术,它由四方面组成:</p><ul><li>java编程语言</li><li>java类文件格式</li><li>java虚拟机</li><li>java应用程序接口(Java API)</li></ul><p>其关系如:</p><p><img src="/2018/11/15/java详解jvm工作原理和流程/java关系.png" alt=""></p><p>java平台由Java虚拟机和Java应用程序接口搭建,java语言则是进入这个平台的通道,用Java语言编写并编译的程序可以运行在这个平台上.</p><p>这个平台结构:</p><p><img src="/2018/11/15/java详解jvm工作原理和流程/平台结构.png" alt=""></p><p>运行期环境代表着Java平台,开发人员编写Java代码(.java文件),然后将之编译成字节码(.class)文件,在然后字节码被装入内存,一旦字节码进入虚拟机,它就会被解释器解释执行,或者是被即时代码发生器有选择的转换成机器码执行. </p><p>java程序经过一次编译之后，将java代码编译为字节码也就是class文件，然后在不同的操作系统上依靠不同的java虚拟机进行解释，最后再转换为不同平台的机器码，最终得到执行。这样我们是不是可以推演，如果要在mac系统上运行，是不是只需要安装mac java虚拟机就行了。 </p><p>JVM在它的生命周期中有一个明确的任务,那就是运行java程序,因此当Java程序员启动的时候,就产生JVM的一个实例;当程序运行结束的时候,该实例也就跟着消失了 </p><p>在Java平台的结构中,可以看出,Java虚拟机(JVM)处在核心的位置,是程序与底层操作系统和硬件无关的一个关键.下方是移植接口. </p><p>移植接口由两部分组成：适配器 和 Java操作系统</p><p>其中依赖于平台的部分被称为适配器</p><p>JVM通过移植接口在具体的平台和操作系统上实现;在JVM的上方是Java的基本类库和扩展类库以及他们的API,利用Java API编写的应用程序(application)和小程序(java applet)可以在任何Java平台上运行而无需考虑底层平台,就是因为有Java虚拟机(JVM实现了程序与操作系统的分离,从而实现了Java的平台无关性)</p><h1 id="二、JVM基本概念和运行过程"><a href="#二、JVM基本概念和运行过程" class="headerlink" title="二、JVM基本概念和运行过程"></a>二、JVM基本概念和运行过程</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念:"></a>1.基本概念:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JVM是可运行Java代码的假象计算机（虚拟计算机）</span><br></pre></td></tr></table></figure><p>JVM包括：</p><ul><li>一套字节码指令集</li><li>一组寄存器</li><li>一个栈</li><li>一个垃圾回收</li><li>堆</li><li>一个存储方法域</li></ul><p>JVM是运行在操作系统之上的,它与硬件没有直接的交互 </p><h2 id="2-运行过程"><a href="#2-运行过程" class="headerlink" title="2.运行过程"></a>2.运行过程</h2><p>Java源文件 通过 编译器 能够产生相应的 字节码文件(.Class文件) ,而字节码文件又通过 Java虚拟机中的解释器 编译成 特定机器上的机器码</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">java源文件</span>  <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;  <span class="comment">编译器</span>  <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;  <span class="comment">字节码文件</span></span><br><span class="line"><span class="comment">字节码文件</span>  <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">JVM</span>  <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;  <span class="comment">机器码</span></span><br></pre></td></tr></table></figure><p>每一种平台 的 解释器是不同的, 但是实现的 虚拟机 是 相同 的,这也就是Java为什么能够 跨平台 的原因了 </p><p>当一个 程序从开始运行 这时 虚拟机 就开始 实例化 了,  多个程序 启动就会存在 多个虚拟机实例. 程序 退出或关闭, 则虚拟机 实例消亡 ,  </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">注意:</span></span><br><span class="line">多个虚拟机实例之间数据不能共享</span><br></pre></td></tr></table></figure><h2 id="3-三种JVM"><a href="#3-三种JVM" class="headerlink" title="3.三种JVM:"></a>3.三种JVM:</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- Sun 公司的 HotSpot</span><br><span class="line">- BEA 公司的 JRockit</span><br><span class="line">- IBM 公司的 J9 JVM</span><br><span class="line"></span><br><span class="line">在 JDK1.7 及其以前我们所使用的都是 Sun 公司的 HotSpot, 但是由于 Sun公司 和 BEA公司都被 oracle 收购</span><br><span class="line"></span><br><span class="line">jdk1.8 将采用 Sun 公司的<span class="built_in"> HotSpot </span>和 BEA 公司的 JRockit 两个JVM中 精华 形成  jdk1.8的JVM</span><br></pre></td></tr></table></figure><h1 id="三、JVM的体系结构"><a href="#三、JVM的体系结构" class="headerlink" title="三、JVM的体系结构"></a>三、JVM的体系结构</h1><p><img src="/2018/11/15/java详解jvm工作原理和流程/jvm结构图1.png" alt=""></p><p><img src="/2018/11/15/java详解jvm工作原理和流程/jvm结构图2.png" alt=""></p><h2 id="1-Class-Loader类加载器"><a href="#1-Class-Loader类加载器" class="headerlink" title="1.Class Loader类加载器"></a>1.Class Loader类加载器</h2><p>负责加载.class文件,class文件在文件开头有特定的文件标示,并且ClassLoader负责class文件的加载等.但是至于它是否可以运行,则由Execution Engine(执行引擎)决定 </p><ul><li>定位和导入 二进制.class文件</li><li>验证 导入类的正确性</li><li>为类 分配 初始化 内存</li><li>帮助 解析 符号引用</li></ul><h2 id="2-Native-Interface-本地接口"><a href="#2-Native-Interface-本地接口" class="headerlink" title="2.Native Interface 本地接口"></a>2.Native Interface 本地接口</h2><p>本地接口的作用是 融合不同的编程语言为Java所用, 它的 初衷 是融合 C/C++ , Java诞生的时候C/C++横行的时候,想要立足,必须调用C/C++程序, 于是就在内存中专门开辟了一块区域处理标记为 native的代码.</p><p>具体做法: Native Method Stack中登记native 方法,在Execution Engine执行的时候加载native libraies(本地方法库)</p><p>不过目前该方法使用的越来越少了,除非是与硬件有关的应用,</p><p>如:</p><p>通过Java程序驱动打印机,或者Java系统管理生产设备,在企业级应用中已经比较少见</p><p>因为现在的 异构领域空间 的通信很发达 ,比如:可以使用 Socket通信, 也可以使用 Web Service等</p><h2 id="3-Excution-Engine-执行引擎"><a href="#3-Excution-Engine-执行引擎" class="headerlink" title="3.Excution Engine 执行引擎:"></a>3.Excution Engine 执行引擎:</h2><p>执行 包在 装载类 的方法中的 指令,也就是 方法</p><h2 id="4-Runtime-data-area-运行数据区"><a href="#4-Runtime-data-area-运行数据区" class="headerlink" title="4.Runtime data area 运行数据区:"></a>4.Runtime data area 运行数据区:</h2><p>虚拟机内存或者 JVM内存, 从整个 计算机内存中开辟 一块内存 存储 JVM用到的 对象,变量等</p><p>运行区数据又分很多小区,分别为：方法区  堆  虚拟机栈  本地方法栈 程序计数器 </p><h2 id="5-JVM数据运行区详解-栈管运行-堆管存储"><a href="#5-JVM数据运行区详解-栈管运行-堆管存储" class="headerlink" title="5.JVM数据运行区详解(栈管运行,堆管存储):"></a>5.JVM数据运行区详解(栈管运行,堆管存储):</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">说明: jvm调优主要就是 优化Heap堆和<span class="function"><span class="keyword">Method</span> <span class="title">Area</span>方法区</span></span><br></pre></td></tr></table></figure><p><img src="/2018/11/15/java详解jvm工作原理和流程/jvm数据运行区.png" alt=""></p><ul><li><p>方法区  Method Area </p><ul><li>方法区是各个线程共享的区域，</li><li>所有 字段  和 方法字节码 ,以及一些特殊方法如 构造函数, 接口代码 也在此定义.</li><li>简单说,所有 定义的方法的信息 都保存在该区域,属于 共享区间 </li><li>静态变量 + 常量 + 类信息 + 运行时常量池 存在方法区中 </li></ul></li><li><p>堆 </p><ul><li>java堆也是线程共享的区域，我们的类的实例就放在这个区域(而指向该实例变量的引用存在栈)，</li><li>可以想象你的一个系统会产生很多实例，因此java堆的空间也是最大的。</li><li>如果java堆空间不足了，程序会抛出OutOfMemoryError异常。 </li><li>也是 GC（垃圾回收机制） 主要的 回收区,  一个JVM 实例只存在 一个堆 类内存,堆内存的 大小 是可以 调节 的 </li></ul></li><li><p>虚拟机栈  VM Stack  </p><ul><li><p>栈是什么 ：栈也叫 栈内存, 主管Java 程序的运行, 是在  线程创建时 创建, 他的生命期是跟随 线程的生命期, 线程结束 栈内存也就 释放,  对于栈来说 不存在垃圾回收问题, 只要线程已结束该栈就over,生命周期和线程一致, 是 线程私有的 </p></li><li><p>基本类型 的变量和 对象的引用 变量都是在函数的 栈内存中分配 </p></li><li><p>栈存储什么：栈帧中主要保存 3类数据:</p><ul><li>本地变量(Local Variables): 输入参数和输出参数以及方法内的变量</li><li>栈操作( Operand Stack ): 记录出栈,入栈的操作</li><li>栈帧数据( Frame Data ): 包括类文件,方法等等</li></ul></li><li><p>栈运行原理</p><ul><li>栈中的 数据 都是以 栈帧的格式 存在, 栈帧是一个 内存区块, 是一个 数据集, 是一个有关 方法 和运行期 数据 的 数据集</li><li>当一个方法A被调用时就产生了一个栈帧F1,并被压入到栈中,A方法有调用了B方法,于是产生栈帧F2也被压入栈,B方法有调用了C方法,于是产生的栈帧F3也被压入栈……依次执行完毕后,先弹出后进……F3,再弹出F2,F1 </li><li>遵循 先进后出/后进先出 原则  </li></ul></li><li><p>就是说，java栈是每个线程私有的区域，它的生命周期与线程相同，一个线程对应一个java栈，每执行一个方法就会往栈中压入一个元素，这个元素叫“栈帧”，而栈帧中包括了方法中的局部变量、用于存放中间状态值的操作栈，这里面有很多细节。如果java栈空间不足了，程序会抛出StackOverflowError异常，想一想什么情况下会容易产生这个错误，对，递归，递归如果深度很深，就会执行大量的方法，方法越多java栈的占用空间越大。 </p></li></ul></li><li><p>本地方法栈  Native Method Stack </p><ul><li>本地方法栈角色和java栈类似，只不过它是用来表示执行本地方法的，它的具体做法是Native Method Stack中登记native方法，本地方法栈存放的方法调用本地方法接口，在Execution Engine执行时候加载native libraies ，最终调用本地方法库，实现与操作系统、硬件交互的目的。 </li></ul></li><li><p>程序计数器</p><ul><li>PC寄存器（有的这么叫，这里提一下），说到这里我们的类已经加载了，实例对象、方法、静态变量都去了自己该去的地方，那么问题来了，程序该怎么执行，哪个方法先执行，哪个方法后执行，这些指令执行的顺序就是PC寄存器在管，它的作用就是控制程序指令的执行顺序 （Register，也是记录，登记，寄存的意思，就是用来管理的）</li><li>每个线程都一个 程序计算器, 就是一个 指针, 指向  方法区中的 方法字节码 (下一个将要执行的指令代码),由  执行引擎读取  下一条指令,是一个 非常小 的内存空间,几乎可以 忽略不计 </li></ul></li></ul><h2 id="6-堆内存"><a href="#6-堆内存" class="headerlink" title="6.堆内存"></a>6.堆内存</h2><p>  堆内存分为3部分: </p><p>  <img src="/2018/11/15/java详解jvm工作原理和流程/堆内存.png" alt=""></p><p>  1.新生区</p><ul><li>新生区是 类 的 诞生,成长,消亡 的区域.</li><li>一个 类 在这里 产生,应用, 最后被 垃圾回收器收集,结束生命</li><li><p>新生区又分为两部分:</p><ul><li>伊甸区(Eden space) :所有的类都是在伊甸区被new出来的 </li><li>幸存者区(Survivor Space) :有两个,0区和1区 <ul><li>当伊甸区的空间用完时,程序有需要创建对象,JVM的垃圾回收器将对伊甸区进行垃圾回收(Minor GC),将伊甸区中的剩余对象移动到幸存0区, </li><li>若0取也满了,对该区域进行垃圾回收,然后移动到1区 </li><li>1区满了移动到养老区(Tenure Generation Space) </li><li>养老区满了,这时候将产生Major GC(FullGC),进行养老区的内存清理. </li><li>若养老区执行Full GC之后发现依然无法进行对象的保存,会产生OOM异常(OutOfMemoryError,内存溢出) </li><li>所以，如果出现java.lang.OutOfMemoryError:Java heap space异常,说明Java虚拟机的堆内存不够 ，原因有二：<ul><li>Java虚拟机的堆内存 设置 不够,可以通过参数 -Xms,  -Xmx  调整 (jvm调优方面会说)</li><li>代码中创建了 大量大对象,并且长时间 不能被 垃圾收集器 收集(存在被引用) </li></ul></li></ul></li></ul><p>2.养老区</p></li><li><p>用于保存从新生区筛选出来的Java对象,一般 池对象  都在这个区域活跃 </p></li><li>年老代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在） </li><li>内存大小相对会比较大，垃圾回收也相对没有那么频繁（譬如可能几个小时一次） </li><li>年老代主要采用压缩的方式来避免内存碎片（将存活对象移动到内存片的一边，也就是内存整理）。</li><li><p>当然，有些垃圾回收器（譬如CMS垃圾回收器）出于效率的原因，可能会不进行压缩。 （这些调优篇细讲）</p><p>3.永久区（Permanent Space ）</p></li><li><p>是一个 常驻内存区域 , 用于存放 JDK自身 所携带的 class,interface的元数据 </p></li><li>也就是说它存储的是 运行环境必须 的类信息,被装载进此区域的数据是 不会被  垃圾回收器 回收 掉的 </li><li>关闭JVM 才会释放  此区域所占用的内存 </li><li>如果出现java.lang.OutOfMemoryError:PermGen space,说明是Java虚拟机对永久代Perm内存设置不够 ，原因也有两点：<ul><li>程序启动需要加载大量的第三方jar包. 如:在一个tomcat下部署了太多的应用 </li><li>大量动态反射生成的类不断被加载,最终导致Perm区被占满 </li></ul></li><li>关于永久区的个版本：<ul><li>jdk1.6之前:常量池分配在永久带</li><li>jdk1.7:有,但已经逐步”去永久带”</li><li>jdk1.8之后:无(java.lang.OutOfMemoryError:PermGen space这种错误将不会出现在JDK1.8中)</li><li>下面两张图片解释一下</li></ul></li></ul><p><img src="/2018/11/15/java详解jvm工作原理和流程/永久区1.png" alt=""></p><p><img src="/2018/11/15/java详解jvm工作原理和流程/元空间.png" alt=""></p><h1 id="四、-方法区和堆内存的异议"><a href="#四、-方法区和堆内存的异议" class="headerlink" title="四、 方法区和堆内存的异议:"></a>四、 方法区和堆内存的异议:</h1><p>实际而言,方法区和堆一样,是各个线程共享的内存区域,它用于存储虚拟机加载的: </p><p>类信息+普通常量+静态常量+编译器变异后的代码</p><p>虽然JVM规范将方法区描述为堆的一个逻辑部分,但它却还有一个别名叫做Non-Heap(非堆),目的就是要和堆分开.</p><p>对于HotSpot虚拟机,很多开发者习惯将方法区称之为”永久代(Parmanent Gen)”,但严格本质上说两者不同,或者说使用永久代来实现方法区而已,永久代是方法区的一个实现,jdk1.7的版本中,已经将原本放在永久代的字符串常量池移走</p><p>常量池(Constant Pool)是方法区的一部分,class文件除了有类的版本,字段,方法,接口等描述信息外,还有一项信息就是常量池,这部分内容将在类加载后进入方法区的运行时常量池中存放.</p><h1 id="五、简单补充"><a href="#五、简单补充" class="headerlink" title="五、简单补充"></a>五、简单补充</h1><p>堆内存调优简介 </p><p><img src="/2018/11/15/java详解jvm工作原理和流程/堆内存优化简介.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;一、浅说java&quot;&gt;&lt;a href=&quot;#一、浅说java&quot; class=&quot;he
      
    
    </summary>
    
      <category term="java" scheme="https://it233.github.io/categories/java/"/>
    
      <category term="jvm" scheme="https://it233.github.io/categories/java/jvm/"/>
    
    
      <category term="笔记" scheme="https://it233.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java中的关键字native</title>
    <link href="https://it233.github.io/2018/11/15/Java%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97native/"/>
    <id>https://it233.github.io/2018/11/15/Java中的关键字native/</id>
    <published>2018-11-15T02:55:05.000Z</published>
    <updated>2018-11-28T06:48:29.012Z</updated>
    
    <content type="html"><![CDATA[<p>【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！</p><hr><p>[TOC]</p><h1 id="一、简单介绍"><a href="#一、简单介绍" class="headerlink" title="一、简单介绍"></a>一、简单介绍</h1><p>native关键字</p><ul><li><p>众所周知，java是跨平台的语言，既然跨平台，就要牺牲对底层的控制，所以java对于底层的控制就依赖于其他语言的帮助，而这就是native的作用</p></li><li><p>native是用作java和其他语言进行协作时用的，也就是native后的方法的实现不是用java写的。既然不是java写的，那肯定看不到它的源码了</p></li><li><p>native修饰的方法时一个原生态方法,方法对应的实现不是在当前文件,而是在用其他语言(如C或者C++)实现的文件中.并且被编译成了dll文件。</p></li><li>这些方法的实现体在dll文件中，jdk的源码中并不包含，所以是看不到的。对于不同的平台，他们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的</li><li>Java语言本身不能对操作系统底层进行访问和操作,但是可通过JNI接口调用其他语言来实现对底层的访问.</li><li>JNI是Java本机接口(Java Native Interface),是一个本机编程接口,是Java软件开发发工具箱(java Software Development Kit, SDK)的一部分.JNI允许Java代码使用以其他语言编写的代码和代码库.</li><li>Invocation API(JNI的一部分)可以用来将Java虚拟机(JVM)嵌入到本机应用程序中,从而允许程序员代码内部调用java代码</li><li>所以，native的意思就是通知操作系统，我需要这个方法，而你操作系统需要给我实现，我需要使用。而java只需要调用操作系统的方法就行了</li><li>java不是完美的，java的运行速度上比传统的C语言慢许多，java无法直接访问到底层操作系统等缺点。当然，解决方法就是上面说的利用native方法来扩展java程序的功能。以下有实践步骤：是之前做笔记的时候尝试的：</li></ul><h1 id="二、实践理解"><a href="#二、实践理解" class="headerlink" title="二、实践理解"></a>二、实践理解</h1><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用java调用<span class="keyword">C</span>的<span class="string">"sayHello"</span></span><br></pre></td></tr></table></figure><p>1.创建一个java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloNative</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"HelloNative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"static-access"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HelloNative().sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个sayHello()方法，native标识该方法的实现在非当前文件，在static静态快中加载的library(HelloNative)中</p><p>运行main()之后出现以下情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>报错信息时说找不到library(“HelloNative”)的路径，因为我们本地就没有这个文件</p><p>2.创建本地方法文件</p><p>我们将Java类HelloNative复制出来，（我给放在了D盘根目录，方便）</p><p>然后在控制台用javac命令将其编译成字节码文件，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">javac</span> <span class="selector-tag">HelloNative</span><span class="selector-class">.jave</span></span><br></pre></td></tr></table></figure><p>注意：如果命令输入目录与.java文件不在同一目录下，javac命令后的文件名要加路径，如图中d:\HelloNative.java：</p><p><img src="/2018/11/15/Java中的关键字native/cmd01.png" alt=""></p><p>然后在用havah编译，获得包含C声明头文件</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">javah HelloNative</span></span><br></pre></td></tr></table></figure><p>注意：在这里，我命令目录与文件目录不在同一路径，报错了，这个命令不会区别路径，而是在当前目录下找d:\HelloNative这个名字的文件，把d:\也当成文件名字的一部分</p><p>到此，我们一共有三个文件了：</p><p><img src="/2018/11/15/Java中的关键字native/files.png" alt=""></p><p>看一下.h文件的内容吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class HelloNative */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_HelloNative</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_HelloNative</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     HelloNative</span></span><br><span class="line"><span class="comment"> * Method:    sayHello</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_HelloNative_sayHello</span><br><span class="line">  (JNIEnv *, jclass);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>创建.c文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后运行gcc命令来生成dll共享库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>命令中的路径是电脑中jdk的安装路径\include</p><p>完成后这样就有5个文件了：</p><p><img src="/2018/11/15/Java中的关键字native/files5.png" alt=""></p><p>然后在用java命令运行一下java代码，就能成功在cmd通过java代码调用c的sayHello方法了</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">java HelloNative</span></span><br></pre></td></tr></table></figure><p>说明：</p><p>从gcc命令开始，没有图和真相了，那是因为我所有的笔记标签的文章都是回头看以前做的笔记的时候，重新整理记录一下，也有的是之前没有记录到的，整理的时候又重新学一遍；也有之前试验过但是现在环境不允许了。</p><p>不过又去了网上看了看帖子，别人的文章有的用的命令不一样，所以具体如何生成dll，尝试一下就行了，只要生成了dll就OK了</p><h1 id="三、步骤总结："><a href="#三、步骤总结：" class="headerlink" title="三、步骤总结："></a>三、步骤总结：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总结一下步骤吧：</span><br></pre></td></tr></table></figure><p>1 先创建java类，在类中加载需要的library，声明要调用的本地方法</p><p>2  使用javac命令编译.java文件，生成字节码文件.class</p><p>3  使用javah命令编译成.h文件，生成包含C声明头的文件</p><p>4  编写c文件（.c），然后通过gcc命令(或者vs C++环境下cl命令)生成dll</p><p>5  然后利用java命令运行Java代码检测是否成功</p><p>其实，上面的这个步骤是反着来的，是因为我们从java介入，往底层找的，真正的顺序应该是先写好的c方法生成dll共享库，然后jvm启动之后留在本地方法区中，随着我们写好java代码之后，如果需要用到本地方法，我们就去找相应的方法直接调用就行了(这部分可以简单看一下jvm方面的知识应该比较容易理解，好了，我再看看jvm的笔记)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;一、简单介绍&quot;&gt;&lt;a href=&quot;#一、简单介绍&quot; class=&quot;header
      
    
    </summary>
    
      <category term="java" scheme="https://it233.github.io/categories/java/"/>
    
      <category term="关键字" scheme="https://it233.github.io/categories/java/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    
      <category term="笔记" scheme="https://it233.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用JPA创建原生sql(不使用实体类)</title>
    <link href="https://it233.github.io/2018/11/13/%E4%BD%BF%E7%94%A8JPA%E5%88%9B%E5%BB%BA%E5%8E%9F%E7%94%9Fsql-%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BD%93%E7%B1%BB/"/>
    <id>https://it233.github.io/2018/11/13/使用JPA创建原生sql-不使用实体类/</id>
    <published>2018-11-13T05:19:38.000Z</published>
    <updated>2018-11-28T06:28:05.778Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一、描述"><a href="#一、描述" class="headerlink" title="一、描述"></a>一、描述</h1><ul><li><p>JPA很强大，嗯，没错，是很强大！</p><pre><code>它是通过JDK5.0注解或者XML描述对象-关系表的映射关系，并能够将在运行中的实体对象持久化到数据库中。</code></pre></li><li><p>并且它也是面向对象查询，也就是将实体类与数据库的表映射，即使不会数据库的开发者，只要能看懂java的类，只要能熟练使用jpa，也能很便捷地操作数据库</p></li><li><p>当然，映射类有其好处，也有弊端。假如说，某个场景下，我需要查询多个表中的数据，并且每个表中只有一到两个字段有用，而整张表的字段又很多，所以有时候就不需要将每个表都完整映射成实体类（不然的话，每次查询就要多查询很多无用的垃圾信息）</p></li><li><p>今天遇到了这种场景，由于是多表联查，但是只需要其中各一个字段，其余的每个表十几个字段都没用。所以就不需要把每张表的数据都查询出来。而个人对于jpa也不熟练，所以踩了很多坑。下面就此记录：</p></li></ul><h1 id="二、实录"><a href="#二、实录" class="headerlink" title="二、实录"></a>二、实录</h1><pre><code>（踩坑全过程，实力坑自己！Pain and happiness!想直接看结果，直接拉下去别看这段了）</code></pre><h3 id="想法1、"><a href="#想法1、" class="headerlink" title="想法1、"></a>想法1、</h3><p>返回map，不用实体类</p><p>1.dao层（Repository）</p><ul><li>就是控制sql语句对数据库进行增删改查。</li><li><p>这里的接口很容易写，只需要继承JpaRepository&lt;entity,object&gt;接口就可以了<br>#<br>  这里需要注意：<br>  1.entity，必须是被管理的类，也就是与数据库进行映射的实体类</p><p>  所以，就坑在这了，一直报错说Repository什么什么类型必须是被映射管理的，而map却不是。奶奶的，继续想办法</p><h3 id="想法2、"><a href="#想法2、" class="headerlink" title="想法2、"></a>想法2、</h3></li></ul><p>创建实体类（不过由于不懂，所以这里没有进行关系映射，就是一个单纯的javaBean，不用仔细说了失败！）</p><p>​    注意：<br>    1.实体类必须与数据库映射才算被映射管理（@Entity注解）</p><pre><code>继续尝试</code></pre><h3 id="想法3、"><a href="#想法3、" class="headerlink" title="想法3、"></a>想法3、</h3><p>映射实体类(但是这次也只写了部分字段，自己需要的)</p><p>​    注意：</p><ul><li>加上注解标明映射之后，又特么脑残踩了个雷（鄙视自己一秒钟）<ul><li>对于这个，说一下吧，由于最初没打算映射，并且需要的数据是多个表的，所以类名就自己起的名字。好家伙，提示table_name没有被映射过！我嘞个擦。所以在@Entity注解加上name属性：</li><li>@Entity(name=”table_name”)最初的时候加错了，写成实体类的名字了，尴尬！这里其实要写表的名字，表明该实体类与那张表映射</li></ul></li><li>与数据库映射的类必须有@Id标明主键(失败一次！吼，不想解释了)</li><li>这一点忍无可忍！错误信息说，表中为not null的字段，必须在实体类中映射！也就是实体类中必须有非空字段的属性！！！<ul><li>吼吼吼！！我连吼三次可以了吧！那我跟映射全部字段有什么区别呢？还是初衷吗？</li></ul></li><li>以上一环扣一环之后，想要按照之前想法，实体类，拜拜！</li><li>经过以上绕的弯路，所以就又绕回来了。哼哼！于是乎：老子不用实体类了，也不继承JpaRepository。</li></ul><h3 id="想法4、"><a href="#想法4、" class="headerlink" title="想法4、"></a>想法4、</h3><p>注解托管Repository！</p><pre><code>奈斯！启动刚开始没报错，之前报错貌似跳过去了！突然之间，XXXXXX that could not be found，我真xxxx了，然后去网上找解决方法，要吐血！各种各样的方法，没用！直到我看到一个帖子：</code></pre><p><img src="/2018/11/13/使用JPA创建原生sql-不使用实体类/1.png" alt="帖子截图"></p><pre><code>一口老血啊！果断不找了！（别学我，因为刚刚在找这个帖子的时候，无意间瞥见另一个帖子，解决方案是：在Application启动类中加上注解：@EnableJpaRepositories(&quot;com.example.repository&quot;)来说明要扫描的类，虽然之前也在启动类中加过注释，但我也记不清这个到底有没有尝试过了，感觉很靠谱，这里说一下！失败了也别来找我,也有可能环境不同）所以！这是一个死循环啊，想要用dao层Repository，OK的，继承JPARepository吧，等等，我jpa有条件的，entity呢？ 好，给你！慢着，我entity不干，先给cp一个数据库表吧，我可不打酱油的！唉，给你cp个表吧，停！cp随便你，但是我有孩子，得带过去，你去问问entity同不同意！尼玛，可怕！！！于是，果断放弃了从dao层入手。</code></pre><h1 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h1><ul><li><p>JPA很强大，嗯，没错，是很强大！</p><p>  又是这句话，没错，我们如果映射实体类的话，那么目前的情况就感觉无用数据太多，而且累赘，要映射好几张表<br>  但是别怕，jpa不但能面向对象查询，还支持原生sql，能够让我们根据自己的想法来实现</p></li><li><p>第一种：使用注解@Query(value=”sqlString”)</p></li><li><p>第二种：entityManager.createNativeQuery(sqlString)</p><p>  第一种，注解在dao层的方法上，由于我自动装配出问题了，并且及早地放弃了，所以没用，</p><p>  第二种，上代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Query query = entityManager.createNativeQuery(<span class="string">"select * from user where id = ?"</span>);</span><br><span class="line">query.setParameter(<span class="number">1</span>,<span class="string">"g10001"</span>);</span><br><span class="line">List list = query.getResultList();</span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   map.put(<span class="string">"name1"</span>,objs.get(<span class="number">0</span>)[<span class="number">0</span>].toString());</span><br><span class="line">   map.put(<span class="string">"name2"</span>,objs.get(<span class="number">0</span>)[<span class="number">1</span>].toString());......</span><br></pre></td></tr></table></figure><p>搞定！list是List&lt;Object[]&gt;类型，里面放的就是一条条数据，而Object[]数组里面是一条数据中的所有字段。</p><p>不过又见几个坑，是网上的帖子，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object os : list)&#123;</span><br><span class="line">Map map = (Map)os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我只求数组（实际上是Object类型的数组）强转Map这波操作！！！！没别的要求</p><h1 id="四、"><a href="#四、" class="headerlink" title="四、"></a>四、</h1><pre><code>诙谐的话语，搞笑而又逗逼！就跟老朋友聊骚，听老朋友牢骚。轻松吗？</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;一、描述&quot;&gt;&lt;a href=&quot;#一、描述&quot; class=&quot;headerlink&quot; title=&quot;一、描述&quot;&gt;&lt;/a&gt;一、描述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JPA很强大，嗯，没错，是很强大！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;它是通过JDK
      
    
    </summary>
    
      <category term="java" scheme="https://it233.github.io/categories/java/"/>
    
      <category term="框架" scheme="https://it233.github.io/categories/java/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="JPA" scheme="https://it233.github.io/categories/java/%E6%A1%86%E6%9E%B6/JPA/"/>
    
    
      <category term="实录" scheme="https://it233.github.io/tags/%E5%AE%9E%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql建表时设置日期默认值及默认修改时间</title>
    <link href="https://it233.github.io/2018/11/12/mysql%E5%BB%BA%E8%A1%A8%E6%97%B6%E8%AE%BE%E7%BD%AE%E6%97%A5%E6%9C%9F%E9%BB%98%E8%AE%A4%E5%80%BC%E5%8F%8A%E9%BB%98%E8%AE%A4%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4/"/>
    <id>https://it233.github.io/2018/11/12/mysql建表时设置日期默认值及默认修改时间/</id>
    <published>2018-11-12T03:10:06.000Z</published>
    <updated>2018-11-15T09:32:08.975Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>#一、简单说明<br>    在做项目的时候，在数据库中基本上都会有关于日期的问题。其中不乏包括日期格式、运算、比较等等。不过这些都很常见了，今天要记录的点，非常简单，不过可能也是很多情况下忽略的东西。</p><pre><code>关于这次记录的东西，就是mysql中时间格式的默认值。很多时候，我们都会对一条数据的相关时间进行记录，比如创建日期，修改日期等等最常见的。而处理这些日期的大部分方法，一般是在后台中获取当前的时间，然后随着数据插入到表中进行保存。下面，要说的是用mysql自带的方法来实现。（如果觉得没多大意义的话，请止步到此吧，如果想了解一下，请继续）</code></pre><p>#二、图文示例</p><pre><code>这里使用的版本是MySQL 5.6</code></pre><p>###1.mysql的日期和时间类型（这里会展示一下各种时间格式，不想看的跳过）</p><pre><code>先来看一下mysql中的日期和时间类型，以及其值的样子</code></pre><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql日期和时间类型.png" alt="mysql的日期和时间类型"></p><pre><code>- 在图中我们能够看到，我给所有的日期和时间类型赋值都是年/月/日 时:分:秒.毫秒- 而最终查询出来的日期格式如列表展示，不同的类型，格式也不同- 其中year类型只能赋值并保存年份，不过这个字段的赋值有点有意思的地方</code></pre><p>####1.1 year类型</p><pre><code>我们先来看看不同的赋值的结果</code></pre><p>1.首先赋值0</p><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql-year-0.png" alt="mysql-year-0"></p><p>2.然后1</p><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql-year-1.png" alt="mysql-year-0"></p><pre><code>应该有人应该猜出来了吧,不过我很好奇的是，这个赋值到底范围是多少，于是在这个过程中又遇到了有趣的事情</code></pre><p>3.然后：</p><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql建表时设置日期默认值及默认修改时间.assets/mysql-year-69.png" alt="mysql-year-69.png"></p><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql建表时设置日期默认值及默认修改时间.assets/mysql-year-70.png" alt="mysql-year-70.png"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">到这里就能看出来，mysql日期虽然年份能够不用写完整的<span class="number">4</span>位，但是对于只写两位数，mysql中还是有点范围的<span class="number">70</span>表示<span class="number">1970</span>，而<span class="number">0</span>表示的是<span class="number">2000</span>，很显然，最多就是<span class="number">99</span>表示<span class="number">1999</span>了，然后从<span class="number">1</span><span class="number">-69</span>表示的是<span class="number">2001</span><span class="number">-2069</span>，所以mysql非完整的年份默认值范围<span class="number">0</span><span class="number">-99</span></span><br></pre></td></tr></table></figure><p>4.完整年份最大值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不要问我怎么来的，我无聊</span><br></pre></td></tr></table></figure><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql建表时设置日期默认值及默认修改时间.assets/mysql-time-maxvalue.png" alt="mysql-time-maxvalue.png"></p><p>###2.正题：设置默认时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个设置是创建该数据的当前时间</span><br></pre></td></tr></table></figure><p>1.使用函数now()</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql中有函数可以在sql语句中直接使用（废话不解释了），<span class="built_in">now</span>()都不陌生</span><br></pre></td></tr></table></figure><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql建表时设置日期默认值及默认修改时间.assets/mysql-default-now.png" alt="mysql-default-now.png"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不过支持<span class="built_in">now</span>()函数的只有datetime和timestamp两种类型，其他三种都不支持</span><br></pre></td></tr></table></figure><p>2.current_（cur系列）</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们可以利用<span class="keyword">default</span> current_timestamp为timestamp类型的设置默认值</span><br><span class="line"></span><br><span class="line">不过很无奈的是，mysql中有current_date和current_time等，但是我这个版本却不能用，</span><br></pre></td></tr></table></figure><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql建表时设置日期默认值及默认修改时间.assets/mysql-default-cur.png" alt="cur.png"></p><p>3.自动记录修改时间</p><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql建表时设置日期默认值及默认修改时间.assets/default-update-insert.png" alt="default-update-insert.png"></p><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql建表时设置日期默认值及默认修改时间.assets/default-update.png" alt="default-update.png"></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在这里能够看到，<span class="built_in">id</span>为<span class="number">1</span>的这条数据时间变成了执行update时候的时间</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于前两天接了新项目，所以写了一半就停下来了，今天有点时间，想着就写完它。勉强看，也算给自己昨个记录</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;#一、简单说明&lt;br&gt;    在做项目的时候，在数据库中基本上都会有关于日期的问题。其中不乏包括日期格式、运算、比较等等。不过这些都很常见了，今天要记录的点，非常简单，不过可能也是很多情况下忽略的东西。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;关于这次记录的
      
    
    </summary>
    
      <category term="DB" scheme="https://it233.github.io/categories/DB/"/>
    
      <category term="MySQL" scheme="https://it233.github.io/categories/DB/MySQL/"/>
    
    
      <category term="mysql" scheme="https://it233.github.io/tags/mysql/"/>
    
      <category term="日期" scheme="https://it233.github.io/tags/%E6%97%A5%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://it233.github.io/2018/11/09/hello-world/"/>
    <id>https://it233.github.io/2018/11/09/hello-world/</id>
    <published>2018-11-09T09:28:16.849Z</published>
    <updated>2018-11-09T07:30:41.525Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="其他" scheme="https://it233.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://it233.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
</feed>
