<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字符串的扩展]]></title>
    <url>%2Fit233.github.io%2F2018%2F12%2F07%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[ES6 加强了对Unicode的支持，并且扩展了字符串对象 字符串的Unicode表示法javaScript允许采用 \uxxxx 形式表示一个字符，其中xxxx表示字符的Unicode码点 12"\u0061"// "a" 但是，这种表示法只限于码点在 \u0000 ~ \uFFFF之间的字符，超出这个范围的字符串必须用两个双字节的形式表示 12345"\uD842\uDFB7"// "𠮷""\u20BB7"// " 7" 如上，如果\u后面跟上超过0xFFFF的数值（如：\20BB7），JavaScript会理解成\u20BB+7 由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟一个7 ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。 1234567891011"\u&#123;20BB7&#125;"// "𠮷""\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"// "ABC"let hello = 123;hell\u&#123;6F&#125; // 123'\u&#123;1F680&#125;' === '\uD83D\uDE80'// true 上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。 有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。 1234567891011"\u&#123;20BB7&#125;"// "𠮷""\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"// "ABC"let hello = 123;hell\u&#123;6F&#125; // 123'\u&#123;1F680&#125;' === '\uD83D\uDE80'// true 上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。 有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。 12345'\z' === 'z' // true'\172' === 'z' // true'\x7A' === 'z' // true'\u007A' === 'z' // true'\u&#123;7A&#125;' === 'z' // true codePointAt()JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。 1234567var s = "𠮷";s.length // 2s.charAt(0) // ''s.charAt(1) // ''s.charCodeAt(0) // 55362s.charCodeAt(1) // 57271 上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。 ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。 123456let s = '𠮷a';s.codePointAt(0) // 134071s.codePointAt(1) // 57271s.codePointAt(2) // 97 codePointAt方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt方法的结果与charCodeAt方法相同。 总之，codePointAt方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。 codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下。 疑问：既然用索引0表示第一个字，并且能够渠道完整的”𠮷”的码点，为什么索引为1还是取到”𠮷”的后两个码点？而索引为2才是取到第二个字符？没搞懂，实验出来确实是如上的结果！那么这样就会出现这样一种情况：一个字符串，里面的字符不确定到底是两个字节还是四个字节，也就是说不确定一个字符包含的码点到底是一个还是两个，这样取值的时候怎么办？就会出现位置无法确定！ 先来看下面的代码： 123456let s = '𠮷a';for (let ch of s) &#123; console.log(ch.codePointAt(0).toString(16));&#125;// 20bb7// 61 这里说明一下：在ES6环境下（ES5不知道，因为没有在ES5环境下测试过”𠮷a”这个字符串），使用split()将s拆成数组，数组长度为3，就是跟上面的结果一样，使用charAt()，根据索引取值，0和1都是只能取“𠮷”字的前两个字节和后两个字节，所以，这里就用for循环，注意是of，不能用in，使用in取得的是split()之后的索引（0，1，2），除了使用循环之外，还可以使用变量的解构赋值： 12345let s = '𠮷a';let [one,two] = sconsole.log(one,two)//20bb7 //61 以上两种方式,目前只想到了这两种能够完全获取字符串中完整的单个字符的码点方法 注意：对象的解构赋值也是长度为3，不可行，substr()、sbustring()、split()等等这些方法，都不行。就连indexOf(“a”)获得的索引都是2，很尴尬的结果 接下来，我们可以判断一个字符到底是两个字节还是四个字节组成的： 123456function is32Bit(c) &#123; return c.codePointAt(0) &gt; 0xFFFF;&#125;is32Bit("𠮷") // trueis32Bit("a") // false String.fromCodePoint()ES5 提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）。 12String.fromCharCode(0x20BB7)// "ஷ" 上面代码中，String.fromCharCode不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。 ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反 1234String.fromCodePoint(0x20BB7)// "𠮷"String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y'// true 上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。 如上第三行String.fromCodePoint(0x78, 0x1f680, 0x79)返回的字符串是：x🚀y 注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。 字符串的遍历器接口之前有说过（变量的解构赋值），实验表明，字符串是具备Iterator接口的，也就是能够循环，即遍历接口，这是ES6位字符串添加的，这样字符串就可以使用for…of循环便利，上面代码有例子，就不列举了 当然，除了便于遍历字符串，这个遍历器最大的有点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点 12345678910for (let i = 0; i &lt; text.length; i++) &#123; console.log(text[i]);&#125;// " "// " "for (let i of text) &#123; console.log(i);&#125;// "𠮷" 上面代码中，字符串text只有一个字符，但是for循环会认为它包含两个字符（都不可打印），而for...of循环会正确识别出这一个字符。 normalize()许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。 这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别 1234'\u01D1'==='\u004F\u030C' //false'\u01D1'.length // 1'\u004F\u030C'.length // 2 上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。 ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。 12'\u01D1'.normalize() === '\u004F\u030C'.normalize()// true normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。 NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。 12'\u004F\u030C'.normalize('NFC').length // 1'\u004F\u030C'.normalize('NFD').length // 2 上面代码表示，NFC参数返回字符的合成形式，NFD参数返回字符的分解形式。 不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。 includes(), startsWith(), endsWith()传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 12345let s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true 这三个方法都支持第二个参数，表示开始搜索的位置。 12345let s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false 上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。 123'x'.repeat(3) // "xxx"'hello'.repeat(2) // "hellohello"'na'.repeat(0) // "" 参数如果是小数，会被舍弃小数部分取整。 1'na'.repeat(2.9) // "nana" 如果repeat的参数是负数或者Infinity，会报错。 1234'na'.repeat(Infinity)// RangeError'na'.repeat(-1)// RangeError 但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。 1'na'.repeat(-0.9) // "" 参数NaN等同于 0。 1'na'.repeat(NaN) // "" 如果repeat的参数是字符串，则会先转换成数字。 12'na'.repeat('na') // ""'na'.repeat('3') // "nanana" padStart()，padEnd()ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 12345'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' 上面代码中，padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。 如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。 12'xxx'.padStart(2, 'ab') // 'xxx''xxx'.padEnd(2, 'ab') // 'xxx' 如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。 12'abc'.padStart(10, '0123456789')// '0123456abc' 如果省略第二个参数，默认使用空格补全长度。 12'x'.padStart(4) // ' x''x'.padEnd(4) // 'x ' padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。 123'1'.padStart(10, '0') // "0000000001"'12'.padStart(10, '0') // "0000000012"'123456'.padStart(10, '0') // "0000123456" 另一个用途是提示字符串格式。 12'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12" matchAll()matchAll方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。 模板字符串传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。 123456$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); 上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。 12345$('#result').append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 12345678910111213// 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 1let greeting = `\`Yo\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 上面代码中，所有模板字符串的空格和换行，都是被保留的，比如&lt;ul&gt;标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`.trim()); 模板字符串中嵌入变量，需要将变量名写在${}之中。 123456789101112function authorize(user, action) &#123; if (!user.hasPrivilege(action)) &#123; throw new Error( // 传统写法为 // 'User ' // + user.name // + ' is not authorized to do ' // + action // + '.' `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`); &#125;&#125; 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 123456789101112let x = 1;let y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`// "1 + 2 = 3"`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`// "1 + 4 = 5"let obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;`// "3" 模板字符串之中还能调用函数。 123456function fn() &#123; return "Hello World";&#125;`foo $&#123;fn()&#125; bar`// foo Hello World bar 如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。 如果模板字符串中的变量没有声明，将报错。 123// 变量place没有声明let msg = `Hello, $&#123;place&#125;`;// 报错 由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。 12`Hello $&#123;'World'&#125;`// "Hello World" 模板字符串甚至还能嵌套。 12345678const tmpl = addrs =&gt; ` &lt;table&gt; $&#123;addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt; `).join('')&#125; &lt;/table&gt;`; 上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。 123456789101112131415const data = [ &#123; first: '&lt;Jane&gt;', last: 'Bond' &#125;, &#123; first: 'Lars', last: '&lt;Croft&gt;' &#125;,];console.log(tmpl(data));// &lt;table&gt;//// &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;//// &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;//// &lt;/table&gt; 如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。 123456789// 写法一let str = 'return ' + '`Hello $&#123;name&#125;!`';let func = new Function('name', str);func('Jack') // "Hello Jack!"// 写法二let str = '(name) =&gt; `Hello $&#123;name&#125;!`';let func = eval.call(null, str);func('Jack') // "Hello Jack!" 实例：模板编译下面，我们来看一个通过模板字符串，生成正式模板的实例。 1234567let template = `&lt;ul&gt; &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt;`; 上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%...%&gt;放置 JavaScript 代码，使用&lt;%= ... %&gt;输出 JavaScript 表达式。 怎么编译这个模板字符串呢？ 一种思路是将其转换为 JavaScript 表达式字符串。 1234567echo('&lt;ul&gt;');for(let i=0; i &lt; data.supplies.length; i++) &#123; echo('&lt;li&gt;'); echo(data.supplies[i]); echo('&lt;/li&gt;');&#125;;echo('&lt;/ul&gt;'); 这个转换使用正则表达式就行了。 12345678let evalExpr = /&lt;%=(.+?)%&gt;/g;let expr = /&lt;%([\s\S]+?)%&gt;/g;template = template .replace(evalExpr, '`); \n echo( $1 ); \n echo(`') .replace(expr, '`); \n $1 \n echo(`');template = 'echo(`' + template + '`);'; 然后，将template封装在一个函数里面返回，就可以了。 1234567891011121314let script =`(function parse(data)&#123; let output = ""; function echo(html)&#123; output += html; &#125; $&#123; template &#125; return output;&#125;)`;return script; 将上面的内容拼装成一个模板编译函数compile。 12345678910111213141516171819202122232425function compile(template)&#123; const evalExpr = /&lt;%=(.+?)%&gt;/g; const expr = /&lt;%([\s\S]+?)%&gt;/g; template = template .replace(evalExpr, '`); \n echo( $1 ); \n echo(`') .replace(expr, '`); \n $1 \n echo(`'); template = 'echo(`' + template + '`);'; let script = `(function parse(data)&#123; let output = ""; function echo(html)&#123; output += html; &#125; $&#123; template &#125; return output; &#125;)`; return script;&#125; compile函数的用法如下。 1234567let parse = eval(compile(template));div.innerHTML = parse(&#123; supplies: [ "broom", "mop", "cleaner" ] &#125;);// &lt;ul&gt;// &lt;li&gt;broom&lt;/li&gt;// &lt;li&gt;mop&lt;/li&gt;// &lt;li&gt;cleaner&lt;/li&gt;// &lt;/ul&gt; 标签模板模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 123alert`123`// 等同于alert(123) 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 123456let a = 5;let b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;// 等同于tag(['Hello ', ' world ', ''], 15, 50); 上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。 函数tag依次会接收到多个参数。 123456789function tag(stringArr, value1, value2)&#123; // ...&#125;// 等同于function tag(stringArr, ...values)&#123; // ...&#125; tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。 tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。 tag函数所有参数的实际值如下。 第一个参数：[&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;] 第二个参数: 15 第三个参数：50 也就是说，tag函数实际上以下面的形式调用。 1tag(['Hello ', ' world ', ''], 15, 50) 我们可以按照需要编写tag函数的代码。下面是tag函数的一种写法，以及运行结果。 1234567891011121314151617181920let a = 5;let b = 10;function tag(s, v1, v2) &#123; console.log(s[0]); console.log(s[1]); console.log(s[2]); console.log(v1); console.log(v2); return "OK";&#125;tag`Hello $&#123; a + b &#125; world $&#123; a * b&#125;`;// "Hello "// " world "// ""// 15// 50// "OK" 下面是一个更复杂的例子。 123456789101112131415161718let total = 30;let msg = passthru`The total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`;function passthru(literals) &#123; let result = ''; let i = 0; while (i &lt; literals.length) &#123; result += literals[i++]; if (i &lt; arguments.length) &#123; result += arguments[i]; &#125; &#125; return result;&#125;msg // "The total is 30 (31.5 with tax)" 上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。 passthru函数采用 rest 参数的写法如下。 12345678910function passthru(literals, ...values) &#123; let output = ""; let index; for (index = 0; index &lt; values.length; index++) &#123; output += literals[index] + values[index]; &#125; output += literals[index] return output;&#125; “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。 123456789101112131415161718let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; let s = templateData[0]; for (let i = 1; i &lt; arguments.length; i++) &#123; let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, "&amp;amp;") .replace(/&lt;/g, "&amp;lt;") .replace(/&gt;/g, "&amp;gt;"); // Don't escape special characters in the template. s += templateData[i]; &#125; return s;&#125; 上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。 12345let sender = '&lt;script&gt;alert("abc")&lt;/script&gt;'; // 恶意代码let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;message// &lt;p&gt;&amp;lt;script&amp;gt;alert("abc")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt; 标签模板的另一个应用，就是多语言转换（国际化处理）。 12i18n`Welcome to $&#123;siteName&#125;, you are visitor number $&#123;visitorNumber&#125;!`// "欢迎访问xxx，您是第xxxx位访问者！" 模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。 123456789// 下面的hashTemplate函数// 是一个自定义的模板处理函数let libraryHtml = hashTemplate` &lt;ul&gt; #for book in $&#123;myBooks&#125; &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt; #end &lt;/ul&gt;`; 除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。 123456789jsx` &lt;div&gt; &lt;input ref='input' onChange='$&#123;this.handleChange&#125;' defaultValue='$&#123;this.state.value&#125;' /&gt; $&#123;this.state.value&#125; &lt;/div&gt;` 上面的代码通过jsx函数，将一个 DOM 字符串转为 React 对象。你可以在 Github 找到jsx函数的具体实现。 下面则是一个假想的例子，通过java函数，在 JavaScript 代码之中运行 Java 代码。 12345678java`class HelloWorldApp &#123; public static void main(String[] args) &#123; System.out.println(“Hello World!”); // Display the string. &#125;&#125;`HelloWorldApp.main(); 模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。 12console.log`123`// ["123", raw: Array[1]] 上面代码中，console.log接受的参数，实际上是一个数组。该数组有一个raw属性，保存的是转义后的原字符串。 请看下面的例子。 1234567tag`First line\nSecond line`function tag(strings) &#123; console.log(strings.raw[0]); // strings.raw[0] 为 "First line\\nSecond line" // 打印输出 "First line\nSecond line"&#125; 上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[&quot;First line\nSecond line&quot;]，那么strings.raw数组就是[&quot;First line\\nSecond line&quot;]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\n视为\\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。 String.raw()ES6 还为原生的 String 对象，提供了一个raw方法。 String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。 12345String.raw`Hi\n$&#123;2+3&#125;!`;// 返回 "Hi\\n5!"String.raw`Hi\u000A!`;// 返回 "Hi\\u000A!" 如果原字符串的斜杠已经转义，那么String.raw会进行再次转义。 12String.raw`Hi\\n`// 返回 "Hi\\\\n" String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。 String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。 12345String.raw(&#123; raw: 'test' &#125;, 0, 1, 2);// 't0e1s2t'// 等同于String.raw(&#123; raw: ['t','e','s','t'] &#125;, 0, 1, 2); 作为函数，String.raw的代码实现基本如下。 12345678910String.raw = function (strings, ...values) &#123; let output = ''; let index; for (index = 0; index &lt; values.length; index++) &#123; output += strings.raw[index] + values[index]; &#125; output += strings.raw[index] return output;&#125; 模板字符串的限制前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。 举例来说，标签模板里面可以嵌入 LaTEX 语言。 1234567891011function latex(strings) &#123; // ...&#125;let document = latex`\newcommand&#123;\fun&#125;&#123;\textbf&#123;Fun!&#125;&#125; // 正常工作\newcommand&#123;\unicode&#125;&#123;\textbf&#123;Unicode!&#125;&#125; // 报错\newcommand&#123;\xerxes&#125;&#123;\textbf&#123;King!&#125;&#125; // 报错Breve over the h goes \u&#123;h&#125;ere // 报错` 上面代码中，变量document内嵌的模板字符串，对于 LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。 模板字符串会将\u00FF和\u{42}当作 Unicode 字符进行转义，所以\unicode解析时报错；而\x56会被当作十六进制字符串转义，所以\xerxes会报错。也就是说，\u和\x在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。 为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。 12345function tag(strs) &#123; strs[0] === undefined strs.raw[0] === "\\unicode and \\u&#123;55&#125;";&#125;tag`\unicode and \u&#123;55&#125;` 上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为undefined，但是raw属性依然可以得到原始字符串，因此tag函数还是可以对原字符串进行处理。 注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。 1let bad = `bad escape sequence: \unicode`; // 报错]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>实录</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量的解构赋值]]></title>
    <url>%2Fit233.github.io%2F2018%2F12%2F05%2F%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[数组的解构赋值基本用法ES6 允许按照一定模式，从数据和对象中提取值，对变量进行赋值，这被称为解构（Destructuring） 之前，为变量赋值，只能为变量一个个地直接指定值，如： 123let a = 1;let b = 2;let c = 3; ES6 之后允许写成： 1let [a, b, c] = [1, 2, 3]; 上面代码表示，从数组[1,2,3]中取值，按照对应位置,分别给变量a，b，c进行赋值 本质上，这种写法属于“匹配模式”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 嵌套赋值如下代码 1234let [a,[b,c]] = [1,[2,3]]a//1b//2c//3 这里代码结构互相嵌套，数组里面嵌套数组，不过只要能够在右边结构中找到相对应的位置，依然能够赋值成功 不完全解构12345678910let [,,d] = [1,2,3,4]d//3let [e] = [1,2,3,4]e//1let [a] = [[1,2]]a//[1,2] 如上代码所展示，等号两边结构模式相同（都为数组），那么就会根据左边的结构，在右边的结构中寻找对应位置的值进行赋值 但是，如果分析右边结构之后，找不到与之对应的值，那么该位置的变量则为undefined: 123let [a,b] = [[1,2]]a//[1]b//undefined 以上两种情况都属于不完全解构，指的是虽然等号两边的模式都一样，但是数据结构却有不同，导致等号两边的结构并不能完全对应起来，但是这样并不影响解构赋值的使用。 这样一来的结果，就是如果能够在等号右边对应位置找到对应的值，那么左边的变量就会赋予该值，否则为undefined rest参数在结构赋值的时候，还支持rest参数，这样的参数能够在不完全结构的情况下，将所有值保存起来。 需要说明注意的是： rest参数必须放在所有参数的最后面，因为这是一个用来扫尾的参数，简单来说就是当左边参数不够接收右边元素的时候，右边还有剩余的元素，那么解构将会直接将剩余的元素原封不动全部丢给rest参数 根据第一条，rest参数必须是最后一个，所以也就是说，rest参数也只能有一个 rest参数写法如下： 123let [a,...b] = [1,2,3]a//1b//[2,3] 上面代码，等号左边采用了rest参数…b，表示匹配完之前的参数之后，等号右边剩余的所有元素直接给b（不论结构） 123456789let [,a,...b] = [1,2,[3,4]]a//2b//[3,4]let [a,...b] = [1,2,3,&#123;name:"小明"&#125;]a//1b//[2,3,Object],这个Object就是&#123;name:"1"&#125;//如下打印name值是"小明"console.log(b[2].name) 以上情况是在右边有多余元素的情况，那么假如右边元素少于左边参数： 123let [,a,...b] = [1,2]a//2b//[] 回想一下之前说的解构赋值，如果没有匹配的元素，其值就是undefined，但是这里的b在没有匹配到元素赋值的时候，确实一个空数组[] 简单解释一下： 既然我们的b是rest参数，也就是接收解构赋值的时候，需要考虑到，我们剩余的元素还有可能有多个，那么我们接受多个数组中的元素，自然是用数组来接收。 所以这个rest参数就是一个空数组，当解构完之后，右边元素还有剩余，就将元素按顺序一个一个地原封塞到rest参数中，而如果没有剩余元素了，那么就不用塞了，rest参数就保持一个空数组了 解构原理如果等号右边的解构不是一个可以遍历的解构(详情参考Iterator)，那么解构操作会报错 12345678let [a] = 1;let [b] = false;let [c] = NaN;let [d] = undefined;let [e] = null;let [f] = &#123;&#125;;//以上这些均会报错： is not iterable 以上的代码语句，等号右边的值，要么是转为对象以后不具备Iterator接口（前5个表单时），要么本身就不具备Iterator接口（第六个表达式） 也就是说右边的数据要能够进行循环 说道这里，就要说一下字符串类型了，先看下面代码： 123456let [a,b,c,d,...e] = "这是一个字符串"a//这b//是c//一d//个e//['字','符','串'] 其实说白了，字符串也就是一串字符，即多个字符的数组(集合)，按照一定顺序组成的一串文字。因此，在字符串解构赋值的时候，字符串被转换成了一个类似数组的对象 同时，对于set结构，也可以使用数组的结构赋值 12let [x, y, z] = new Set(['a', 'b', 'c']);x // "a" 事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值 12345678910function* hhh() &#123; let a = 0; let b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;let [a,b,c,d,e,f] = hhh();console.log(a,b,c,d,e,f)//0 1 1 2 3 5 以上代码，hhh()是一个Generator函数，原生具有Iterator接口，解构赋值会依次从这个接口获取值 默认值解构赋值能够制定默认值，也就是当没有找到对应的元素给其赋值的时候，会采取制定的值为其赋值 如： 123456789let [a = '1'] = []a//1let [b,c='3'] = [5]b//5c//let [d = '1'] = ['aaa']d//aaa 需要注意的是，ES6 内部使用雅阁想等运算符 (===)来判断一个位置是否有值。所以只有当一个数组成员严格等于undefined，默认值才会生效 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 如上面代码，一个值为null，默认值却没有生效，是因为null === undefined为false 另外，如果一个默认值是一个表达式（函数也属于一个表达式），那么这个表达式是惰性求值的，也就是只有在使用到这个表达式的时候，才会去运行求值 12345function f() &#123; console.log('aaa');&#125;let [x = f()] = [1]; 上面代码不会执行f()函数，因为x能够在右边取到值，不会触发默认值 默认值也可以引用解构赋值的其他变量，但是该变量必须是在引用之前已经声明的 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError: y is not defined 这个在之前的let &amp; const说过，就不赘述了 对象的解构赋值解构赋值不仅可以用于数组，还可以用于对象 基本用法1let &#123;a&#125; = &#123;a:"这是a"&#125; 对象的解构赋值其数组的解构赋值模式一样，不过要注意的是，对象的解构赋值，是匹配等号右边对象中的属性名来赋值 如上面代码，let{a} ，会在右边的对象中{}找a这个名字的属性，然后取值赋值给左边的a，如果右边对象中没有这个属性，那么就为undefined, 如下代码 1let &#123;a&#125; = &#123;b:"这是b,不是a"&#125; 同时，因为是按照对象的属性名进行匹配，所以并不是想数组一样要按照严格的顺序 1let &#123;a,b&#125; = &#123;b:"这是b,不是a",a:"这才是a"&#125; 而如果我们变量名与属性名不一致，但是还想要取到某个属性的值，我们可以这么写： 1let &#123;a:b&#125; = &#123;c:"这是c",a:"这才是a"&#125; 在上面代码中，b才是变量，左边的a只是为了对应右边属性a，是说b要取属性a的值，这样变量b就会赋予属性a的值：”这才是a” 这样来说，对象的解构赋值可以看成以下代码的简写： 123let&#123;a:a,b:b&#125; = &#123;a:"这是a",b:"这是b"&#125;//简写为：let&#123;a,b&#125; = &#123;a:"这是a",b:"这是b"&#125; 嵌套赋值与数组一样，对象解构也能用于嵌套结构 12345678910let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World" 不过要注意并且要明白的是：这里的p是模式，不是变量，因此不会被赋值， 如果p也要作为变量赋值，可以这么写： 1234567891011let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World"p // ["Hello", &#123;y: "World"&#125;] 更复杂一点的嵌套如下： 12345678910111213const node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // Object &#123;start: Object&#125;start // Object &#123;line: 1, column: 5&#125; 上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量 这种嵌套赋值几乎很少用，一般基本的赋值就能满足大部分应用需求 默认值对象的解构赋值也可以指定默认值 123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;;y // 3var &#123;x: y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong" 与数组默认值一样的是，想要默认值生效的条件也是对象的属性值严格等于undefined，属性值为null的时候并不会导致默认值生效 同时，如果解构失败，变量的值也会等于undefined，也能致使默认值生效 我们都知道，数组本质就是一个特殊的对象，因此可以对数组进行对象属性的解构： 1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3 注意 如果解构模式是签到的对象，而且子对象所在的父属性不存在，那么将会报错 12// 报错let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;; 这里简答说明一下： 按照解构流程，我们会根据解构模式去对象中匹配foo属性（此属性根据解构模式来看也是一个模式（即对象）），而此时对象中没有foo属性，那么这个对象就是undefined，而我们再看解构模式中，要取的是该模式（foo）的属性bar，所以就应该是foo.bar，但是此时foo对象为undefined，故报错 还要注意的一点是，如果想要将一个已经声明的let变量用于对象解构赋值，必须要非常小心，先看如下代码： 1234// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 这个写法错误的原因是，我们用let声明了一个变量x，然后在{x}中使用这个变量，但是实际上JavaScript引擎会将{x}理解成一个代码块，这样就会发生语法上的错误。 如何解决这样的问题，我们可以不将大括号写在首行，这样可以避免将其解释为代码块 12let x;(&#123;x&#125; = &#123;x: 1&#125;); 对于这一点，接下来进行解释： 圆括号的问题解构赋值虽然很方便，但是解析起来并不容日，对于编译器来说，一个式子到底是模式，还是表达式，从一开始是不知道的，只有等到解析的时候（解析到或者解析不到等号）才能知道 由此带来的问题是，如果模式中出现圆括号怎么处理 ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号 但是这条规则实际上不那么容易辨别，处理起来也相当麻烦。因此，如果可能，尽量不要在模式中放置圆括号 不能使用圆括号以下解构赋值不能使用圆括号 #### 变量赋值语句 12345678let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 以上6个语句都会报错，因为他们都是变量声明语句，模式不能使用圆括号 #### 函数参数 要知道函数参数也是属于变量声明，因此不能带有圆括号 1234// 报错function f([(z)]) &#123; return z; &#125;// 报错function f([z,(x)]) &#123; return x; &#125; 赋值语句的模式123// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5]; 上面代码将整个模式放在圆括号之中，导致报错。 12// 报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; 上面代码将一部分模式放在圆括号之中，导致报错。 可以使用圆括号可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号 123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 上面三行语句可以正确执行， 其一、因为首先他们都是赋值语句，而不是生命语句 其二、他们的圆括号部分都不属于模式的一部分 第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象，然后在进行对象解构赋值 123let &#123;a,toString:b&#125; = 123a//undefinedb//b是function toString()&#123;.....&#125;, 这里的b是一个函数，是Number.prototype.toString指向的函数toString(){} 相应地，数字可以转为Number对象，那么布尔值也有对象Boolean 1let &#123;toString: s&#125; = true; 这里的s跟b一样，不过s是Boolean.prototype.toString 解构赋值的规则是，只要等号右边的值不是对象或者数组，就先将其转为对象，然后在进行对象解构赋值 不过要注意的是undefined和null都无法转为对象，所以对他们进行解构赋值，都会报错 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值函数的参数也可以使用解构赋值 12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。 下面是另一个例子。 12[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 默认值函数参数的解构也可以使用默认值 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。 从另一个角度来讲，如下的代码也是一种设置默认值的方式，但是却与上面的代码有很大差别： 12345678function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以当在整个参数为undefined的时候，才会致使默认值生效，所以会得到与前一种写法不同的结果。 解构赋值的用途变量的结构赋值用途很多，以下几个场景就能体验其优点： 变量值互换1234let x = 1;let y = 2;[x, y] = [y, x]; 如果按照以前的方式，我们还需要通过第三方中间量来帮助进行互换，而使用解构赋值的方式，可以直接进行变量值的交换，这样的写法不仅简介，而且易读，语义非常清晰 从函数返回多个值我们都知道，想要一个函数返回多个值的话，我们需要利用数组或者对象，将着多个值借助数组或者对象带出来。不过比较麻烦的是，取值的问题。而有了解构赋值，那么取值的时候就会非常方便 12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据在解析JSON对象的数据时，解构赋值就显得尤为便利了 12345678910let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] 函数参数的默认值我们应该这么做过，为了保证代码容错性，经常需要对函数的入参进行验证，防止出现空指针的异常 而我们通过解构赋值来给函数参数指定默认值，就不需要再在函数中判断参数，然后再给默认值的代码了 1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125; = &#123;&#125;) &#123; // ... do stuff&#125;; map结构的循环遍历我们都知道，想要获取map的值要通过key来获取，而map的key一般可以是没有任何规律，所以想要循环就不会像数组那样简单。 不过我们可以通过解构赋值来方便低解决这个问题 Map结构原生支持Iterator接口，配合变量的解构赋值，获取key和value就如下： 1234567const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125; 输入模块的指定方法加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰 1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map"); 这些场景下，能够使用变量的解构赋值，都会是一种很便捷的方法，足以体现出解构赋值的强大]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>实录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[let&const]]></title>
    <url>%2Fit233.github.io%2F2018%2F12%2F04%2Flet%26const%2F</url>
    <content type="text"><![CDATA[let命令简述 ES6新增了let命令用来生命变量，而在之前写js的时候，我们都习惯了使用var，而let的用法也与之相似。 而存在了var命令来声明变量，为什么还要有let命令。 众所周知，使用var的话会出现很多的问题，如变量提升导致的各种赋值、取值的错误问题等等，想必前端的这类问题遇到不少。 为了有效的规避此类的问题，特推出了let命令。使用let声明的变量，只会在let命令所在的代码块内有效，也就是除了包含let命令的作用域，其他地方是访问不到这个变量的 代码实验下面实录实验代码 先来看一下var命令声明的变量 1234&#123; var a = 10&#125;console.log(a) //10 这个代码运行之后，能够打印出a的值为10，然而我们的变量a是在{}区域中定义的，而console.log(a)是在该区域外面访问a，也就是在上一级调用低级区域中的变量，但是依然能够进行访问 再来看一下let 12345&#123; let a = 10 console.log(a)//10&#125;console.log(a)//ReferenceError: a is not defined 这个代码运行第三行会打印10，而第5行会报错：ReferenceError: a is not defined 这就是let的作用，在{}区域中定义的a，在该区域外（上级区域）是无法访问到该变量的，这样就不存在变量提升的问题了,而a变量也就只能作用在｛｝区域中 问题研究 然后给大家展示一个很有趣的问题 12345678910var b = 0;for(var a = 0;a &lt;10;a++)&#123; setTimeout(() =&gt; &#123; b += a; console.log("for-"+a+":"+b) &#125;, 1000);&#125;var a = 5;b+=a;console.log("0-9累加总和+5为："+b) 按照正常逻辑，我们这块代码是要进行统计0-9累加的和，我们分析这段代码： 先声明变量b为0，方便最后保存总和 写for循环，进行0-9的累加 然后定义变量a=5，b计算完之后再累加5，然后输出结果 正常逻辑算下来应该是45+5 = 50 结果呢？ 我想，和我一样先学java后来学js的人，起初很痛苦吧。为什么呢？为什么呢？ 这个具体如何解释我也不太能理解，到底for循环的a与后面定义的a是否同一个？还是后面定义的把之前的给覆盖掉了？分不太清，只知道在等1s之后，执行b+=a的时候，拿到的a是5，最后赋值为5的那个a 除此之外，还有一个比较好玩的是：把后面var a = 5去掉，又会出现另一个问题 分析解释 实验之前的那个循环把var改成let，会出现什么情况 12345678910var b = 0for(let a = 0;a &lt;10;a++)&#123; setTimeout(() =&gt; &#123; b += a console.log("for-"+a+":"+b) &#125;, 1000);&#125;var a = 5;b+=a;console.log("0-9累加总和+5为："+b) 虽然顺序有问题（setTimeout()函数异步延时），但是最终结果是正确的 好了，我们来看一下之前说的去掉后面定义的var会出现什么问题 var： 123456for(var a = 0;a &lt;10;a++)&#123; setTimeout(() =&gt; &#123; console.log("for-"+a) &#125;, 1000);&#125;console.log() 为了方便，我们只保留了循环，结果如下 let： 123456for(let a = 0;a &lt;10;a++)&#123; setTimeout(() =&gt; &#123; console.log("for-"+a) &#125;, 1000);&#125;console.log() 结果： 为什么会出现这样的情况，别急，我们来调试一下看看会不会发现什么： 我们先来看看var： 断点就打在第一行，for，然后启动调试，注意看变量这块 在这里要说一下刚刚大家能够看到，我们这张图是启动调试之后未做任何操作的第一张图，但是这时候Local中就已经存在了a，这是为什么？是node.js在遇到变量声明的时候，会将声明放在第一行，先声明变量，然后在继续执行 当我们走到第二行，那么a就创建成功了，我们来观察变量看看有什么值得注意的？ 看到Local下面a。这是本地变量。而之前为undefined，通过第一行的赋值之后(声明被提升到了上面，所以第一行只完成了一个赋值)，它的值是0 接下来我们一直调试到第六行，然后能发现这个情况： 然后我们放开调试，直接执行到底 然后我们来看看let 调试走一步 这里出现了Block：这是块级作用域，ES6新加的，后面会说到。这就是不同，这样就说明这个for中声明的a就是只能作用在这个块中，其他地方用不了，也拿不到，所以结果是，不说了。都知道了 唯一性 大家应该知道，使用var命令声明的变量，任何时候都可以重复声明，而所有变量都是指向同一个全局变量 123var a = 0console.log(a) //0var a = 10 而使用let命令声明的变量却不同，也就是说let声明的变量只能有一个，不能与已存在的变量重名 123var a = 0console.log(a)let a = 10 //SyntaxError: Identifier 'a' has already been declared 不只是在之后声明，在之前声明也是报错（为什么?已经解释过了）： 123let a = 0console.log(a)var a = 10 //SyntaxError: Identifier 'a' has already been declared 总结 var指令 var声明的变量a，在全局范围内都有效，所以全局只有一个变量a 在循环中，每一次循环，变量a的值都会发生改变，如果a的声明执行为var，循环内的a指向的就是全局的a 使用var指令如果先声明了一个变量a，之后又使用var指令声明一个变量a，这个时候不会报错，两个变量a都是指向同一个变量，也只有一个变量a var声明的变量a，在任何时候调用的，都是当前a的值，也就是我们使用setTimeOut（）延时调用a的时候，所有a都是最后一个值 var命令会发生变量提升现象，即在变量声明之前可以使用，不过值为undefined。也就是之前说的，node.js执行代码之前，先把var声明的变量都提升到最前面，先声明所有变量，值为undefined，在继续执行后面的代码，遇到赋值的时候就赋值，调用的时候就调用 let指令 let指令声明的a，只在当前当前的作用域内有效 在循环中，let声明的a，只在本轮循环中有效，所以每次循环的a其实都是一个新的变量 每次循环的a都是新的变量，却能够知道上一轮循环a的值，是因为JavaScript引擎内部会记住上一轮循环的值，初始化本轮的变量a时，就在上一轮循环的基础上进行计算 for循环的特别之处：设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域 使用let声明的变量，不会发生变量提升，所以在声明它之前，该变量相当于(为什么是相当于，看完后面希望理解)是不存在的，如果在声明之前调用该变量，会报错 使用let声明的变量，在同一个区域之中是唯一的，即无论以哪种形式声明了变量a，在该区域中之后的代码里都无法再使用let声明变量a 暂时性死区简述 所说的暂时性死区，就是在let命令声明变量之前，该变量都是不可用的，这一部分代码区间就称为暂时性死区 例如有一段代码，有一块区域占据总代码的第10~30行，其中有let命令声明的变量在该区域的第20行，那么这块区域的第10~20行就是该变量的“暂时性死区”（temporal dead zone，TDZ） 变量绑定区域与TDZ所谓的变量绑定区域，就是指如果一个块级作用域内存在let命令声明的变量a，那么这个变量就会绑定这个区域，并且不会再受到外部的影响，及时在外部又声明了与该变量相同名称的变量a，也不会影响到这个区域中的变量a 如： 12345var a = 0&#123; console.log(a)//0 var a = 10&#125; 在这段代码中，存在一个var命令的变量a，但是在块级区域的代码中又进行了一次变量a的声明(var)，这样的代码是可以通过的 但是有这种情况： 12345var a = 0&#123; console.log(a) let a = 10 //ReferenceError: a is not defined&#125; 这里有两点：变量绑定区域以及暂时性死区 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就是用这些变量的，就会报错 所以在代码行2~5这个区块之间，存在let声明的变量a，那么1声明的变量a对于2~5这个区块就是无效的，因为let a已经绑定了这个区块，同时因为let变量的唯一性，不允许var变量再来插足。而2~4行，就是let a的死区，是无法调用变量a的 “暂时性死区”也就意味着typeof不再是一个百分之百安全的操作 下面为对比代码： 1234567console.log(typeof a) //undefinedvar a = 0&#123; console.log(typeof b) //undefined console.log(typeof a) //报错：ReferenceError: a is not defined let a = 10&#125; 这里的代码能够看得出来 var变量因为变量提升，所以在声明代码之前就能调用，只不过是undefined 如果没有声明的变量，他就是undefined 但是let变量在声明之前，虽然也是undefined，但是规定在死区中是无法调用的，会报错 配图如下： 关于隐蔽死区的示例示例一、函数入参12345function fun(x = y, y = 2)&#123; //ReferenceError: y is not defined return [x,y]&#125;a = fun()console.log(a) 以上代码的意思就是定义一个函数，这个函数有两个参数，x和y 并且给两个参数默认值，x的默认值是y的值，y的默认值是2 这里会报错:ReferenceError: y is not defined(可能某些情况下不会报错) 为什么会报错，简单说一下： 首先，这里报错y，是第一个参数的x = y这里报错，这里的y未找到 为什么？因为在这个fun()的区块中，有声明y，不过是第二个参数声明的，所以在第一个参数调用就是y的死区， 如果将两个参数互换一下位置，那么这段代码就能正确执行了 12345function bar(y = 2 , x = y)&#123; return [x,y]&#125;a = bar()console.log(a) //Array(2) [2, 2] #### 实例二、声明赋值 1234var a = aconsole.log(a) //undefinedlet b = b //ReferenceError: b is not definedconsole.log(b) 这里依旧是死区的问题，上面的对比代码，var a= a赋值的时候运行正常，是因为var变量没有死区的 而let b = b报错，是因为=后的b属于调用变量b，而这个区块中有声明b的let命令，所以在b没有完全声明之前调用了b，这就是一个死区 块级作用域在ES5中只有全局作用域和函数作用域，没有块级作用域，这样会带来很多问题： 问题一、内层变量可能会覆盖外层变量12345var a = new Date();function fun()&#123; console.log(a) //Wed Dec 05 2018 14:21:35 GMT+0800 (中国标准时间) &#123;&#125;&#125;fun() 而如果是这样： 123456var a = new Date();function fun()&#123; console.log(a) //undefined var a = 123&#125;fun() 为什么会这样呢？是因为变量提升，由于在fun()中也有声明a变量，所以a变量的声明就提升到了函数最顶端进行声明，这时候a就是undefined，这个时候是因为fun()的a覆盖了上层的a 问题二、区块变量泄露为全局变量12345var s = 'abcdefg'for(var i = 0;i&lt;s.length;i++)&#123; console.log(s[i])&#125;console.log(i) //7 这里在循环结束之后，i的值依然存在，还是能够获取到 ES6的块级作用域let实际上是为JavaScript新增了块级作用域 示例代码： 12345678910111213141516function fun()&#123; var a = 5 if(true)&#123; var a = 10 &#125; console.log("a:",a)&#125;function fun2()&#123; let b = 5 if(true)&#123; let b = 10; &#125; console.log(b)&#125;fun()//10fun2()//5 从这段代码的执行结果能够看得出来，var变量内层变量会影响到上层变量，但是let变量却不会 之前说过，let变量是绑定区域的，所以在一个区域中，同样的变量（名字相同）只会存在一个 而如果下层let变量与上层let变量同名的话，不会互相影响，采用就近原则 同时块级作用域的出现，也使得立即执行函数表达式不再必要了 块级作用域与函数声明函数能不能在块级作用域之中声明？ ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域中声明 如下代码： 123456789101112if (true) &#123; function fun() &#123; console.log("fun") &#125;&#125;try &#123; function fun2() &#123; console.log("fun2") &#125;&#125; catch (e) &#123; console.log(e)&#125; 其实以上两种函数声明，根据ES5的规定都是非法的 但是浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上米昂两种情况实际上都能运行，不会报错。 而ES6引入了块级作用域，明确允许在块级作用域之中声明函数 同时，ES6规定，块级作用域之中。函数声明语句的行为类似于let，在块级作用域之外不能被引用 除此之外：需要注意的是，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响，为了减轻因此产生的不兼容问题，ES6在附录B里规定，浏览器的实现可不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数 函数声明类似于var，即会提升到全局作用域或函数作用域的头部 同时，函数声明还会提升到所在的块级作用域的头部 注意：上面三条规则只对ES6的的浏览器有效，其他环境的而实现不用遵守，还是将块级作用域的函数声明当作let处理 所以，考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数， 如果确实需要，也应该写成函数表达式，而不是函数声明语句： 123456789101112131415&#123; //函数声明语句 let a = 'abcdefg' function f() &#123; return a &#125;&#125;&#123; //函数表达式 let b = 'abcdefg' let fu = function fun() &#123; return b &#125;&#125; 注意： 我们都知道，写块级（如if，循环），如果区域中只有一行代码，可以省略大括号 但是在块级作用域声明函数，即使如这样形式的函数： function fun(){} 这也不是代表只有一行代码，所以如果在块级作用域声明函数，如果没有块级作用域的大括号，会报错 const命令基本用法const是声明一个常量，这个常量是只读的，就是能够读取其值，但是不能改变它的值 const常量注意点1. 常量一旦声明之后，就不能改变123const a = 0;a = 3;// TypeError: Assignment to constant variable. 2.常量的值必须在声明的时候就立即初始化，不能留到以后赋值12const a;// SyntaxError: Missing initializer in const declaration const命令####１.作用域 const的作用域与let命令相同：只在声明所在的块级作用域有效 2.暂时性死区const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明之后使用 3.唯一性const声明的常量,也与let一样,在同一块级区域中不可重复声明，具有唯一性 const本质题外话做过后台，有研究过常量的人，应该知道，所说的常量，指的就是这个变量在栈中保存的值不会改变。而如果是指向某个对象的话，那么就是执行某个对象的地址不能改变，而对象中的属性可以随意改变。 简述const实际上也是如此，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的书怒不得改动。 对于简单类型的数据（数值、字符创、布尔），值就保存在变量指向的那个内存地址，因此等同于常量。 但是对于符合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保持这个指针是固定不变的（总是指向某一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了 如下代码： 123456const a = &#123;&#125;;// 为 a 添加一个属性，可以成功a.prop = 123;a.prop // 123// 将 a 指向另一个对象，就会报错a = &#123;&#125;; // TypeError: "a" is read-only 1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 ### 扩展 冻结对象如果真的想将对象冻结，即对象已经创建，其数据结构不能改变，要用Object.freeze方法 12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 除此之外，如果还要将对象的属性冻结，下面代码是一个能够将对象彻底冻结的函数 12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; 原理就是如果对象的属性还是对象的话，就递归调用，将这个对象冻结，直到所有对象属性全部被冻结 ES6 声明变量的六种方法ES5只有两种声明变量的方法：var命令和function命令。 ES6除了添加let和const命令，还有另外两种声明变量的方法：import命令和class命令 顶层对象顶层对象的属性顶层对象，在浏览器环境指的就是window对象，在Node指的就是global对象 ES5之中，顶层对象的属性与全局变量是等价的 12345window.a = 1;a // 1a = 2;window.a // 2 这个代码，顶层对象的属性赋值与全局变量的赋值，是同一件事，也就是说全局变量 就是 顶层对象的属性 顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。 这样的设计带来几个很大的问题： 首先是没法在编译时就报出变量未声明的错误，只有运行时材能知道（因为全局变量很可能是顶层对象的属性创造的，而属性的创造是动态的） 其次，程序员很容易不知不倦就创建了全局变量 最后，顶层对象的属性是导出可以有读写的，这非常不利于模块化编程 另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的 ES6为了改变这一点， 一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性 另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性 也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined 这段代码中，全局变量a由var命令声明，所以它是顶层对象的属性； 全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined global对象ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的 浏览器里面，顶层对象是window，但是Node和Web Worker没有window 浏览器和Web Worker里面，self也指向顶层对象，但是Node没有self Node里面，顶层对象是global，但其他环境都不支持 同一段代码为了能够在各种环境都能取到顶层对象，现在一般是使用this变量，但是有局限性： 全局环境中，this会返回顶层对象。但是Node模块和ES6模块中，this返回的是当前模块 函数里面的this，如果函数不是作为对象的方法运行，而是淡村作为函数运行，this会指向顶层对象。但是严格模式下，这时this会返回undefined 不管是严格模式还是普通模式，new Function(‘return this’)()总会返回全局对象。但是如果浏览器用了CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法可能无法使用 综上所述，很难找到一种方法，可以在所有情况下都渠道顶层对象。 下面是两种勉强可以使用的方法 12345678910111213141516// 方法一(typeof window !== 'undefined' ? window : (typeof process === 'object' &amp;&amp; typeof require === 'function' &amp;&amp; typeof global === 'object') ? global : this);// 方法二var getGlobal = function () &#123; if (typeof self !== 'undefined') &#123; return self; &#125; if (typeof window !== 'undefined') &#123; return window; &#125; if (typeof global !== 'undefined') &#123; return global; &#125; throw new Error('unable to locate global object');&#125;; 现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。 垫片库system.global模拟了这个天，可以在所有环境拿到global 12345// CommonJS 的写法require('system.global/shim')();// ES6 模块的写法import shim from 'system.global/shim'; shim(); 上面代码可以保证各种环境里面，global对象都是存在的。 123456// CommonJS 的写法var global = require('system.global')();// ES6 模块的写法import getGlobal from 'system.global';const global = getGlobal(); 上面代码将顶层对象放入变量global]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>let</tag>
        <tag>const</tag>
        <tag>实录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java整型封装类Integer的比较]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F29%2Fjava%E6%95%B4%E5%9E%8B%E5%B0%81%E8%A3%85%E7%B1%BBInteger%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！ 一、浅说（这里说的是废话）数字类型​ 我们日常中经常会使用的数字来进行各种计算，比如1，2，3等这些自然数，当然这些自然数都是整的，不会像小数1.1，2.5，3.21等等这样有小数点的零散的小数，这些大于0的数字都被称为正数。 ​ 当然，有大于必然会有小于，所以那些小于0的数字被称为负数，如-1，-2，-3，-5.33，-7.4等 ​ 而在这些负数中也是跟正数一样，除了代表小于0的负号（-）之外，其他都一样，有的像1，2，3一样没有小数点，有的却有小数点，这样我们可以把所有数字分为整数和小数 java中代表数字的类型​ 这些最基本的知识点，就不在这过多介绍，简单提一下 整型：java中的整型就是上面我们说的整数，java中整型的数据类型有这么几个byte、short、int、long 浮点型：浮点型，说的就是带有小数点的小数了，java中浮点型的数据类型有flot、double 这里就简单过一下，今天我们要说的并不是这几个数据类型，而是另一种 引子上面所说的数据类型，都是java中的基本数据类型，也就是这门语言出生就定义好的类型。占用的内存空间比较小，用起来也比较方便。 但是，尽管如此，依然会有它自己的缺陷。我们应该都知道，其实在项目中用的比较多的并不是这些基本数据类型，而是它们的封装类 为什么要用开销更大的封装类，而不是这些基本类型? 最简单的一个问题，在一个类中的属性，定义一个整型变量，那么这个变量会有一个默认值0，这个时候，这个0到底是传递过来的值就是0呢？还是因为没有给这个它赋值的默认值呢？ 如果你说自己赋值自己不知道吗？那么项目中一般拿值都会从前端传递过来，这个时候在程序运行的过程中，我们又怎么知道这个值是前端传过来就是0呢？还是因为前端没有传所以默认值为0了呢？ 好了，简单讨论，所以我们能看出来，基本数据类型有时候并不能满足一些需求，所以这些基本数据类型的封装类（升级版）就来了。 今天我们要说的是整型int的封装类（Integer） 二、由该话题引发的补充疑问我想应该有人在初学的时候，有人会告诉你，Integer类型进行值比较的时候，要用equalse()方法进行比较，但是有时候我们却还是用==进行比较，你会发现，有的时候==比较两个相同数字的Integer对象，返回的是true，有的时候却是false，接下来会详细说明 == 和 equals()这里在简单提一下二者的区别 首先，==比较的是两个值，而equals()比较的是两个内容 我想我提出的这个概念会有很多人不解甚至会喷，因为大部分人都有这样根深蒂固的概念： ==比较的是地址，equals比较的是值 这么说也不能算错吧，毕竟大多数人都是这么说的。 而我有一点疑问提出来，就是这种说法的不严谨： 我们都知道，地址一般是对象才有，也就是说我们存在堆中的对象才会有指向这个对象在堆中实际位置的地址，而我们把这个地址会存在一个变量中，而这个变量中的值，就是这个地址，这个值也是存在栈中的 对此，所以人都说==比较的是地址，而equals比较的是值 那么我想问一下，这样的说法置基本数据类型byte、short、int、long、double、float于何地？他们有指向堆中对象的地址吗？ 所以说，我觉得存在栈中的不管是指向对象的地址，还是基本数据类型本身的值，都是这个变量存储的值，而存在于堆中的真正对象，保存的就是这个对象的内容（包括其拥有的属性、行为方法等，都是这个对象的内容） 如果你有更有助于自己理解的概念，那更好 好了，上面的说法可能跳的有点快，不过没办法，这里是要说封装类Integer，关于虚拟机的内存模型，这里就不细说了 三、实验实录好了，扯了那么多，还没真正进入话题，想喷就喷吧 问题现象现在来说一下这个问题的现象： 1. 先看int123int a = 1;int b = 1;System.out.println("int a == int b 结果："+(a == b)); 这个结果不用多考虑，为true是吧？ 2. 再看Integer123Integer c = 1;Integer d = 1;System.out.println("Integer c == Integer d 结果："+(c == d)); 好，按照我们之前说的，==比较的是c和d的值（栈中的值）， 那么这里分析下：我们创建一个Integer对象c，给这个对象赋值为1，然后我们又创建一个对象d，这个对象也赋值为1，然后用==比较c和d，我们比较的是两个对象存在栈中的地址，也就是c和d真正的值（指向对象的地址） 结果如何？ 吼，是true，好了，暂且到这，先不讨论，接下来看另一个实验： 3.再看一次Integer 瞧，我们看到了什么？ false唉，刚刚还是true的，为什么变成false了呢？ 问题依旧保留，我们来看看equals() 4.看看equals() 之前说了，equals()是比较两个对象内容是否完全一致 我们看看用equals比较这两种情况的结果 true，两个都是true，说明两个对象内容完全一致。 查找原因断点调试 我们一般遇到问题首先想到的是断点调试，这没问题，那么我们来走一波看看 打上断点，进入调试，然后分步来看，慢慢解析 注意看这张图的几个点，我们走到c、d两个Integer对象创建结束， 能够在Variables中看到，已经创建好了c、d两个对象，值都是1 注意看一下括号中，这里标明了c、d两个对象都是Integer对象，而这两个对象的记录编号都是525 ok，继续往下走 这里我们看到，有创建了e、f两个值为1111的Integer对象，记录编号分别是528，529 到此，我们应该能够看出来了吧 没错，在给Integer的两个对象都赋值为1的时候，c、d两个变量的值保存的地址是指向同一个对象的(525) 而赋值为1111的时候，两个变量的值保存的地址分别指向不同的（528和529） 这就是为什么c==d为true，而e==f为false 一步一步可以当是废话 到此，并没有结束，并不是找到为什么c==d为true，e==f为false是因为前者是同一个对象，而后者是不同对象就结束了。这也仅仅是看到了表象原因 由此，我们应该引发另一个问题：为什么同样是给Integer的对象赋值，都赋值为1的时候是同一个对象，而赋值为1111的时候确实两个不同的对象？ 这点是对于无从下手的人来说，思考到这里，我们应该怎么办？有经验的人肯定二话不说就去看源码去了，没错，答案肯定是在Integer的源码中。 刚进源码中又看了一眼，Integer类中有1600行左右的代码，我们怎么找？很头疼，是那些代码引起的上面的这个问题的？我们不知道。 这样我们该怎么办？有种无头苍蝇般的慌乱感吧？ 不用着急！我们可以利用ide断点调试中的一个小小的便利功能，有人注意到调试的时候，Variables视图中，我们每有一个行为调用，就会标识出这个行为以及其实体对象，下面看一组图，慢慢理解 我们能够看到，第一张图，也就是我给对象c赋值的时候所调用的行为方法就是编号为525的Integer对象的方法valueOf(int)—-对象d也是 第三张图为了更全面，我就展示了一下输出字符串的时候，其实这行代码的行为就是StringBuffer的toString方法，因为println()入参是String类型（拼接字符串的时候默认使用了StringBuffer来进行拼接，是为了效率，字符串的问题这里不讨论） 为了更全面，我们就举例三种，所以就又加了一个别的类型Date。能够在最后一张图看到，也有一个行为，是类加载行为。 可能大家都看到不同的对象的行为，ide给我们展示的信息也不同，甚至有些乱，不过那也是没有办法的，它只会给我们展示最近有影响的行为，如我们代码中Integer c = 1，其实这一行代码有这么几个行为：声明Integer对象c，实例化对象c，然后给c赋值，而我们上面展示的是最后一个给c赋值的valueOf(int)。 所以，如果有不知道该怎么去看源码的，可以借助这一点来去源码里面看一看，毕竟可以利用这一点找到跟我们程序有最直接关系的方法，然后以此为起点，慢慢往里看 查看源码在调试中我们能看到，调用Integer的时候调用了valueOf(int)这个方法，那就来看一下这个方法究竟有什么神奇的地方： 打开Integer类的源码，找到valueOf(int) 在Integer类的源码中，重载了多个valueOf方法，不过都是调用了valueOf(int i)的方法来处理的。所以我们只要看这个方法就可以了 在源码中能够看到：当赋值i在IntegerCache.low和IntegerCache.high之间（二者都包括）的时候，是直接返回已存在的IntegerCache.cache[index]中的值（某一个对象），否则才会新建！ 到了这一步，我想差不多应该已经明白是怎么回事了。 这里是Integer做的一个缓存，预先缓存一部分值，如果程序要使用的值在其中，那么直接就拿来用，否则的话才会新建一个对象赋值返回。 所以我们能够判断出来，当给Integer a赋值1的时候，是没有超出IntegerCache.cache的范围的，而1111则超出了，所以导致一种是相同对象，一种是不同对象的结果。 Integer中整数缓存不过这个范围到底是多少呢？ 那么既然提到这个问题了，我们就深究一下这个IntegerCache.cache到底怎么回事： 那么就来看看IntegerCache的源码： 在Integer类中有一个内部类，就是IntegerCache 这个类的作用就是为Integer类提供一部分int类型的缓存，避免了重复创建对象的麻烦。 下面请看源码： 在源码中我们能够看到，首先IntegerCache设定了缓存最小值为-128(对于这个值，我想大家应该已经猜到了什么) 没错，这是byte的最小临界点（最小值） 那么high不用想了，很大可能就是127了 当然，看了源码也能看到了，在静态块中经过处理，最大值high也是127 所以在valueOf中，入参i如果满足-128&lt;=i&lt;=127，那么返回的对象都是同一个，数组cache中的某一个，否则就是new 一个对象 所以就会出现如果Integer的值是在-128~127之间的时候用==判断为true，而其他的值==为false的现象 关于Integer缓存而对于Integer缓存大小的设置，也是可以自己设定的 因为java不是直接运行在本地操作系统上的，而是运行在jvm上的，我们可以通过配置更改jvm的运行参数来改变。 这个网上看看就好了，毕竟将缓存范围变大，那么意味着内存开销加剧，并且这部分缓存不会被gc回收的]]></content>
      <categories>
        <category>java</category>
        <category>数据类型</category>
        <category>整型</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jpa自动映射java实体类与数据库表]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F28%2Fjpa%E8%87%AA%E5%8A%A8%E6%98%A0%E5%B0%84java%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[​ 之前有说过jpa不实用实体类，那是某种特殊情况的时候的需要 ​ 而大多数的时候，我们后端代码还是需要有与数据库对应的实体类的 ​ 这样方便后端进行管理数据，而且更易于使用jpa框架 这次废话不多说，毕竟时间不多，简单做一些记录，反正对于这个框架还不太熟悉！有机会再来好好研究一番 下面直接说出如何去写，原理，实验什么的就先免了 实体类123456789101112131415@Data@NoArgsConstructor@AllArgsConstructor@Builder@Entity@Table(name = "ssprt_config",uniqueConstraints = &#123;@UniqueConstraint(name = "UK_SSPRTCONFIG_TYPE",columnNames = "type")&#125;)public class SsprtConfig &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = "type",length = 50) private String type; @Column(name = "value",length = 1) private Integer value;&#125; 简单解释： @Data：不用说了，就是getter、setter方法 @NoArgsConstructor：无参构造 @AllArgsConstructor：所有参数的构造 注意2和3两个注解，最好加上，因为我们利用jpa查询数据的时候，查完数据通过构造进行给实体类赋值，没有的话会报有关构造函数的错误 @Builder：builder创建对象，利用静态方法builder来创建对象，而不用new，提供链式setter赋值，方便快捷 @Entity：标注这是一个实体类，是一个与数据库映射的实体类 @Table：标注这个类所对应的数据库中的表名，同时，如果数据库中没有与之对应的表，会自动生成该表与之对应（这个要在配置文件中配置策略，不细说了，因为我也只是知道，并没有研究） name：不是必须的，如果没有，那么使用默认的该实体类的短类名。 uniqueConstraints：唯一键，指定某个列columnNames @Id：标注为主键 @GeneratedValue：主键生成策略， TABLE：使用表保存id值 IDENTITY：identitycolumn SEQUENCR ：sequence AUTO：根据数据库的不同使用上面三个 @Column：生命该字段与数据库表字段的映射关系， name指表字段名，length指数据长度，注意数据类型使用封装类]]></content>
      <categories>
        <category>java</category>
        <category>框架</category>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas-camera]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F21%2Fcanvas-camera%2F</url>
    <content type="text"><![CDATA[这里是运用canvas来实现电脑摄像头拍照的功能的js代码。 纯属个人兴趣 以下是个人封装的js，好坏皆是如此 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * * 调用摄像头 * 传入参数：必须 * canvas：画布，传入的参数为id,class,name或者tagName四选一，注意：只需要传入名称即可,不需要符号， * 例如:&lt;canvas id = "myCanvas"&gt;&lt;/canvas&gt;,那么入参就是myCanvas * video：影像，传入id，class，name，或者tagName四选一 * * 传入参数：非必须 * open ：打开摄像头功能的按钮id，class，Name * snap ： 拍摄功能的按钮id，class或者name * close： 关闭摄像头功能的按钮id，class或者name * * 注意：如果不传入按钮功能，会有open，snap，close三个function来提供相应的功能，可以直接使用canCamera.open()等来调用 * * 同时，提供链式调用 * * 调用示例： * var cc = canCamera(&#123; * canvas:"myCanvas", * video:"myVideo", * open:"start", * snap:"getPhotoBtn", * close:"closeBtn" * &#125;) * * 或者： * * var cc = canCamera(&#123; * canvas:"myCanvas", * video:"myVideo" * &#125;) * //绑定按钮点击事件 * document.getElementById("start").addEventListener('click',cc.open); * document.getElementById("getPhotoBtn").addEventListener('click',cc.snap); * document.getElementById("closeBtn").addEventListener('click',cc.close); * */(function (window, document) &#123; var canCamera = function (obj) &#123; var $this = canCamera $this.canvas = document.getElementById(obj.canvas) || document.getElementsByName(obj.canvas)[0] || document.getElementsByClassName(obj.canvas)[0] || document.getElementsByTagName(obj.canvas)[0] $this.video = document.getElementById(obj.video) || document.getElementsByName(obj.video)[0] || document.getElementsByClassName(obj.video)[0] || document.getElementsByTagName(obj.video)[0] $this.openBtn = document.getElementById(obj.open) || document.getElementsByName(obj.open)[0] || document.getElementsByClassName(obj.open)[0] $this.snapBtn = document.getElementById(obj.snap) || document.getElementsByName(obj.snap)[0] || document.getElementsByClassName(obj.snap)[0] $this.closeBtn = document.getElementById(obj.close) || document.getElementsByName(obj.close)[0] || document.getElementsByClassName(obj.close)[0] $this.context = $this.canvas.getContext('2d') $this.MediaStreamTrack = null $this.open = function () &#123; $this.video.style.display = "block"; $this.canvas.style.display = "none"; if (navigator.mediaDevices &amp;&amp; navigator.mediaDevices.getUserMedia) &#123; navigator.mediaDevices.getUserMedia(&#123; "video": true &#125;).then(function (stream) &#123; $this.MediaStreamTrack = typeof stream.stop === 'function' ? stream : stream.getTracks()[1]; $this.video.srcObject = stream; $this.video.play(); &#125;).catch(function (err) &#123; console.log(err); &#125;); &#125; else if (navigator.getMedia) &#123; navigator.getMedia(&#123; "video": true &#125;).then(function (stream) &#123; console.log(stream); $this.MediaStreamTrack = stream.getTracks()[1]; $this.video.srcObject = (window.webkitURL).createObjectURL(stream); $this.video.play(); &#125;).catch(function (err) &#123; console.log(err); &#125;); &#125; else &#123; alert("浏览器不支持！"); &#125; return $this &#125;; $this.snap = function () &#123; var w = $this.video.offsetWidth, h = $this.video.offsetHeight; $this.video.style.display = "none"; $this.canvas.style.display = "block"; $this.context.drawImage($this.video, 0, 0, w, h); return $this &#125;; $this.close = function () &#123; $this.MediaStreamTrack &amp;&amp; $this.MediaStreamTrack.stop(); return $this &#125;; if ($this.openBtn) $this.openBtn.addEventListener('click', $this.open); if ($this.snapBtn) $this.snapBtn.addEventListener('click', $this.snap); if ($this.closeBtn) $this.closeBtn.addEventListener('click', $this.close); window.canCamera = canCamera || new canCamera() return $this &#125; window.canCamera = canCamera || new canCamera()&#125;)(window, document)]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>HFJs</category>
      </categories>
      <tags>
        <tag>兴趣</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端画图Canvas简单运用]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F19%2F%E5%89%8D%E7%AB%AF%E7%94%BB%E5%9B%BECanvas%E7%AE%80%E5%8D%95%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、前言 朋友遇到的情况，属于前端的问题，是需要打开摄像头来拍照，关于这个问题，他找到了我让我来帮他解决，不过由于我的前端也是属于那种半吊子水平，所以在过程中也是参考了网上的不少资料和案例，不过还好的是因此也了解了不少知识，所以准备整理一下，做个记录 这篇主要是前端canvas画布功能，可能知识不够全面，但是要实现拍照应该是没问题了 除了参照图像资源进行利用canvas画图之外，canvas还有很多功能提供，方便我们直接在页面上进行手工绘画，这些功能这里就不展示了，因为我也忘记了，只是之前刚学前端的时候有捣弄过，不过现在主要做后台开发，所以前端水平就一般般 二、画图 在实现拍照之前，先来详细了解一下canvas画图功能，这样对于后面拍照会更简单一点 页面准备 实现canvas画图功能，我们需要准备一张图片，为了试验效果，我就随便截了一张桌面的图片 在页面中我们要放置一张图片(当然，也可以不用展示在页面上，这个js代码中会扩展)，所以需要img标签元素 想要进行在页面画图，我们还要通过canvas标签元素获得context(简称，后面展示全部)来帮我们实现这个功能 然后，为了进行测试，我们加一个按钮，当点击按钮的时候，我们将展示的图片画出来 html代码 我们需要的html代码很简单，只有三个元素：img、canvas、button 1234&lt;img src="../imgs/0.png" id="img"&gt;&lt;canvas height="400" width="200" id="canvas1" style="border: 1px solid gray"&gt;&lt;/canvas&gt;&lt;br/&gt;&lt;button id="draw"&gt;画图&lt;/button&gt; js代码及详解简单分析 在上代码之前， 先来说一下流程 我们想要参照img元素中的图片资源，利用canvas来将其画出来 那么首先我们就需要找到img元素中的图片， 其次还要有canvas画图的对象， 然后获得canvas的Context 最后配置Context的环境将img图片画出来 总体简单来说就这四步，下面直接上代码，然后再解释： js代码12345678window.onload = function () &#123; document.getElementById("ckbtn").addEventListener('click', function () &#123; var img = document.getElementById("img"); var cv = document.getElementById('canvas1'); var ct = cv.getContext("2d"); ct.drawImage(img, 0, 0, 200, 400); &#125;);&#125; js代码详细解释（以及踩过的坑和未踩过的坑） 注意点1、window.onload 这个window.onload不用多解释，就是在页面加载完成之后再执行funciton中的这段代码 为什么一定要这么做呢？ 那是因为我们现在使用的页面元素，如果没有这个onload保证页面先加载完成，有可能会出现这种情况： canvas元素找不到，所以我们获取其dom对象的时候有可能会出现undefined 如果canvas出现undefined的话，那么我们必然无法获得该画布下的Context，也就无法实现画图功能 除此之外，运气好，我们canvas画布放的比较靠前，能够找得到，不过我们知道，图片属于外部静态资源，加载可能没有html原生代码快，这个时候，如果我们图片没有加载完成，也可能会出现画图失败 举个例子，假如有一个画家，他要为一个人画一幅像，但是不巧的是，这个人突然临时有事，不能准时到，那么在这个人还没有到达之前，这个画家怎么去画这幅画？他拿什么做参考呢？ 再者呢，我们又要绑定按钮，所以onload最好是加上 这里说了那么多，我们能够知道，如果我们看着代码没有错误，并且没有报错，那么很可能是图片没有加载完成，导致没法画出图片（之后还有一个可能的原因，在注意点2） 注意点2、canvas元素 这里要注意的是，我们所说的canvas画图，其实canvas只是一个画布,隐约记得曾经学的时候，好像还有画笔什么来着，记不清了，不纠结了、 真正实现画图功能的，是画笔而不是画布，而之前说的Context，是一种环境， 这里打个比方，canvas是画布，就是画家使用的画板，就是我们要画出的画的容器 那个画笔是什么来着，就是用来进行绘画的，之前说的能够手工绘画也是控制画笔在页面上进行绘画 而context，是环境，就好比我们画家用画笔在画布上绘画所需要的因素，在这里我个人将它理解为了画家，因为context提供了画图很多方法来满足画图的需要。就像一个画家一样具备的能力 这里简单展示一下context，关于context这个对象具体的代码有点多，有兴趣的可以自己研究 123getContext(contextId: "2d", contextAttributes?: Canvas2DContextAttributes): CanvasRenderingContext2D | null;getContext(contextId: "webgl" | "experimental-webgl", contextAttributes?: WebGLContextAttributes): WebGLRenderingContext | null;getContext(contextId: string, contextAttributes?: &#123;&#125;): CanvasRenderingContext2D | WebGLRenderingContext | null; 这里并不是很详细地解释了canvas，所以我们知道，canvas是容器，这里也会有一个小问题，不知道有没有人遇到过。（在做摄像头拍照的时候遇到了小问题，所以回头研究了canvas） 如果我们为了美观，不展示canvas来占空间，而设置为了display:none，那么会发生什么情况？ 另外，如果我们设置了canvas的长宽都为0，会是什么情况？ 对于以上两点，在下面会案例展示结果，先猜一下吧 注意点3、2维和3维画图 通过上面的getContext()方法，能够看得出来，我们假如传入的是“2d”这个字符串，那么就会获得CanvasRenderingContext2D这个对象 在没有看过这些代码之前，我也曾一度认为，有2d就有3d，果断丢个”3d”参数进去，哈哈，获得null，那么我们肯定觉得不合理，有2d画图就应该能画3d的啊，其实webgl就是用来画3d的，不过我不会，也不了解 不过有一点需要注意了，接下来图文解释更清晰 首先我获得canvas之后，通过传入参数3d 1234var cv = document.getElementById('canvas1'); console.log(cv) var ct = cv.getContext("3d"); console.log(ct) 获得的结果为null 然而我们如果传入的是”2d”或者”webgl”的话，确实能够获得context的 注意了：如果我们先入参2d获得返回对象保存在一个变量中，然后再入参webgl保存在另一个变量中，会是什么结果？ 123456var cv = document.getElementById('canvas1'); console.log(cv) var ct2d = cv.getContext("2d"); var ctwebgl = cv.getContext("webgl") console.log("ct2d:"+ct2d) console.log("ctwebgl:"+ctwebgl) 12345678910111213141516- 结果就是先获得的context占据这个画布，再设置另一个则没用了，直接为null。而官方原注释并没有解释为何，我们可以从官方注释中得到的信息，就是：- 返回一个对象，该对象提供绘制和操作文档中画布元素上的图像和图形的方法和属性。上下文对象包括关于颜色、线宽、字体和其他可以在画布上绘制的图形参数的信息。 @param上下文要创建的画布类型的标识符(ID)。Internet Explorer 9和Internet Explorer 10仅支持使用canvas.getContext(“2d”)的2d环境;IE11预览还支持3d或WebGL上下文使用canvas.getContext(“实验- WebGL”);- 好像并没有什么文字能解释为什么只能获得一次？那么我们就只能从代码中分析了，请移至注意点2查看代码，这里不贴了- w3school中也没有过多解释，不过这里依然不妨碍理解，这个方法大致为以下情况：- 根据入参来匹配2d或者webgl，如果是，那么会先去看contextAttributes，如果已经有值了（上次一调用之后会将2d或者webgl相应对象存下来，猜测），那么直接返回null，这就导致如果第一次已经拿到2d的对象了，那么下面再入参webgl调用，获得的就是null，而为什么不是返回上一次的，就是函数返回值的问题吧，看前两个getContext，返回值要么是对应的2d或webgl对象，要么是null。这就是说参数匹配到之后，就会执行相应的函数，而"2d"只会返回2d对象或者null，webgl也是一样。最后一个方法，是在参数不匹配2d或者webgl的时候，会先去返回2d，如果没有，再考虑webgl，最后二者都没有，就返回null- 其实，之上一点的看法，最后理解根本无法实践，因为按照最后的说法，我们必须要传一个参数过去，而如果我们先传过去2d，那么获得2d对象，这时候再去调用getContext实践，不好意思，之前已经设置过2d了，其他的我不会给你了。就好比一个画板，其中A画家先去使用了，那么不好意思，不管你后来再来的其他任何人，都不会得到使用权。不过如果再次传入2d，还是能够获得2d对象，这个只能解释为A画家中途休息，休息完之后依旧拥有该画板的使用权。以至于最后的猜想也没法实现验证。因为我除了传入2d参数，其他任何参数都会直接获得null- 而且这看到的只是interface中的代码，没有具体实现的逻辑代码，一切靠猜测，所以可能会很大的冲突，不过结果肯定是一样的，因为就是通过结果来进行推测的逻辑。如果有人比较了解这方面的东西，希望能够告知以便相互学习 注意点4：这里不叫注意点，应该是知识点 drawImage（r,x,y,w,h）参数： r：代表的是图像源头 x：表示在画布中x坐标轴的偏移量 y：y坐标轴偏移量 w：画出的图片的宽度 h：高度 、结果实例 参照页面img元素画图 这里就丢两张图， 反正该解释的上面已经解释了 不参照页面img元素画图 在前面说过，我们不将图片展示在页面上来将图片画出来，不过我们要遵循的步骤依旧是一样的 只不过第一步找参考图片不是在页面中寻找了，而是在js代码中，也就是我们要手动创建一个img元素dom对象，然后指定其图片 代码： 12345678window.onload = function () &#123; var img = document.createElement("img") img.src="../imgs/0.png" document.getElementById("draw").addEventListener('click', function () &#123; var cv = document.getElementById('canvas1'); var ct = cv.getContext("2d"); ct.drawImage(img, 0, 0, 200, 200); &#125;); 结果图： 以上展示了如何利用canvas画图，其中有理解错误的地方，也就这样了。下面来看一下怎么将这张canvas中的图片保存下来，这个后面会用到 四、canvas补充 上面说到的两个问题，在这里进行补充示例说明结果 问题1：canvas设置为display:none的情况会如何 首先看一下代码： html：直接设置canvas样式为display:none 1234&lt;canvas height="400" width="200" id="canvas1" style="border: 1px solid gray;display:none;"&gt;&lt;/canvas&gt;&lt;br/&gt;&lt;button id="draw"&gt;画图&lt;/button&gt;&lt;button id="show"&gt;展示&lt;/button&gt; 结果可想而知，页面上什么都没有只有两个个按钮 js代码：思路是，点击画图将图片画到canvas中，在点击展示改变canvas的样式为block，看看有没有图片 123456789101112//画图按钮var img = document.createElement("img")img.src="../imgs/0.png"document.getElementById("draw").addEventListener('click', function () &#123; var cv = document.getElementById('canvas1'); var ct = cv.getContext("2d"); ct.drawImage(img, 0, 0, 200, 200);&#125;);//展示按钮document.getElementById("show").addEventListener('click',function () &#123; document.getElementById("canvas1").style.display= 'block';&#125;) 结果： 啊哈，有图片耶！那么我们来看看第二种情况 问题2：canvas设置为长宽都为0的情况会如何 思路同上一个，直接贴代码和效果 1234&lt;canvas height="0" width="0" id="canvas1" style="border: 1px solid gray;"&gt;&lt;/canvas&gt;&lt;br/&gt;&lt;button id="draw"&gt;画图&lt;/button&gt;&lt;button id="show"&gt;展示&lt;/button&gt; 12345678910111213//画图按钮 var img = document.createElement("img") img.src = "../imgs/0.png" document.getElementById("draw").addEventListener('click', function () &#123; var cv = document.getElementById('canvas1'); var ct = cv.getContext("2d"); ct.drawImage(img, 0, 0, 200, 200); &#125;); //展示按钮 document.getElementById("show").addEventListener('click', function () &#123; document.getElementById("canvas1").style.width = '200px'; document.getElementById("canvas1").style.height = '400px'; &#125;) 没有图片唉！ 总结： 我们将canvas设置为display:none，但是该元素还是存在页面中的，并且占有一定的面积，只是因为设置为不显示，所以视觉上并没有占用页面的空间。 之前说过，canvas是画布，画图是将图片画在canvas元素上，那么既然存在，不管别人看不看得到，我们画图的时候没有影响 而将canvas宽高设置为0，那么该元素虽然依旧存在页面中，但是一个没有任何大小的元素，真正的意义是依旧存在页面中吗？谁能将一幅画画在面积为0的画板上呢？ 所以，对于canvas的理解，就是这样，它就是一个容器，就是用来存放画出来的图像的一个容器。 五、canvas图片下载 针对与摄像头拍照，我们需要将”拍”的照片保存下来，其实就是将canvas中画出来的图像保存下来， 然后目前的情况也就是我们只是拥有一个存在于页面有展示效果的视觉图像而已，以及一个保存这个图像的元素 那么我们如何将这个元素中的画面以图片文件形式保存下来呢？ 其实很简单，有以下几步 ## １、获得图片文件形式 文件，其实也是一组数据，我们只要拿到这组数据就能实现文件下载 123var ctx = document.getElementById('canvas1'); //获得图片的base64加密字符串 var imgdata = ctx.toDataURL("image/png", 1.0); 通过ctx.toDataURL方法能够将canvas元素中的图像元素转成文件数据路径 接下来，有了文件数据路径。我们可以通过a标签来进行下载该文件 12345678910111213//设置文件名字，并生成a标签链接文件直接执行鼠标点击事件进行下载var type = 'jpg'var filename = 'canvas画图.' + type;var a = document.createElement('a');//设置a链接元素为文件数据路径，点击时候就能直接下载a.href = imgdata;a.download = filename;//然后生成鼠标点击事件// a.click()var event = document.createEvent('MouseEvents');event.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);//执行a标签元素的鼠标点击事件，就相当于是在页面中用鼠标点击了a链接，实现下载a.dispatchEvent(event); 说明一下：其实从10行开始到结束的代码，效果等同于第九行的a.click()，就是为了能够不实用鼠标点击页面元素而实现a的点击事件 到此，我们就把canvas中的图像保存下来了，有人应该注意到，png格式，对于没有被填充的canvas范围，在图片中是透明背景。 除了png格式，还支持jpg、bmp、gif等格式，视自己的需求来吧 六、摄像头拍照 其实摄像头拍照功能，我们也能够利用canvas画图来实现 按照我们之前说的，利用canvas只要能够将画面元素拿到，就能够将该元素区域中的图像画到canvas中，然后下载 上面已经说了后面的步骤，所以我们要利用摄像头中拍照，那么到目前我们要解决的事情就只有两个了： 1、拿到摄像头中拍摄到的画面展示在页面中 2、将页面中展示摄像头页面的元素获取到，给canvas画下来 打开摄像头先贴代码，然后再解释 12345678910navigator.mediaDevices.getUserMedia(&#123; "video": true &#125;).then(function (stream) &#123; console.log(stream); $this.MediaStreamTrack = typeof stream.stop === 'function' ? stream : stream.getTracks()[1]; $this.video.srcObject = stream; $this.video.play(); &#125;).catch(function (err) &#123; console.log(err); &#125;); 详解navigator Navigator 对象包含有关浏览器的信息 ， 注释：没有应用于 navigator 对象的公开标准，不过所有浏览器都支持该对象 描述：Navigator 对象包含的属性描述了正在使用的浏览器。可以使用这些属性进行平台专用的配置。 虽然这个对象的名称显而易见的是 Netscape 的 Navigator 浏览器，但其他实现了 JavaScript 的浏览器也支持这个对象。 Navigator 对象的实例是唯一的，可以用 Window 对象的 navigator 属性来引用它。 对于这个对象，可以去网上查查，今天我们关注的并不是它 mediaDevices 上面说的Navigator对象很牛逼，牛逼到我们能够获得当前所使用环境的很多信息，包括浏览器，当前系统等等 而mediaDevices，则是一个API接口，该接口提供了访问链接媒体输入的设备，如我们使用的摄像头、照相机和麦克风，以及屏幕共享等。 这些媒体输入设备,都能通过该接口来访问链接以便调用 链接可以去网站上看看详细的文档资料 ​ https://developer.mozilla.org/zh-CN/ 进去后点击左上角技术&gt;&gt;&gt;API/dom 能够查看所有的API文档，然后找到mediaDevices和Navigator自行学习 有了mediaDevices，只是给我们提供了媒体输入设备链接，而我们要使用设备，还需要一个方法，没错，就是代码中的getUserMedia() mediaDevices.getUserMedia() 该方法会使用户给予使用媒体输入的许可 ，媒体输入会产生一个MediaStream，里面包含了请求的媒体类型的轨道 。 MediaStream是一个流，这个流可以包括视频轨道（来自硬件或者虚拟视频源，比如相机、视频采集设备和屏幕共享服务等等 ）、音频轨道（同样来自硬件或虚拟音频源，比如麦克风、A/D转换器等等 ），也可能是其他轨道 这个函数的参数也比较简单，就是一个对象，这个对象就是表示我们要请求使用的媒体 1&#123; audio: true, video: true &#125; 上面这个代码表示没有任何要求，只要使用音频和视频的媒体 1234&#123; audio: true, video: &#123; width: 1280, height: 720 &#125;&#125; 而这上面代码是说，我要使用音频和视频媒体输入设备，但是视频设配我要1280x720的分辨率 等等，这些参数我们可以灵活使用，而这些东西在上面分享的url里面都有，可以自行去看文档学习 说完参数，那么来看一下返回值：Promise 其实这个对象没多大深度，就是表示异步操作最终完成或者失败的对象 也就是说，我们请求使用设备，成功了，这个对象就表示成功了，失败了，就表示失败了 它的本质就是一个绑定了回调函数的对象，而不是将回调函数传入函数内部 所以我们用.then(function(){})来执行请求设备许可后的处理方法 而如果请求失败或者设备不可用。会回调PermissionDeniedError 或者NotFoundError ，我们用链式调用.catch(function(){})来处理异常 注意：有可能这个对象既不返回允许，也不返回拒绝，因为用户不是百分百会选择允许使用或者拒绝使用，也可能用户什么都不选 好了，闲话不多说，简单聊一聊，具体的去看文档资料学习吧 接下来说一下获得使用设备的许可之后，我们怎么做 Promise.then(function(){})回调 刚刚说过，在then绑定一个回调函数，可以用来处理获得许可后的方法，那么我们就来看一下这里的代码 这里，表示我们取得使用权，那么我们就只需要处理反馈给我们的stream(流)就可以了 然后，我们获得视频轨道（后面我们需要关闭摄像头的），当然，在代码中我们为了严谨，还是做了一步判断，就简单来谈一下吧 $this.MediaStreamTrack = typeof stream.stop === ‘function’ ? stream : stream.getTracks()[1]; 这个我们先判断返回的流stream是不是一个函数，如果是的话，那么有可能这个流里面包含的不仅仅是一个视频轨道，所以在这进行了判断，更为严谨。三元表达式就不解释了吧。 处理完stream之后，就非常简单了，我们想要在页面上展示视频，就是使用video，那么通过document获得页面元素video的dom对象video（因为懒得想名字了，就直接var video了。别误会它是什么东西，就是通过id获取的页面元素） $this.video.srcObject = stream; 然后，就给video这个对象的srcObject赋值为当前的stream，完美搞定 这里需要注意一下，有的帖子中写的是video.src = stream，可坑死了 因为之前没写过，所以刚开始就直接赋值的别人的代码，结果没画面，但是摄像头打开了 就是因为属性不是src，而是srcObject 于是乎，就去了上边链接的网站上看了很久文档，才慢慢搞明白怎么回事，然后自己封装成了自己的组件，以备不时之需，嘿嘿嘿 虽说路径已经配好了，不过不觉得还差点什么吗？没错，video没有开始播放啊，不解释了，.play() 拍照 ok，摄像头画面我们有了，那么就该”拍照”了吧，为什么把拍照两个字用引号引起来？还不懂吗？因为压根就不是拍照，而是canvas画图 这一步就非常简单了，照旧，在页面上添加一个 拍照 按钮，然后点击事件里面代码如下： 1$this.context.drawImage($this.video, 0, 0, 200, 400); 一行代码搞定，就是直接将video像之前的img一样，直接放进去就OK了 关闭摄像头 记得关闭摄像头 1$this.MediaStreamTrack.stop(); 问题点画面出不来 别急别急，有可能是浏览器不兼容的问题 那么我们通过Navigator.mediaDevices来请求摄像头，可能因为浏览器问题而出现错误，别急，我们还有另一种办法 12345678910navigator.getMedia(&#123; "video": true &#125;).then(function (stream) &#123; console.log(stream); $this.MediaStreamTrack = stream.getTracks()[1]; $this.video.srcObject = (window.webkitURL).createObjectURL(stream); $this.video.play(); &#125;).catch(function (err) &#123; console.log(err); &#125;); 不过这种就是会返回一个函数 拍照无效果？ 这个不解释了，有这个问题很大部分应该就是画图中出现的那两个问题吧，如果当时你不知道为什么会出现那两种情况，那么当你做到摄像头拍照的时候就有可能会遇到了 好了，这个不解释，但是下面我们来完善一下页面，并且看看为什么会出现之前提出的两个问题 七、完善页面效果完善 嘿嘿，说到这，我要提要求了，我们一般摄像头拍摄，是不是有需要弹出层的？有需要将影像固定在某个区域的，反正肯定不会是在页面最左上角吧？那样丑死了。 ok，那么我们就来看一下吧。最简单的思路就是，将video元素和canvas元素共同放在同一个容器中，这样不管需求想要将影像在哪呈现，只要把这个容器拿过去就OK了，里面什么都不需要动。 123456789&lt;div id="camera"&gt; &lt;div id="contentHolder"&gt; &lt;video id="video" width="640" height="480" autoplay&gt;&lt;/video&gt; &lt;canvas id="canvas" width="640" height="480"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;div id="buttons"&gt; &lt;button id="btn_snap" class="btn btn_blue"&gt;拍照&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; ok，我的页面（老脸很红，这明明是朋友发来的页面）时这个样子滴，一个大的容器id = “camera”，而里面分两块div，一个是contentHolder用来呈现影响video以及拍照后保存画面的vanvas，另一个是存放按钮 我草，为什么会这样 为什么？ 现在能够看到，原来是canvas，当初我们实验的时候没考虑过页面美化的问题吧？那么这个canvas怎么办？ 很简单啦，将canvas设置为none不就行了？ 但是，千万别傻傻地将canvas设置宽高为0，然后再改回来，这样没法画图的，上面的实验也说过了 js完善 ok，如果按照之前设置为none之后，那么后面可能会没有画面，这个没关系，还记的之前的canvas补充里面的实验吗？就那么解决 但是还是有点担心，在将canvas设置为display:block之前，千万别忘记吧video设置为display:none，因为我们的容器只能同时容纳其中一个的大小，是为了美观，同时也是为了造成一种假象，那就是视频和拍照都在同一个容器里面，其实是两个元素（video和canvas）进行切换的 代码如下： 123$this.video.style.display = "none";$this.canvas.style.display = "block";$this.context.drawImage($this.video, 0, 0, 200, 400); 组件 最后就是个人封装的组件，代码就不贴在这了，单独贴到一个文章中吧]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>实录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java详解jvm工作原理和流程]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F15%2Fjava%E8%AF%A6%E8%A7%A3jvm%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！ [TOC] 一、浅说java说起java,人们首先想到的是java编程语言,然而事实上,Java是一种技术,它由四方面组成: java编程语言 java类文件格式 java虚拟机 java应用程序接口(Java API) 其关系如: java平台由Java虚拟机和Java应用程序接口搭建,java语言则是进入这个平台的通道,用Java语言编写并编译的程序可以运行在这个平台上. 这个平台结构: 运行期环境代表着Java平台,开发人员编写Java代码(.java文件),然后将之编译成字节码(.class)文件,在然后字节码被装入内存,一旦字节码进入虚拟机,它就会被解释器解释执行,或者是被即时代码发生器有选择的转换成机器码执行. java程序经过一次编译之后，将java代码编译为字节码也就是class文件，然后在不同的操作系统上依靠不同的java虚拟机进行解释，最后再转换为不同平台的机器码，最终得到执行。这样我们是不是可以推演，如果要在mac系统上运行，是不是只需要安装mac java虚拟机就行了。 JVM在它的生命周期中有一个明确的任务,那就是运行java程序,因此当Java程序员启动的时候,就产生JVM的一个实例;当程序运行结束的时候,该实例也就跟着消失了 在Java平台的结构中,可以看出,Java虚拟机(JVM)处在核心的位置,是程序与底层操作系统和硬件无关的一个关键.下方是移植接口. 移植接口由两部分组成：适配器 和 Java操作系统 其中依赖于平台的部分被称为适配器 JVM通过移植接口在具体的平台和操作系统上实现;在JVM的上方是Java的基本类库和扩展类库以及他们的API,利用Java API编写的应用程序(application)和小程序(java applet)可以在任何Java平台上运行而无需考虑底层平台,就是因为有Java虚拟机(JVM实现了程序与操作系统的分离,从而实现了Java的平台无关性) 二、JVM基本概念和运行过程1.基本概念:1JVM是可运行Java代码的假象计算机（虚拟计算机） JVM包括： 一套字节码指令集 一组寄存器 一个栈 一个垃圾回收 堆 一个存储方法域 JVM是运行在操作系统之上的,它与硬件没有直接的交互 2.运行过程Java源文件 通过 编译器 能够产生相应的 字节码文件(.Class文件) ,而字节码文件又通过 Java虚拟机中的解释器 编译成 特定机器上的机器码 12java源文件 ----&gt; 编译器 ----&gt; 字节码文件字节码文件 ----&gt; JVM ----&gt; 机器码 每一种平台 的 解释器是不同的, 但是实现的 虚拟机 是 相同 的,这也就是Java为什么能够 跨平台 的原因了 当一个 程序从开始运行 这时 虚拟机 就开始 实例化 了, 多个程序 启动就会存在 多个虚拟机实例. 程序 退出或关闭, 则虚拟机 实例消亡 , 12注意:多个虚拟机实例之间数据不能共享 3.三种JVM:1234567- Sun 公司的 HotSpot- BEA 公司的 JRockit- IBM 公司的 J9 JVM在 JDK1.7 及其以前我们所使用的都是 Sun 公司的 HotSpot, 但是由于 Sun公司 和 BEA公司都被 oracle 收购jdk1.8 将采用 Sun 公司的 HotSpot 和 BEA 公司的 JRockit 两个JVM中 精华 形成 jdk1.8的JVM 三、JVM的体系结构 1.Class Loader类加载器负责加载.class文件,class文件在文件开头有特定的文件标示,并且ClassLoader负责class文件的加载等.但是至于它是否可以运行,则由Execution Engine(执行引擎)决定 定位和导入 二进制.class文件 验证 导入类的正确性 为类 分配 初始化 内存 帮助 解析 符号引用 2.Native Interface 本地接口本地接口的作用是 融合不同的编程语言为Java所用, 它的 初衷 是融合 C/C++ , Java诞生的时候C/C++横行的时候,想要立足,必须调用C/C++程序, 于是就在内存中专门开辟了一块区域处理标记为 native的代码. 具体做法: Native Method Stack中登记native 方法,在Execution Engine执行的时候加载native libraies(本地方法库) 不过目前该方法使用的越来越少了,除非是与硬件有关的应用, 如: 通过Java程序驱动打印机,或者Java系统管理生产设备,在企业级应用中已经比较少见 因为现在的 异构领域空间 的通信很发达 ,比如:可以使用 Socket通信, 也可以使用 Web Service等 3.Excution Engine 执行引擎:执行 包在 装载类 的方法中的 指令,也就是 方法 4.Runtime data area 运行数据区:虚拟机内存或者 JVM内存, 从整个 计算机内存中开辟 一块内存 存储 JVM用到的 对象,变量等 运行区数据又分很多小区,分别为：方法区 堆 虚拟机栈 本地方法栈 程序计数器 5.JVM数据运行区详解(栈管运行,堆管存储):1说明: jvm调优主要就是 优化Heap堆和Method Area方法区 方法区 Method Area 方法区是各个线程共享的区域， 所有 字段 和 方法字节码 ,以及一些特殊方法如 构造函数, 接口代码 也在此定义. 简单说,所有 定义的方法的信息 都保存在该区域,属于 共享区间 静态变量 + 常量 + 类信息 + 运行时常量池 存在方法区中 堆 java堆也是线程共享的区域，我们的类的实例就放在这个区域(而指向该实例变量的引用存在栈)， 可以想象你的一个系统会产生很多实例，因此java堆的空间也是最大的。 如果java堆空间不足了，程序会抛出OutOfMemoryError异常。 也是 GC（垃圾回收机制） 主要的 回收区, 一个JVM 实例只存在 一个堆 类内存,堆内存的 大小 是可以 调节 的 虚拟机栈 VM Stack 栈是什么 ：栈也叫 栈内存, 主管Java 程序的运行, 是在 线程创建时 创建, 他的生命期是跟随 线程的生命期, 线程结束 栈内存也就 释放, 对于栈来说 不存在垃圾回收问题, 只要线程已结束该栈就over,生命周期和线程一致, 是 线程私有的 基本类型 的变量和 对象的引用 变量都是在函数的 栈内存中分配 栈存储什么：栈帧中主要保存 3类数据: 本地变量(Local Variables): 输入参数和输出参数以及方法内的变量 栈操作( Operand Stack ): 记录出栈,入栈的操作 栈帧数据( Frame Data ): 包括类文件,方法等等 栈运行原理 栈中的 数据 都是以 栈帧的格式 存在, 栈帧是一个 内存区块, 是一个 数据集, 是一个有关 方法 和运行期 数据 的 数据集 当一个方法A被调用时就产生了一个栈帧F1,并被压入到栈中,A方法有调用了B方法,于是产生栈帧F2也被压入栈,B方法有调用了C方法,于是产生的栈帧F3也被压入栈……依次执行完毕后,先弹出后进……F3,再弹出F2,F1 遵循 先进后出/后进先出 原则 就是说，java栈是每个线程私有的区域，它的生命周期与线程相同，一个线程对应一个java栈，每执行一个方法就会往栈中压入一个元素，这个元素叫“栈帧”，而栈帧中包括了方法中的局部变量、用于存放中间状态值的操作栈，这里面有很多细节。如果java栈空间不足了，程序会抛出StackOverflowError异常，想一想什么情况下会容易产生这个错误，对，递归，递归如果深度很深，就会执行大量的方法，方法越多java栈的占用空间越大。 本地方法栈 Native Method Stack 本地方法栈角色和java栈类似，只不过它是用来表示执行本地方法的，它的具体做法是Native Method Stack中登记native方法，本地方法栈存放的方法调用本地方法接口，在Execution Engine执行时候加载native libraies ，最终调用本地方法库，实现与操作系统、硬件交互的目的。 程序计数器 PC寄存器（有的这么叫，这里提一下），说到这里我们的类已经加载了，实例对象、方法、静态变量都去了自己该去的地方，那么问题来了，程序该怎么执行，哪个方法先执行，哪个方法后执行，这些指令执行的顺序就是PC寄存器在管，它的作用就是控制程序指令的执行顺序 （Register，也是记录，登记，寄存的意思，就是用来管理的） 每个线程都一个 程序计算器, 就是一个 指针, 指向 方法区中的 方法字节码 (下一个将要执行的指令代码),由 执行引擎读取 下一条指令,是一个 非常小 的内存空间,几乎可以 忽略不计 6.堆内存 堆内存分为3部分: 1.新生区 新生区是 类 的 诞生,成长,消亡 的区域. 一个 类 在这里 产生,应用, 最后被 垃圾回收器收集,结束生命 新生区又分为两部分: 伊甸区(Eden space) :所有的类都是在伊甸区被new出来的 幸存者区(Survivor Space) :有两个,0区和1区 当伊甸区的空间用完时,程序有需要创建对象,JVM的垃圾回收器将对伊甸区进行垃圾回收(Minor GC),将伊甸区中的剩余对象移动到幸存0区, 若0取也满了,对该区域进行垃圾回收,然后移动到1区 1区满了移动到养老区(Tenure Generation Space) 养老区满了,这时候将产生Major GC(FullGC),进行养老区的内存清理. 若养老区执行Full GC之后发现依然无法进行对象的保存,会产生OOM异常(OutOfMemoryError,内存溢出) 所以，如果出现java.lang.OutOfMemoryError:Java heap space异常,说明Java虚拟机的堆内存不够 ，原因有二： Java虚拟机的堆内存 设置 不够,可以通过参数 -Xms, -Xmx 调整 (jvm调优方面会说) 代码中创建了 大量大对象,并且长时间 不能被 垃圾收集器 收集(存在被引用) 2.养老区 用于保存从新生区筛选出来的Java对象,一般 池对象 都在这个区域活跃 年老代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在） 内存大小相对会比较大，垃圾回收也相对没有那么频繁（譬如可能几个小时一次） 年老代主要采用压缩的方式来避免内存碎片（将存活对象移动到内存片的一边，也就是内存整理）。 当然，有些垃圾回收器（譬如CMS垃圾回收器）出于效率的原因，可能会不进行压缩。 （这些调优篇细讲） 3.永久区（Permanent Space ） 是一个 常驻内存区域 , 用于存放 JDK自身 所携带的 class,interface的元数据 也就是说它存储的是 运行环境必须 的类信息,被装载进此区域的数据是 不会被 垃圾回收器 回收 掉的 关闭JVM 才会释放 此区域所占用的内存 如果出现java.lang.OutOfMemoryError:PermGen space,说明是Java虚拟机对永久代Perm内存设置不够 ，原因也有两点： 程序启动需要加载大量的第三方jar包. 如:在一个tomcat下部署了太多的应用 大量动态反射生成的类不断被加载,最终导致Perm区被占满 关于永久区的个版本： jdk1.6之前:常量池分配在永久带 jdk1.7:有,但已经逐步”去永久带” jdk1.8之后:无(java.lang.OutOfMemoryError:PermGen space这种错误将不会出现在JDK1.8中) 下面两张图片解释一下 四、 方法区和堆内存的异议:实际而言,方法区和堆一样,是各个线程共享的内存区域,它用于存储虚拟机加载的: 类信息+普通常量+静态常量+编译器变异后的代码 虽然JVM规范将方法区描述为堆的一个逻辑部分,但它却还有一个别名叫做Non-Heap(非堆),目的就是要和堆分开. 对于HotSpot虚拟机,很多开发者习惯将方法区称之为”永久代(Parmanent Gen)”,但严格本质上说两者不同,或者说使用永久代来实现方法区而已,永久代是方法区的一个实现,jdk1.7的版本中,已经将原本放在永久代的字符串常量池移走 常量池(Constant Pool)是方法区的一部分,class文件除了有类的版本,字段,方法,接口等描述信息外,还有一项信息就是常量池,这部分内容将在类加载后进入方法区的运行时常量池中存放. 五、简单补充堆内存调优简介]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的关键字native]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F15%2FJava%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97native%2F</url>
    <content type="text"><![CDATA[【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！ [TOC] 一、简单介绍native关键字 众所周知，java是跨平台的语言，既然跨平台，就要牺牲对底层的控制，所以java对于底层的控制就依赖于其他语言的帮助，而这就是native的作用 native是用作java和其他语言进行协作时用的，也就是native后的方法的实现不是用java写的。既然不是java写的，那肯定看不到它的源码了 native修饰的方法时一个原生态方法,方法对应的实现不是在当前文件,而是在用其他语言(如C或者C++)实现的文件中.并且被编译成了dll文件。 这些方法的实现体在dll文件中，jdk的源码中并不包含，所以是看不到的。对于不同的平台，他们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的 Java语言本身不能对操作系统底层进行访问和操作,但是可通过JNI接口调用其他语言来实现对底层的访问. JNI是Java本机接口(Java Native Interface),是一个本机编程接口,是Java软件开发发工具箱(java Software Development Kit, SDK)的一部分.JNI允许Java代码使用以其他语言编写的代码和代码库. Invocation API(JNI的一部分)可以用来将Java虚拟机(JVM)嵌入到本机应用程序中,从而允许程序员代码内部调用java代码 所以，native的意思就是通知操作系统，我需要这个方法，而你操作系统需要给我实现，我需要使用。而java只需要调用操作系统的方法就行了 java不是完美的，java的运行速度上比传统的C语言慢许多，java无法直接访问到底层操作系统等缺点。当然，解决方法就是上面说的利用native方法来扩展java程序的功能。以下有实践步骤：是之前做笔记的时候尝试的： 二、实践理解1使用java调用C的"sayHello" 1.创建一个java类 123456789101112public class HelloNative &#123; static&#123; System.loadLibrary("HelloNative"); &#125; public static native void sayHello(); @SuppressWarnings("static-access") public static void main(String[] args) &#123; new HelloNative().sayHello(); &#125;&#125; 这里有一个sayHello()方法，native标识该方法的实现在非当前文件，在static静态快中加载的library(HelloNative)中 运行main()之后出现以下情况 12 报错信息时说找不到library(“HelloNative”)的路径，因为我们本地就没有这个文件 2.创建本地方法文件 我们将Java类HelloNative复制出来，（我给放在了D盘根目录，方便） 然后在控制台用javac命令将其编译成字节码文件， 1javac HelloNative.jave 注意：如果命令输入目录与.java文件不在同一目录下，javac命令后的文件名要加路径，如图中d:\HelloNative.java： 然后在用havah编译，获得包含C声明头文件 1javah HelloNative 注意：在这里，我命令目录与文件目录不在同一路径，报错了，这个命令不会区别路径，而是在当前目录下找d:\HelloNative这个名字的文件，把d:\也当成文件名字的一部分 到此，我们一共有三个文件了： 看一下.h文件的内容吧： 123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class HelloNative */#ifndef _Included_HelloNative#define _Included_HelloNative#ifdef __cplusplusextern "C" &#123;#endif/* * Class: HelloNative * Method: sayHello * Signature: ()V */JNIEXPORT void JNICALL Java_HelloNative_sayHello (JNIEnv *, jclass);#ifdef __cplusplus&#125;#endif#endif 创建.c文件： 12 然后运行gcc命令来生成dll共享库 12 命令中的路径是电脑中jdk的安装路径\include 完成后这样就有5个文件了： 然后在用java命令运行一下java代码，就能成功在cmd通过java代码调用c的sayHello方法了 1java HelloNative 说明： 从gcc命令开始，没有图和真相了，那是因为我所有的笔记标签的文章都是回头看以前做的笔记的时候，重新整理记录一下，也有的是之前没有记录到的，整理的时候又重新学一遍；也有之前试验过但是现在环境不允许了。 不过又去了网上看了看帖子，别人的文章有的用的命令不一样，所以具体如何生成dll，尝试一下就行了，只要生成了dll就OK了 三、步骤总结：1总结一下步骤吧： 1 先创建java类，在类中加载需要的library，声明要调用的本地方法 2 使用javac命令编译.java文件，生成字节码文件.class 3 使用javah命令编译成.h文件，生成包含C声明头的文件 4 编写c文件（.c），然后通过gcc命令(或者vs C++环境下cl命令)生成dll 5 然后利用java命令运行Java代码检测是否成功 其实，上面的这个步骤是反着来的，是因为我们从java介入，往底层找的，真正的顺序应该是先写好的c方法生成dll共享库，然后jvm启动之后留在本地方法区中，随着我们写好java代码之后，如果需要用到本地方法，我们就去找相应的方法直接调用就行了(这部分可以简单看一下jvm方面的知识应该比较容易理解，好了，我再看看jvm的笔记)。]]></content>
      <categories>
        <category>java</category>
        <category>关键字</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用JPA创建原生sql(不使用实体类)]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F13%2F%E4%BD%BF%E7%94%A8JPA%E5%88%9B%E5%BB%BA%E5%8E%9F%E7%94%9Fsql-%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BD%93%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[[TOC] 一、描述 JPA很强大，嗯，没错，是很强大！ 它是通过JDK5.0注解或者XML描述对象-关系表的映射关系，并能够将在运行中的实体对象持久化到数据库中。 并且它也是面向对象查询，也就是将实体类与数据库的表映射，即使不会数据库的开发者，只要能看懂java的类，只要能熟练使用jpa，也能很便捷地操作数据库 当然，映射类有其好处，也有弊端。假如说，某个场景下，我需要查询多个表中的数据，并且每个表中只有一到两个字段有用，而整张表的字段又很多，所以有时候就不需要将每个表都完整映射成实体类（不然的话，每次查询就要多查询很多无用的垃圾信息） 今天遇到了这种场景，由于是多表联查，但是只需要其中各一个字段，其余的每个表十几个字段都没用。所以就不需要把每张表的数据都查询出来。而个人对于jpa也不熟练，所以踩了很多坑。下面就此记录： 二、实录（踩坑全过程，实力坑自己！Pain and happiness!想直接看结果，直接拉下去别看这段了） 想法1、返回map，不用实体类 1.dao层（Repository） 就是控制sql语句对数据库进行增删改查。 这里的接口很容易写，只需要继承JpaRepository&lt;entity,object&gt;接口就可以了# 这里需要注意： 1.entity，必须是被管理的类，也就是与数据库进行映射的实体类 所以，就坑在这了，一直报错说Repository什么什么类型必须是被映射管理的，而map却不是。奶奶的，继续想办法 想法2、 创建实体类（不过由于不懂，所以这里没有进行关系映射，就是一个单纯的javaBean，不用仔细说了失败！） ​ 注意： 1.实体类必须与数据库映射才算被映射管理（@Entity注解） 继续尝试 想法3、映射实体类(但是这次也只写了部分字段，自己需要的) ​ 注意： 加上注解标明映射之后，又特么脑残踩了个雷（鄙视自己一秒钟） 对于这个，说一下吧，由于最初没打算映射，并且需要的数据是多个表的，所以类名就自己起的名字。好家伙，提示table_name没有被映射过！我嘞个擦。所以在@Entity注解加上name属性： @Entity(name=”table_name”)最初的时候加错了，写成实体类的名字了，尴尬！这里其实要写表的名字，表明该实体类与那张表映射 与数据库映射的类必须有@Id标明主键(失败一次！吼，不想解释了) 这一点忍无可忍！错误信息说，表中为not null的字段，必须在实体类中映射！也就是实体类中必须有非空字段的属性！！！ 吼吼吼！！我连吼三次可以了吧！那我跟映射全部字段有什么区别呢？还是初衷吗？ 以上一环扣一环之后，想要按照之前想法，实体类，拜拜！ 经过以上绕的弯路，所以就又绕回来了。哼哼！于是乎：老子不用实体类了，也不继承JpaRepository。 想法4、注解托管Repository！ 奈斯！启动刚开始没报错，之前报错貌似跳过去了！突然之间，XXXXXX that could not be found，我真xxxx了，然后去网上找解决方法，要吐血！各种各样的方法，没用！直到我看到一个帖子： 一口老血啊！果断不找了！ （别学我，因为刚刚在找这个帖子的时候，无意间瞥见另一个帖子， 解决方案是：在Application启动类中加上注解：@EnableJpaRepositories(&quot;com.example.repository&quot;)来说明要扫描的类， 虽然之前也在启动类中加过注释，但我也记不清这个到底有没有尝试过了， 感觉很靠谱，这里说一下！失败了也别来找我,也有可能环境不同） 所以！这是一个死循环啊，想要用dao层Repository，OK的，继承JPARepository吧， 等等，我jpa有条件的，entity呢？ 好，给你！ 慢着，我entity不干，先给cp一个数据库表吧，我可不打酱油的！唉，给你cp个表吧， 停！cp随便你，但是我有孩子，得带过去，你去问问entity同不同意！ 尼玛，可怕！！！ 于是，果断放弃了从dao层入手。 三、解决方案 JPA很强大，嗯，没错，是很强大！ 又是这句话，没错，我们如果映射实体类的话，那么目前的情况就感觉无用数据太多，而且累赘，要映射好几张表 但是别怕，jpa不但能面向对象查询，还支持原生sql，能够让我们根据自己的想法来实现 第一种：使用注解@Query(value=”sqlString”) 第二种：entityManager.createNativeQuery(sqlString) 第一种，注解在dao层的方法上，由于我自动装配出问题了，并且及早地放弃了，所以没用， 第二种，上代码 123456Query query = entityManager.createNativeQuery("select * from user where id = ?");query.setParameter(1,"g10001");List list = query.getResultList();Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put("name1",objs.get(0)[0].toString()); map.put("name2",objs.get(0)[1].toString());...... 搞定！list是List&lt;Object[]&gt;类型，里面放的就是一条条数据，而Object[]数组里面是一条数据中的所有字段。 不过又见几个坑，是网上的帖子，代码如下： 123for(Object os : list)&#123; Map map = (Map)os;&#125; 我只求数组（实际上是Object类型的数组）强转Map这波操作！！！！没别的要求 四、诙谐的话语，搞笑而又逗逼！就跟老朋友聊骚，听老朋友牢骚。轻松吗？]]></content>
      <categories>
        <category>java</category>
        <category>框架</category>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>实录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql建表时设置日期默认值及默认修改时间]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F12%2Fmysql%E5%BB%BA%E8%A1%A8%E6%97%B6%E8%AE%BE%E7%BD%AE%E6%97%A5%E6%9C%9F%E9%BB%98%E8%AE%A4%E5%80%BC%E5%8F%8A%E9%BB%98%E8%AE%A4%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[[TOC] 一、简单说明在做项目的时候，在数据库中基本上都会有关于日期的问题。其中不乏包括日期格式、运算、比较等等。不过这些都很常见了，今天要记录的点，非常简单，不过可能也是很多情况下忽略的东西。 关于这次记录的东西，就是mysql中时间格式的默认值。 很多时候，我们都会对一条数据的相关时间进行记录，比如创建日期，修改日期等等最常见的。而处理这些日期的大部分方法，一般是在后台中获取当前的时间，然后随着数据插入到表中进行保存。 下面，要说的是用mysql自带的方法来实现。（如果觉得没多大意义的话，请止步到此吧，如果想了解一下，请继续） 二、图文示例这里使用的版本是MySQL 5.6 1.mysql的日期和时间类型（这里会展示一下各种时间格式，不想看的跳过）先来看一下mysql中的日期和时间类型，以及其值的样子 - 在图中我们能够看到，我给所有的日期和时间类型赋值都是年/月/日 时:分:秒.毫秒 - 而最终查询出来的日期格式如列表展示，不同的类型，格式也不同 - 其中year类型只能赋值并保存年份，不过这个字段的赋值有点有意思的地方 1.1 year类型我们先来看看不同的赋值的结果 1.首先赋值0 2.然后1 应该有人应该猜出来了吧,不过我很好奇的是，这个赋值到底范围是多少，于是在这个过程中又遇到了有趣的事情 3.然后： 1到这里就能看出来，mysql日期虽然年份能够不用写完整的4位，但是对于只写两位数，mysql中还是有点范围的70表示1970，而0表示的是2000，很显然，最多就是99表示1999了，然后从1-69表示的是2001-2069，所以mysql非完整的年份默认值范围0-99 4.完整年份最大值 1不要问我怎么来的，我无聊 2.正题：设置默认时间1这个设置是创建该数据的当前时间 1.使用函数now() 1mysql中有函数可以在sql语句中直接使用（废话不解释了），now()都不陌生 1不过支持now()函数的只有datetime和timestamp两种类型，其他三种都不支持 2.current_（cur系列） 123我们可以利用default current_timestamp为timestamp类型的设置默认值不过很无奈的是，mysql中有current_date和current_time等，但是我这个版本却不能用， 3.自动记录修改时间 1在这里能够看到，id为1的这条数据时间变成了执行update时候的时间 1由于前两天接了新项目，所以写了一半就停下来了，今天有点时间，想着就写完它。勉强看，也算给自己做个记录]]></content>
      <categories>
        <category>DB</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>日期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
