<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java整型封装类Integer的比较]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F29%2Fjava%E6%95%B4%E5%9E%8B%E5%B0%81%E8%A3%85%E7%B1%BBInteger%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！ 一、浅说（这是废话）数字类型​ 我们日常中经常会使用的数字来进行各种计算，比如1，2，3等这些自然数，当然这些自然数都是整的，不会像小数1.1，2.5，3.21等等这样有小数点的零散的小数，这些大于0的数字都被称为正数。 ​ 当然，有大于必然会有小于，所以那些小于0的数字被称为负数，如-1，-2，-3，-5.33，-7.4等 ​ 而在这些负数中也是跟正数一样，除了代表小于0的负号（-）之外，其他都一样，有的像1，2，3一样没有小数点，有的却有小数点，这样我们可以把所有数字分为整数和小数 java中代表数字的类型​ 这些最基本的知识点，就不在这过多介绍，简单提一下 整型：java中的整型就是上面我们说的整数，java中整型的数据类型有这么几个byte、short、int、long 浮点型：浮点型，说的就是带有小数点的小数了，java中浮点型的数据类型有flot、double 这里就简单过一下，今天我们要说的并不是这几个数据类型，而是另一种 引子上面所说的数据类型，都是java中的基本数据类型，也就是这门语言出生就定义好的类型。占用的内存空间比较小，用起来也比较方便。 但是，尽管如此，依然会有它自己的缺陷。我们应该都知道，其实在项目中用的比较多的并不是这些基本数据类型，而是它们的封装类 为什么要用开销更大的封装类，而不是这些基本类型? 最简单的一个问题，在一个类中的属性，定义一个整型变量，那么这个变量会有一个默认值0，这个时候，这个0到底是传递过来的值就是0呢？还是因为没有给这个它赋值的默认值呢？ 如果你说自己赋值自己不知道吗？那么项目中一般拿值都会从前端传递过来，这个时候在程序运行的过程中，我们又怎么知道这个值是前端传过来就是0呢？还是因为前端没有传所以默认值为0了呢？ 好了，简单讨论，所以我们能看出来，基本数据类型有时候并不能满足一些需求，所以这些基本数据类型的封装类（升级版）就来了。 今天我们要说的是整型int的封装类（Integer） 二、由该话题引发的补充疑问我想应该有人在初学的时候，有人会告诉你，Integer类型进行值比较的时候，要用equalse()方法进行比较，但是有时候我们却还是用==进行比较，你会发现，有的时候==比较两个相同数字的Integer对象，返回的是true，有的时候却是false，接下来会详细说明 == 和 equals()这里在简单提一下二者的区别 首先，==比较的是两个值，而equals()比较的是两个内容 我想我提出的这个概念会有很多人不解甚至会喷，因为大部分人都有这样根深蒂固的概念： ==比较的是地址，equals比较的是值 这么说也不能算错吧，毕竟大多数人都是这么说的。 而我有一点疑问提出来，就是这种说法的不严谨： 我们都知道，地址一般是对象才有，也就是说我们存在堆中的对象才会有指向这个对象在堆中实际位置的地址，而我们把这个地址会存在一个变量中，而这个变量中的值，就是这个地址，这个值也是存在栈中的 对此，所以人都说==比较的是地址，而equals比较的是值 那么我想问一下，这样的说法置基本数据类型byte、short、int、long、double、float于何地？他们有指向堆中对象的地址吗？ 所以说，我觉得存在栈中的不管是指向对象的地址，还是基本数据类型本身的值，都是这个变量存储的值，而存在于堆中的真正对象，保存的就是这个对象的内容（包括其拥有的属性、行为方法等，都是这个对象的内容） 如果你有更有助于自己理解的概念，那更好 好了，上面的说法可能跳的有点快，不过没办法，这里是要说封装类Integer，关于虚拟机的内存模型，这里就不细说了 三、实验实录好了，扯了那么多，还没真正进入话题，想喷就喷吧 问题现象现在来说一下这个问题的现象： 1. 先看int123int a = 1;int b = 1;System.out.println("int a == int b 结果："+(a == b)); 这个结果不用多考虑，为true是吧？ 2. 再看Integer123Integer c = 1;Integer d = 1;System.out.println("Integer c == Integer d 结果："+(c == d)); 好，按照我们之前说的，==比较的是c和d的值（栈中的值）， 那么这里分析下：我们创建一个Integer对象c，给这个对象赋值为1，然后我们又创建一个对象d，这个对象也赋值为1，然后用==比较c和d，我们比较的是两个对象存在栈中的地址，也就是c和d真正的值（指向对象的地址） 结果如何？ 吼，是true，好了，暂且到这，先不讨论，接下来看另一个实验： 3.再看一次Integer 瞧，我们看到了什么？ false唉，刚刚还是true的，为什么变成false了呢？ 问题依旧保留，我们来看看equals() 4.看看equals() 之前说了，equals()是比较两个对象内容是否完全一致 我们看看用equals比较这两种情况的结果 true，两个都是true，说明两个对象内容完全一致。 查找原因断点调试 我们一般遇到问题首先想到的是断点调试，这没问题，那么我们来走一波看看 打上断点，进入调试，然后分步来看，慢慢解析 注意看这张图的几个点，我们走到c、d两个Integer对象创建结束， 能够在Variables中看到，已经创建好了c、d两个对象，值都是1 注意看一下括号中，这里标明了c、d两个对象都是Integer对象，而这两个对象的记录编号都是525 ok，继续往下走 这里我们看到，有创建了e、f两个值为1111的Integer对象，记录编号分别是528，529 到这里不知道你们有没有这个疑问，反正我在研究的时候是有了疑问： 为什么e、f两个对象记录编号是临近的528，529？ 为什么在d之后创建的对象e不是临近在d之后的526？f为什么不是527？]]></content>
      <categories>
        <category>java</category>
        <category>数据类型</category>
        <category>整型</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jpa自动映射java实体类与数据库表]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F28%2Fjpa%E8%87%AA%E5%8A%A8%E6%98%A0%E5%B0%84java%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[​ 之前有说过jpa不实用实体类，那是某种特殊情况的时候的需要 ​ 而大多数的时候，我们后端代码还是需要有与数据库对应的实体类的 ​ 这样方便后端进行管理数据，而且更易于使用jpa框架 这次废话不多说，毕竟时间不多，简单做一些记录，反正对于这个框架还不太熟悉！有机会再来好好研究一番 下面直接说出如何去写，原理，实验什么的就先免了 实体类123456789101112131415@Data@NoArgsConstructor@AllArgsConstructor@Builder@Entity@Table(name = "ssprt_config",uniqueConstraints = &#123;@UniqueConstraint(name = "UK_SSPRTCONFIG_TYPE",columnNames = "type")&#125;)public class SsprtConfig &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = "type",length = 50) private String type; @Column(name = "value",length = 1) private Integer value;&#125; 简单解释： @Data：不用说了，就是getter、setter方法 @NoArgsConstructor：无参构造 @AllArgsConstructor：所有参数的构造 注意2和3两个注解，最好加上，因为我们利用jpa查询数据的时候，查完数据通过构造进行给实体类赋值，没有的话会报有关构造函数的错误 @Builder：builder创建对象，利用静态方法builder来创建对象，而不用new，提供链式setter赋值，方便快捷 @Entity：标注这是一个实体类，是一个与数据库映射的实体类 @Table：标注这个类所对应的数据库中的表名，同时，如果数据库中没有与之对应的表，会自动生成该表与之对应（这个要在配置文件中配置策略，不细说了，因为我也只是知道，并没有研究） name：不是必须的，如果没有，那么使用默认的该实体类的短类名。 uniqueConstraints：唯一键，指定某个列columnNames @Id：标注为主键 @GeneratedValue：主键生成策略， TABLE：使用表保存id值 IDENTITY：identitycolumn SEQUENCR ：sequence AUTO：根据数据库的不同使用上面三个 @Column：生命该字段与数据库表字段的映射关系， name指表字段名，length指数据长度，注意数据类型使用封装类]]></content>
      <categories>
        <category>java</category>
        <category>框架</category>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas-camera]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F21%2Fcanvas-camera%2F</url>
    <content type="text"><![CDATA[这里是运用canvas来实现电脑摄像头拍照的功能的js代码。 纯属个人兴趣 以下是个人封装的js，好坏皆是如此 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * * 调用摄像头 * 传入参数：必须 * canvas：画布，传入的参数为id,class,name或者tagName四选一，注意：只需要传入名称即可,不需要符号， * 例如:&lt;canvas id = "myCanvas"&gt;&lt;/canvas&gt;,那么入参就是myCanvas * video：影像，传入id，class，name，或者tagName四选一 * * 传入参数：非必须 * open ：打开摄像头功能的按钮id，class，Name * snap ： 拍摄功能的按钮id，class或者name * close： 关闭摄像头功能的按钮id，class或者name * * 注意：如果不传入按钮功能，会有open，snap，close三个function来提供相应的功能，可以直接使用canCamera.open()等来调用 * * 同时，提供链式调用 * * 调用示例： * var cc = canCamera(&#123; * canvas:"myCanvas", * video:"myVideo", * open:"start", * snap:"getPhotoBtn", * close:"closeBtn" * &#125;) * * 或者： * * var cc = canCamera(&#123; * canvas:"myCanvas", * video:"myVideo" * &#125;) * //绑定按钮点击事件 * document.getElementById("start").addEventListener('click',cc.open); * document.getElementById("getPhotoBtn").addEventListener('click',cc.snap); * document.getElementById("closeBtn").addEventListener('click',cc.close); * */(function (window, document) &#123; var canCamera = function (obj) &#123; var $this = canCamera $this.canvas = document.getElementById(obj.canvas) || document.getElementsByName(obj.canvas)[0] || document.getElementsByClassName(obj.canvas)[0] || document.getElementsByTagName(obj.canvas)[0] $this.video = document.getElementById(obj.video) || document.getElementsByName(obj.video)[0] || document.getElementsByClassName(obj.video)[0] || document.getElementsByTagName(obj.video)[0] $this.openBtn = document.getElementById(obj.open) || document.getElementsByName(obj.open)[0] || document.getElementsByClassName(obj.open)[0] $this.snapBtn = document.getElementById(obj.snap) || document.getElementsByName(obj.snap)[0] || document.getElementsByClassName(obj.snap)[0] $this.closeBtn = document.getElementById(obj.close) || document.getElementsByName(obj.close)[0] || document.getElementsByClassName(obj.close)[0] $this.context = $this.canvas.getContext('2d') $this.MediaStreamTrack = null $this.open = function () &#123; $this.video.style.display = "block"; $this.canvas.style.display = "none"; if (navigator.mediaDevices &amp;&amp; navigator.mediaDevices.getUserMedia) &#123; navigator.mediaDevices.getUserMedia(&#123; "video": true &#125;).then(function (stream) &#123; $this.MediaStreamTrack = typeof stream.stop === 'function' ? stream : stream.getTracks()[1]; $this.video.srcObject = stream; $this.video.play(); &#125;).catch(function (err) &#123; console.log(err); &#125;); &#125; else if (navigator.getMedia) &#123; navigator.getMedia(&#123; "video": true &#125;).then(function (stream) &#123; console.log(stream); $this.MediaStreamTrack = stream.getTracks()[1]; $this.video.srcObject = (window.webkitURL).createObjectURL(stream); $this.video.play(); &#125;).catch(function (err) &#123; console.log(err); &#125;); &#125; else &#123; alert("浏览器不支持！"); &#125; return $this &#125;; $this.snap = function () &#123; var w = $this.video.offsetWidth, h = $this.video.offsetHeight; $this.video.style.display = "none"; $this.canvas.style.display = "block"; $this.context.drawImage($this.video, 0, 0, w, h); return $this &#125;; $this.close = function () &#123; $this.MediaStreamTrack &amp;&amp; $this.MediaStreamTrack.stop(); return $this &#125;; if ($this.openBtn) $this.openBtn.addEventListener('click', $this.open); if ($this.snapBtn) $this.snapBtn.addEventListener('click', $this.snap); if ($this.closeBtn) $this.closeBtn.addEventListener('click', $this.close); window.canCamera = canCamera || new canCamera() return $this &#125; window.canCamera = canCamera || new canCamera()&#125;)(window, document)]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>HFJs</category>
      </categories>
      <tags>
        <tag>兴趣</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端画图Canvas简单运用]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F19%2F%E5%89%8D%E7%AB%AF%E7%94%BB%E5%9B%BECanvas%E7%AE%80%E5%8D%95%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、前言 朋友遇到的情况，属于前端的问题，是需要打开摄像头来拍照，关于这个问题，他找到了我让我来帮他解决，不过由于我的前端也是属于那种半吊子水平，所以在过程中也是参考了网上的不少资料和案例，不过还好的是因此也了解了不少知识，所以准备整理一下，做个记录 这篇主要是前端canvas画布功能，可能知识不够全面，但是要实现拍照应该是没问题了 除了参照图像资源进行利用canvas画图之外，canvas还有很多功能提供，方便我们直接在页面上进行手工绘画，这些功能这里就不展示了，因为我也忘记了，只是之前刚学前端的时候有捣弄过，不过现在主要做后台开发，所以前端水平就一般般 二、画图 在实现拍照之前，先来详细了解一下canvas画图功能，这样对于后面拍照会更简单一点 页面准备 实现canvas画图功能，我们需要准备一张图片，为了试验效果，我就随便截了一张桌面的图片 在页面中我们要放置一张图片(当然，也可以不用展示在页面上，这个js代码中会扩展)，所以需要img标签元素 想要进行在页面画图，我们还要通过canvas标签元素获得context(简称，后面展示全部)来帮我们实现这个功能 然后，为了进行测试，我们加一个按钮，当点击按钮的时候，我们将展示的图片画出来 html代码 我们需要的html代码很简单，只有三个元素：img、canvas、button 1234&lt;img src="../imgs/0.png" id="img"&gt;&lt;canvas height="400" width="200" id="canvas1" style="border: 1px solid gray"&gt;&lt;/canvas&gt;&lt;br/&gt;&lt;button id="draw"&gt;画图&lt;/button&gt; js代码及详解简单分析 在上代码之前， 先来说一下流程 我们想要参照img元素中的图片资源，利用canvas来将其画出来 那么首先我们就需要找到img元素中的图片， 其次还要有canvas画图的对象， 然后获得canvas的Context 最后配置Context的环境将img图片画出来 总体简单来说就这四步，下面直接上代码，然后再解释： js代码12345678window.onload = function () &#123; document.getElementById("ckbtn").addEventListener('click', function () &#123; var img = document.getElementById("img"); var cv = document.getElementById('canvas1'); var ct = cv.getContext("2d"); ct.drawImage(img, 0, 0, 200, 400); &#125;);&#125; js代码详细解释（以及踩过的坑和未踩过的坑） 注意点1、window.onload 这个window.onload不用多解释，就是在页面加载完成之后再执行funciton中的这段代码 为什么一定要这么做呢？ 那是因为我们现在使用的页面元素，如果没有这个onload保证页面先加载完成，有可能会出现这种情况： canvas元素找不到，所以我们获取其dom对象的时候有可能会出现undefined 如果canvas出现undefined的话，那么我们必然无法获得该画布下的Context，也就无法实现画图功能 除此之外，运气好，我们canvas画布放的比较靠前，能够找得到，不过我们知道，图片属于外部静态资源，加载可能没有html原生代码快，这个时候，如果我们图片没有加载完成，也可能会出现画图失败 举个例子，假如有一个画家，他要为一个人画一幅像，但是不巧的是，这个人突然临时有事，不能准时到，那么在这个人还没有到达之前，这个画家怎么去画这幅画？他拿什么做参考呢？ 再者呢，我们又要绑定按钮，所以onload最好是加上 这里说了那么多，我们能够知道，如果我们看着代码没有错误，并且没有报错，那么很可能是图片没有加载完成，导致没法画出图片（之后还有一个可能的原因，在注意点2） 注意点2、canvas元素 这里要注意的是，我们所说的canvas画图，其实canvas只是一个画布,隐约记得曾经学的时候，好像还有画笔什么来着，记不清了，不纠结了、 真正实现画图功能的，是画笔而不是画布，而之前说的Context，是一种环境， 这里打个比方，canvas是画布，就是画家使用的画板，就是我们要画出的画的容器 那个画笔是什么来着，就是用来进行绘画的，之前说的能够手工绘画也是控制画笔在页面上进行绘画 而context，是环境，就好比我们画家用画笔在画布上绘画所需要的因素，在这里我个人将它理解为了画家，因为context提供了画图很多方法来满足画图的需要。就像一个画家一样具备的能力 这里简单展示一下context，关于context这个对象具体的代码有点多，有兴趣的可以自己研究 123getContext(contextId: "2d", contextAttributes?: Canvas2DContextAttributes): CanvasRenderingContext2D | null;getContext(contextId: "webgl" | "experimental-webgl", contextAttributes?: WebGLContextAttributes): WebGLRenderingContext | null;getContext(contextId: string, contextAttributes?: &#123;&#125;): CanvasRenderingContext2D | WebGLRenderingContext | null; 这里并不是很详细地解释了canvas，所以我们知道，canvas是容器，这里也会有一个小问题，不知道有没有人遇到过。（在做摄像头拍照的时候遇到了小问题，所以回头研究了canvas） 如果我们为了美观，不展示canvas来占空间，而设置为了display:none，那么会发生什么情况？ 另外，如果我们设置了canvas的长宽都为0，会是什么情况？ 对于以上两点，在下面会案例展示结果，先猜一下吧 注意点3、2维和3维画图 通过上面的getContext()方法，能够看得出来，我们假如传入的是“2d”这个字符串，那么就会获得CanvasRenderingContext2D这个对象 在没有看过这些代码之前，我也曾一度认为，有2d就有3d，果断丢个”3d”参数进去，哈哈，获得null，那么我们肯定觉得不合理，有2d画图就应该能画3d的啊，其实webgl就是用来画3d的，不过我不会，也不了解 不过有一点需要注意了，接下来图文解释更清晰 首先我获得canvas之后，通过传入参数3d 1234var cv = document.getElementById('canvas1'); console.log(cv) var ct = cv.getContext("3d"); console.log(ct) 获得的结果为null 然而我们如果传入的是”2d”或者”webgl”的话，确实能够获得context的 注意了：如果我们先入参2d获得返回对象保存在一个变量中，然后再入参webgl保存在另一个变量中，会是什么结果？ 123456var cv = document.getElementById('canvas1'); console.log(cv) var ct2d = cv.getContext("2d"); var ctwebgl = cv.getContext("webgl") console.log("ct2d:"+ct2d) console.log("ctwebgl:"+ctwebgl) 12345678910111213141516- 结果就是先获得的context占据这个画布，再设置另一个则没用了，直接为null。而官方原注释并没有解释为何，我们可以从官方注释中得到的信息，就是：- 返回一个对象，该对象提供绘制和操作文档中画布元素上的图像和图形的方法和属性。上下文对象包括关于颜色、线宽、字体和其他可以在画布上绘制的图形参数的信息。 @param上下文要创建的画布类型的标识符(ID)。Internet Explorer 9和Internet Explorer 10仅支持使用canvas.getContext(“2d”)的2d环境;IE11预览还支持3d或WebGL上下文使用canvas.getContext(“实验- WebGL”);- 好像并没有什么文字能解释为什么只能获得一次？那么我们就只能从代码中分析了，请移至注意点2查看代码，这里不贴了- w3school中也没有过多解释，不过这里依然不妨碍理解，这个方法大致为以下情况：- 根据入参来匹配2d或者webgl，如果是，那么会先去看contextAttributes，如果已经有值了（上次一调用之后会将2d或者webgl相应对象存下来，猜测），那么直接返回null，这就导致如果第一次已经拿到2d的对象了，那么下面再入参webgl调用，获得的就是null，而为什么不是返回上一次的，就是函数返回值的问题吧，看前两个getContext，返回值要么是对应的2d或webgl对象，要么是null。这就是说参数匹配到之后，就会执行相应的函数，而"2d"只会返回2d对象或者null，webgl也是一样。最后一个方法，是在参数不匹配2d或者webgl的时候，会先去返回2d，如果没有，再考虑webgl，最后二者都没有，就返回null- 其实，之上一点的看法，最后理解根本无法实践，因为按照最后的说法，我们必须要传一个参数过去，而如果我们先传过去2d，那么获得2d对象，这时候再去调用getContext实践，不好意思，之前已经设置过2d了，其他的我不会给你了。就好比一个画板，其中A画家先去使用了，那么不好意思，不管你后来再来的其他任何人，都不会得到使用权。不过如果再次传入2d，还是能够获得2d对象，这个只能解释为A画家中途休息，休息完之后依旧拥有该画板的使用权。以至于最后的猜想也没法实现验证。因为我除了传入2d参数，其他任何参数都会直接获得null- 而且这看到的只是interface中的代码，没有具体实现的逻辑代码，一切靠猜测，所以可能会很大的冲突，不过结果肯定是一样的，因为就是通过结果来进行推测的逻辑。如果有人比较了解这方面的东西，希望能够告知以便相互学习 注意点4：这里不叫注意点，应该是知识点 drawImage（r,x,y,w,h）参数： r：代表的是图像源头 x：表示在画布中x坐标轴的偏移量 y：y坐标轴偏移量 w：画出的图片的宽度 h：高度 、结果实例 参照页面img元素画图 这里就丢两张图， 反正该解释的上面已经解释了 不参照页面img元素画图 在前面说过，我们不将图片展示在页面上来将图片画出来，不过我们要遵循的步骤依旧是一样的 只不过第一步找参考图片不是在页面中寻找了，而是在js代码中，也就是我们要手动创建一个img元素dom对象，然后指定其图片 代码： 12345678window.onload = function () &#123; var img = document.createElement("img") img.src="../imgs/0.png" document.getElementById("draw").addEventListener('click', function () &#123; var cv = document.getElementById('canvas1'); var ct = cv.getContext("2d"); ct.drawImage(img, 0, 0, 200, 200); &#125;); 结果图： 以上展示了如何利用canvas画图，其中有理解错误的地方，也就这样了。下面来看一下怎么将这张canvas中的图片保存下来，这个后面会用到 四、canvas补充 上面说到的两个问题，在这里进行补充示例说明结果 问题1：canvas设置为display:none的情况会如何 首先看一下代码： html：直接设置canvas样式为display:none 1234&lt;canvas height="400" width="200" id="canvas1" style="border: 1px solid gray;display:none;"&gt;&lt;/canvas&gt;&lt;br/&gt;&lt;button id="draw"&gt;画图&lt;/button&gt;&lt;button id="show"&gt;展示&lt;/button&gt; 结果可想而知，页面上什么都没有只有两个个按钮 js代码：思路是，点击画图将图片画到canvas中，在点击展示改变canvas的样式为block，看看有没有图片 123456789101112//画图按钮var img = document.createElement("img")img.src="../imgs/0.png"document.getElementById("draw").addEventListener('click', function () &#123; var cv = document.getElementById('canvas1'); var ct = cv.getContext("2d"); ct.drawImage(img, 0, 0, 200, 200);&#125;);//展示按钮document.getElementById("show").addEventListener('click',function () &#123; document.getElementById("canvas1").style.display= 'block';&#125;) 结果： 啊哈，有图片耶！那么我们来看看第二种情况 问题2：canvas设置为长宽都为0的情况会如何 思路同上一个，直接贴代码和效果 1234&lt;canvas height="0" width="0" id="canvas1" style="border: 1px solid gray;"&gt;&lt;/canvas&gt;&lt;br/&gt;&lt;button id="draw"&gt;画图&lt;/button&gt;&lt;button id="show"&gt;展示&lt;/button&gt; 12345678910111213//画图按钮 var img = document.createElement("img") img.src = "../imgs/0.png" document.getElementById("draw").addEventListener('click', function () &#123; var cv = document.getElementById('canvas1'); var ct = cv.getContext("2d"); ct.drawImage(img, 0, 0, 200, 200); &#125;); //展示按钮 document.getElementById("show").addEventListener('click', function () &#123; document.getElementById("canvas1").style.width = '200px'; document.getElementById("canvas1").style.height = '400px'; &#125;) 没有图片唉！ 总结： 我们将canvas设置为display:none，但是该元素还是存在页面中的，并且占有一定的面积，只是因为设置为不显示，所以视觉上并没有占用页面的空间。 之前说过，canvas是画布，画图是将图片画在canvas元素上，那么既然存在，不管别人看不看得到，我们画图的时候没有影响 而将canvas宽高设置为0，那么该元素虽然依旧存在页面中，但是一个没有任何大小的元素，真正的意义是依旧存在页面中吗？谁能将一幅画画在面积为0的画板上呢？ 所以，对于canvas的理解，就是这样，它就是一个容器，就是用来存放画出来的图像的一个容器。 五、canvas图片下载 针对与摄像头拍照，我们需要将”拍”的照片保存下来，其实就是将canvas中画出来的图像保存下来， 然后目前的情况也就是我们只是拥有一个存在于页面有展示效果的视觉图像而已，以及一个保存这个图像的元素 那么我们如何将这个元素中的画面以图片文件形式保存下来呢？ 其实很简单，有以下几步 ## １、获得图片文件形式 文件，其实也是一组数据，我们只要拿到这组数据就能实现文件下载 123var ctx = document.getElementById('canvas1'); //获得图片的base64加密字符串 var imgdata = ctx.toDataURL("image/png", 1.0); 通过ctx.toDataURL方法能够将canvas元素中的图像元素转成文件数据路径 接下来，有了文件数据路径。我们可以通过a标签来进行下载该文件 12345678910111213//设置文件名字，并生成a标签链接文件直接执行鼠标点击事件进行下载var type = 'jpg'var filename = 'canvas画图.' + type;var a = document.createElement('a');//设置a链接元素为文件数据路径，点击时候就能直接下载a.href = imgdata;a.download = filename;//然后生成鼠标点击事件// a.click()var event = document.createEvent('MouseEvents');event.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);//执行a标签元素的鼠标点击事件，就相当于是在页面中用鼠标点击了a链接，实现下载a.dispatchEvent(event); 说明一下：其实从10行开始到结束的代码，效果等同于第九行的a.click()，就是为了能够不实用鼠标点击页面元素而实现a的点击事件 到此，我们就把canvas中的图像保存下来了，有人应该注意到，png格式，对于没有被填充的canvas范围，在图片中是透明背景。 除了png格式，还支持jpg、bmp、gif等格式，视自己的需求来吧 六、摄像头拍照 其实摄像头拍照功能，我们也能够利用canvas画图来实现 按照我们之前说的，利用canvas只要能够将画面元素拿到，就能够将该元素区域中的图像画到canvas中，然后下载 上面已经说了后面的步骤，所以我们要利用摄像头中拍照，那么到目前我们要解决的事情就只有两个了： 1、拿到摄像头中拍摄到的画面展示在页面中 2、将页面中展示摄像头页面的元素获取到，给canvas画下来 打开摄像头先贴代码，然后再解释 12345678910navigator.mediaDevices.getUserMedia(&#123; "video": true &#125;).then(function (stream) &#123; console.log(stream); $this.MediaStreamTrack = typeof stream.stop === 'function' ? stream : stream.getTracks()[1]; $this.video.srcObject = stream; $this.video.play(); &#125;).catch(function (err) &#123; console.log(err); &#125;); 详解navigator Navigator 对象包含有关浏览器的信息 ， 注释：没有应用于 navigator 对象的公开标准，不过所有浏览器都支持该对象 描述：Navigator 对象包含的属性描述了正在使用的浏览器。可以使用这些属性进行平台专用的配置。 虽然这个对象的名称显而易见的是 Netscape 的 Navigator 浏览器，但其他实现了 JavaScript 的浏览器也支持这个对象。 Navigator 对象的实例是唯一的，可以用 Window 对象的 navigator 属性来引用它。 对于这个对象，可以去网上查查，今天我们关注的并不是它 mediaDevices 上面说的Navigator对象很牛逼，牛逼到我们能够获得当前所使用环境的很多信息，包括浏览器，当前系统等等 而mediaDevices，则是一个API接口，该接口提供了访问链接媒体输入的设备，如我们使用的摄像头、照相机和麦克风，以及屏幕共享等。 这些媒体输入设备,都能通过该接口来访问链接以便调用 链接可以去网站上看看详细的文档资料 ​ https://developer.mozilla.org/zh-CN/ 进去后点击左上角技术&gt;&gt;&gt;API/dom 能够查看所有的API文档，然后找到mediaDevices和Navigator自行学习 有了mediaDevices，只是给我们提供了媒体输入设备链接，而我们要使用设备，还需要一个方法，没错，就是代码中的getUserMedia() mediaDevices.getUserMedia() 该方法会使用户给予使用媒体输入的许可 ，媒体输入会产生一个MediaStream，里面包含了请求的媒体类型的轨道 。 MediaStream是一个流，这个流可以包括视频轨道（来自硬件或者虚拟视频源，比如相机、视频采集设备和屏幕共享服务等等 ）、音频轨道（同样来自硬件或虚拟音频源，比如麦克风、A/D转换器等等 ），也可能是其他轨道 这个函数的参数也比较简单，就是一个对象，这个对象就是表示我们要请求使用的媒体 1&#123; audio: true, video: true &#125; 上面这个代码表示没有任何要求，只要使用音频和视频的媒体 1234&#123; audio: true, video: &#123; width: 1280, height: 720 &#125;&#125; 而这上面代码是说，我要使用音频和视频媒体输入设备，但是视频设配我要1280x720的分辨率 等等，这些参数我们可以灵活使用，而这些东西在上面分享的url里面都有，可以自行去看文档学习 说完参数，那么来看一下返回值：Promise 其实这个对象没多大深度，就是表示异步操作最终完成或者失败的对象 也就是说，我们请求使用设备，成功了，这个对象就表示成功了，失败了，就表示失败了 它的本质就是一个绑定了回调函数的对象，而不是将回调函数传入函数内部 所以我们用.then(function(){})来执行请求设备许可后的处理方法 而如果请求失败或者设备不可用。会回调PermissionDeniedError 或者NotFoundError ，我们用链式调用.catch(function(){})来处理异常 注意：有可能这个对象既不返回允许，也不返回拒绝，因为用户不是百分百会选择允许使用或者拒绝使用，也可能用户什么都不选 好了，闲话不多说，简单聊一聊，具体的去看文档资料学习吧 接下来说一下获得使用设备的许可之后，我们怎么做 Promise.then(function(){})回调 刚刚说过，在then绑定一个回调函数，可以用来处理获得许可后的方法，那么我们就来看一下这里的代码 这里，表示我们取得使用权，那么我们就只需要处理反馈给我们的stream(流)就可以了 然后，我们获得视频轨道（后面我们需要关闭摄像头的），当然，在代码中我们为了严谨，还是做了一步判断，就简单来谈一下吧 $this.MediaStreamTrack = typeof stream.stop === ‘function’ ? stream : stream.getTracks()[1]; 这个我们先判断返回的流stream是不是一个函数，如果是的话，那么有可能这个流里面包含的不仅仅是一个视频轨道，所以在这进行了判断，更为严谨。三元表达式就不解释了吧。 处理完stream之后，就非常简单了，我们想要在页面上展示视频，就是使用video，那么通过document获得页面元素video的dom对象video（因为懒得想名字了，就直接var video了。别误会它是什么东西，就是通过id获取的页面元素） $this.video.srcObject = stream; 然后，就给video这个对象的srcObject赋值为当前的stream，完美搞定 这里需要注意一下，有的帖子中写的是video.src = stream，可坑死了 因为之前没写过，所以刚开始就直接赋值的别人的代码，结果没画面，但是摄像头打开了 就是因为属性不是src，而是srcObject 于是乎，就去了上边链接的网站上看了很久文档，才慢慢搞明白怎么回事，然后自己封装成了自己的组件，以备不时之需，嘿嘿嘿 虽说路径已经配好了，不过不觉得还差点什么吗？没错，video没有开始播放啊，不解释了，.play() 拍照 ok，摄像头画面我们有了，那么就该”拍照”了吧，为什么把拍照两个字用引号引起来？还不懂吗？因为压根就不是拍照，而是canvas画图 这一步就非常简单了，照旧，在页面上添加一个 拍照 按钮，然后点击事件里面代码如下： 1$this.context.drawImage($this.video, 0, 0, 200, 400); 一行代码搞定，就是直接将video像之前的img一样，直接放进去就OK了 关闭摄像头 记得关闭摄像头 1$this.MediaStreamTrack.stop(); 问题点画面出不来 别急别急，有可能是浏览器不兼容的问题 那么我们通过Navigator.mediaDevices来请求摄像头，可能因为浏览器问题而出现错误，别急，我们还有另一种办法 12345678910navigator.getMedia(&#123; "video": true &#125;).then(function (stream) &#123; console.log(stream); $this.MediaStreamTrack = stream.getTracks()[1]; $this.video.srcObject = (window.webkitURL).createObjectURL(stream); $this.video.play(); &#125;).catch(function (err) &#123; console.log(err); &#125;); 不过这种就是会返回一个函数 拍照无效果？ 这个不解释了，有这个问题很大部分应该就是画图中出现的那两个问题吧，如果当时你不知道为什么会出现那两种情况，那么当你做到摄像头拍照的时候就有可能会遇到了 好了，这个不解释，但是下面我们来完善一下页面，并且看看为什么会出现之前提出的两个问题 七、完善页面效果完善 嘿嘿，说到这，我要提要求了，我们一般摄像头拍摄，是不是有需要弹出层的？有需要将影像固定在某个区域的，反正肯定不会是在页面最左上角吧？那样丑死了。 ok，那么我们就来看一下吧。最简单的思路就是，将video元素和canvas元素共同放在同一个容器中，这样不管需求想要将影像在哪呈现，只要把这个容器拿过去就OK了，里面什么都不需要动。 123456789&lt;div id="camera"&gt; &lt;div id="contentHolder"&gt; &lt;video id="video" width="640" height="480" autoplay&gt;&lt;/video&gt; &lt;canvas id="canvas" width="640" height="480"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;div id="buttons"&gt; &lt;button id="btn_snap" class="btn btn_blue"&gt;拍照&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; ok，我的页面（老脸很红，这明明是朋友发来的页面）时这个样子滴，一个大的容器id = “camera”，而里面分两块div，一个是contentHolder用来呈现影响video以及拍照后保存画面的vanvas，另一个是存放按钮 我草，为什么会这样 为什么？ 现在能够看到，原来是canvas，当初我们实验的时候没考虑过页面美化的问题吧？那么这个canvas怎么办？ 很简单啦，将canvas设置为none不就行了？ 但是，千万别傻傻地将canvas设置宽高为0，然后再改回来，这样没法画图的，上面的实验也说过了 js完善 ok，如果按照之前设置为none之后，那么后面可能会没有画面，这个没关系，还记的之前的canvas补充里面的实验吗？就那么解决 但是还是有点担心，在将canvas设置为display:block之前，千万别忘记吧video设置为display:none，因为我们的容器只能同时容纳其中一个的大小，是为了美观，同时也是为了造成一种假象，那就是视频和拍照都在同一个容器里面，其实是两个元素（video和canvas）进行切换的 代码如下： 123$this.video.style.display = "none";$this.canvas.style.display = "block";$this.context.drawImage($this.video, 0, 0, 200, 400); 组件 最后就是个人封装的组件，代码就不贴在这了，单独贴到一个文章中吧]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>实录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java详解jvm工作原理和流程]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F15%2Fjava%E8%AF%A6%E8%A7%A3jvm%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！ [TOC] 一、浅说java说起java,人们首先想到的是java编程语言,然而事实上,Java是一种技术,它由四方面组成: java编程语言 java类文件格式 java虚拟机 java应用程序接口(Java API) 其关系如: java平台由Java虚拟机和Java应用程序接口搭建,java语言则是进入这个平台的通道,用Java语言编写并编译的程序可以运行在这个平台上. 这个平台结构: 运行期环境代表着Java平台,开发人员编写Java代码(.java文件),然后将之编译成字节码(.class)文件,在然后字节码被装入内存,一旦字节码进入虚拟机,它就会被解释器解释执行,或者是被即时代码发生器有选择的转换成机器码执行. java程序经过一次编译之后，将java代码编译为字节码也就是class文件，然后在不同的操作系统上依靠不同的java虚拟机进行解释，最后再转换为不同平台的机器码，最终得到执行。这样我们是不是可以推演，如果要在mac系统上运行，是不是只需要安装mac java虚拟机就行了。 JVM在它的生命周期中有一个明确的任务,那就是运行java程序,因此当Java程序员启动的时候,就产生JVM的一个实例;当程序运行结束的时候,该实例也就跟着消失了 在Java平台的结构中,可以看出,Java虚拟机(JVM)处在核心的位置,是程序与底层操作系统和硬件无关的一个关键.下方是移植接口. 移植接口由两部分组成：适配器 和 Java操作系统 其中依赖于平台的部分被称为适配器 JVM通过移植接口在具体的平台和操作系统上实现;在JVM的上方是Java的基本类库和扩展类库以及他们的API,利用Java API编写的应用程序(application)和小程序(java applet)可以在任何Java平台上运行而无需考虑底层平台,就是因为有Java虚拟机(JVM实现了程序与操作系统的分离,从而实现了Java的平台无关性) 二、JVM基本概念和运行过程1.基本概念:1JVM是可运行Java代码的假象计算机（虚拟计算机） JVM包括： 一套字节码指令集 一组寄存器 一个栈 一个垃圾回收 堆 一个存储方法域 JVM是运行在操作系统之上的,它与硬件没有直接的交互 2.运行过程Java源文件 通过 编译器 能够产生相应的 字节码文件(.Class文件) ,而字节码文件又通过 Java虚拟机中的解释器 编译成 特定机器上的机器码 12java源文件 ----&gt; 编译器 ----&gt; 字节码文件字节码文件 ----&gt; JVM ----&gt; 机器码 每一种平台 的 解释器是不同的, 但是实现的 虚拟机 是 相同 的,这也就是Java为什么能够 跨平台 的原因了 当一个 程序从开始运行 这时 虚拟机 就开始 实例化 了, 多个程序 启动就会存在 多个虚拟机实例. 程序 退出或关闭, 则虚拟机 实例消亡 , 12注意:多个虚拟机实例之间数据不能共享 3.三种JVM:1234567- Sun 公司的 HotSpot- BEA 公司的 JRockit- IBM 公司的 J9 JVM在 JDK1.7 及其以前我们所使用的都是 Sun 公司的 HotSpot, 但是由于 Sun公司 和 BEA公司都被 oracle 收购jdk1.8 将采用 Sun 公司的 HotSpot 和 BEA 公司的 JRockit 两个JVM中 精华 形成 jdk1.8的JVM 三、JVM的体系结构 1.Class Loader类加载器负责加载.class文件,class文件在文件开头有特定的文件标示,并且ClassLoader负责class文件的加载等.但是至于它是否可以运行,则由Execution Engine(执行引擎)决定 定位和导入 二进制.class文件 验证 导入类的正确性 为类 分配 初始化 内存 帮助 解析 符号引用 2.Native Interface 本地接口本地接口的作用是 融合不同的编程语言为Java所用, 它的 初衷 是融合 C/C++ , Java诞生的时候C/C++横行的时候,想要立足,必须调用C/C++程序, 于是就在内存中专门开辟了一块区域处理标记为 native的代码. 具体做法: Native Method Stack中登记native 方法,在Execution Engine执行的时候加载native libraies(本地方法库) 不过目前该方法使用的越来越少了,除非是与硬件有关的应用, 如: 通过Java程序驱动打印机,或者Java系统管理生产设备,在企业级应用中已经比较少见 因为现在的 异构领域空间 的通信很发达 ,比如:可以使用 Socket通信, 也可以使用 Web Service等 3.Excution Engine 执行引擎:执行 包在 装载类 的方法中的 指令,也就是 方法 4.Runtime data area 运行数据区:虚拟机内存或者 JVM内存, 从整个 计算机内存中开辟 一块内存 存储 JVM用到的 对象,变量等 运行区数据又分很多小区,分别为：方法区 堆 虚拟机栈 本地方法栈 程序计数器 5.JVM数据运行区详解(栈管运行,堆管存储):1说明: jvm调优主要就是 优化Heap堆和Method Area方法区 方法区 Method Area 方法区是各个线程共享的区域， 所有 字段 和 方法字节码 ,以及一些特殊方法如 构造函数, 接口代码 也在此定义. 简单说,所有 定义的方法的信息 都保存在该区域,属于 共享区间 静态变量 + 常量 + 类信息 + 运行时常量池 存在方法区中 堆 java堆也是线程共享的区域，我们的类的实例就放在这个区域(而指向该实例变量的引用存在栈)， 可以想象你的一个系统会产生很多实例，因此java堆的空间也是最大的。 如果java堆空间不足了，程序会抛出OutOfMemoryError异常。 也是 GC（垃圾回收机制） 主要的 回收区, 一个JVM 实例只存在 一个堆 类内存,堆内存的 大小 是可以 调节 的 虚拟机栈 VM Stack 栈是什么 ：栈也叫 栈内存, 主管Java 程序的运行, 是在 线程创建时 创建, 他的生命期是跟随 线程的生命期, 线程结束 栈内存也就 释放, 对于栈来说 不存在垃圾回收问题, 只要线程已结束该栈就over,生命周期和线程一致, 是 线程私有的 基本类型 的变量和 对象的引用 变量都是在函数的 栈内存中分配 栈存储什么：栈帧中主要保存 3类数据: 本地变量(Local Variables): 输入参数和输出参数以及方法内的变量 栈操作( Operand Stack ): 记录出栈,入栈的操作 栈帧数据( Frame Data ): 包括类文件,方法等等 栈运行原理 栈中的 数据 都是以 栈帧的格式 存在, 栈帧是一个 内存区块, 是一个 数据集, 是一个有关 方法 和运行期 数据 的 数据集 当一个方法A被调用时就产生了一个栈帧F1,并被压入到栈中,A方法有调用了B方法,于是产生栈帧F2也被压入栈,B方法有调用了C方法,于是产生的栈帧F3也被压入栈……依次执行完毕后,先弹出后进……F3,再弹出F2,F1 遵循 先进后出/后进先出 原则 就是说，java栈是每个线程私有的区域，它的生命周期与线程相同，一个线程对应一个java栈，每执行一个方法就会往栈中压入一个元素，这个元素叫“栈帧”，而栈帧中包括了方法中的局部变量、用于存放中间状态值的操作栈，这里面有很多细节。如果java栈空间不足了，程序会抛出StackOverflowError异常，想一想什么情况下会容易产生这个错误，对，递归，递归如果深度很深，就会执行大量的方法，方法越多java栈的占用空间越大。 本地方法栈 Native Method Stack 本地方法栈角色和java栈类似，只不过它是用来表示执行本地方法的，它的具体做法是Native Method Stack中登记native方法，本地方法栈存放的方法调用本地方法接口，在Execution Engine执行时候加载native libraies ，最终调用本地方法库，实现与操作系统、硬件交互的目的。 程序计数器 PC寄存器（有的这么叫，这里提一下），说到这里我们的类已经加载了，实例对象、方法、静态变量都去了自己该去的地方，那么问题来了，程序该怎么执行，哪个方法先执行，哪个方法后执行，这些指令执行的顺序就是PC寄存器在管，它的作用就是控制程序指令的执行顺序 （Register，也是记录，登记，寄存的意思，就是用来管理的） 每个线程都一个 程序计算器, 就是一个 指针, 指向 方法区中的 方法字节码 (下一个将要执行的指令代码),由 执行引擎读取 下一条指令,是一个 非常小 的内存空间,几乎可以 忽略不计 6.堆内存 堆内存分为3部分: 1.新生区 新生区是 类 的 诞生,成长,消亡 的区域. 一个 类 在这里 产生,应用, 最后被 垃圾回收器收集,结束生命 新生区又分为两部分: 伊甸区(Eden space) :所有的类都是在伊甸区被new出来的 幸存者区(Survivor Space) :有两个,0区和1区 当伊甸区的空间用完时,程序有需要创建对象,JVM的垃圾回收器将对伊甸区进行垃圾回收(Minor GC),将伊甸区中的剩余对象移动到幸存0区, 若0取也满了,对该区域进行垃圾回收,然后移动到1区 1区满了移动到养老区(Tenure Generation Space) 养老区满了,这时候将产生Major GC(FullGC),进行养老区的内存清理. 若养老区执行Full GC之后发现依然无法进行对象的保存,会产生OOM异常(OutOfMemoryError,内存溢出) 所以，如果出现java.lang.OutOfMemoryError:Java heap space异常,说明Java虚拟机的堆内存不够 ，原因有二： Java虚拟机的堆内存 设置 不够,可以通过参数 -Xms, -Xmx 调整 (jvm调优方面会说) 代码中创建了 大量大对象,并且长时间 不能被 垃圾收集器 收集(存在被引用) 2.养老区 用于保存从新生区筛选出来的Java对象,一般 池对象 都在这个区域活跃 年老代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在） 内存大小相对会比较大，垃圾回收也相对没有那么频繁（譬如可能几个小时一次） 年老代主要采用压缩的方式来避免内存碎片（将存活对象移动到内存片的一边，也就是内存整理）。 当然，有些垃圾回收器（譬如CMS垃圾回收器）出于效率的原因，可能会不进行压缩。 （这些调优篇细讲） 3.永久区（Permanent Space ） 是一个 常驻内存区域 , 用于存放 JDK自身 所携带的 class,interface的元数据 也就是说它存储的是 运行环境必须 的类信息,被装载进此区域的数据是 不会被 垃圾回收器 回收 掉的 关闭JVM 才会释放 此区域所占用的内存 如果出现java.lang.OutOfMemoryError:PermGen space,说明是Java虚拟机对永久代Perm内存设置不够 ，原因也有两点： 程序启动需要加载大量的第三方jar包. 如:在一个tomcat下部署了太多的应用 大量动态反射生成的类不断被加载,最终导致Perm区被占满 关于永久区的个版本： jdk1.6之前:常量池分配在永久带 jdk1.7:有,但已经逐步”去永久带” jdk1.8之后:无(java.lang.OutOfMemoryError:PermGen space这种错误将不会出现在JDK1.8中) 下面两张图片解释一下 四、 方法区和堆内存的异议:实际而言,方法区和堆一样,是各个线程共享的内存区域,它用于存储虚拟机加载的: 类信息+普通常量+静态常量+编译器变异后的代码 虽然JVM规范将方法区描述为堆的一个逻辑部分,但它却还有一个别名叫做Non-Heap(非堆),目的就是要和堆分开. 对于HotSpot虚拟机,很多开发者习惯将方法区称之为”永久代(Parmanent Gen)”,但严格本质上说两者不同,或者说使用永久代来实现方法区而已,永久代是方法区的一个实现,jdk1.7的版本中,已经将原本放在永久代的字符串常量池移走 常量池(Constant Pool)是方法区的一部分,class文件除了有类的版本,字段,方法,接口等描述信息外,还有一项信息就是常量池,这部分内容将在类加载后进入方法区的运行时常量池中存放. 五、简单补充堆内存调优简介]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的关键字native]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F15%2FJava%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97native%2F</url>
    <content type="text"><![CDATA[【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！ [TOC] 一、简单介绍native关键字 众所周知，java是跨平台的语言，既然跨平台，就要牺牲对底层的控制，所以java对于底层的控制就依赖于其他语言的帮助，而这就是native的作用 native是用作java和其他语言进行协作时用的，也就是native后的方法的实现不是用java写的。既然不是java写的，那肯定看不到它的源码了 native修饰的方法时一个原生态方法,方法对应的实现不是在当前文件,而是在用其他语言(如C或者C++)实现的文件中.并且被编译成了dll文件。 这些方法的实现体在dll文件中，jdk的源码中并不包含，所以是看不到的。对于不同的平台，他们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的 Java语言本身不能对操作系统底层进行访问和操作,但是可通过JNI接口调用其他语言来实现对底层的访问. JNI是Java本机接口(Java Native Interface),是一个本机编程接口,是Java软件开发发工具箱(java Software Development Kit, SDK)的一部分.JNI允许Java代码使用以其他语言编写的代码和代码库. Invocation API(JNI的一部分)可以用来将Java虚拟机(JVM)嵌入到本机应用程序中,从而允许程序员代码内部调用java代码 所以，native的意思就是通知操作系统，我需要这个方法，而你操作系统需要给我实现，我需要使用。而java只需要调用操作系统的方法就行了 java不是完美的，java的运行速度上比传统的C语言慢许多，java无法直接访问到底层操作系统等缺点。当然，解决方法就是上面说的利用native方法来扩展java程序的功能。以下有实践步骤：是之前做笔记的时候尝试的： 二、实践理解1使用java调用C的"sayHello" 1.创建一个java类 123456789101112public class HelloNative &#123; static&#123; System.loadLibrary("HelloNative"); &#125; public static native void sayHello(); @SuppressWarnings("static-access") public static void main(String[] args) &#123; new HelloNative().sayHello(); &#125;&#125; 这里有一个sayHello()方法，native标识该方法的实现在非当前文件，在static静态快中加载的library(HelloNative)中 运行main()之后出现以下情况 12 报错信息时说找不到library(“HelloNative”)的路径，因为我们本地就没有这个文件 2.创建本地方法文件 我们将Java类HelloNative复制出来，（我给放在了D盘根目录，方便） 然后在控制台用javac命令将其编译成字节码文件， 1javac HelloNative.jave 注意：如果命令输入目录与.java文件不在同一目录下，javac命令后的文件名要加路径，如图中d:\HelloNative.java： 然后在用havah编译，获得包含C声明头文件 1javah HelloNative 注意：在这里，我命令目录与文件目录不在同一路径，报错了，这个命令不会区别路径，而是在当前目录下找d:\HelloNative这个名字的文件，把d:\也当成文件名字的一部分 到此，我们一共有三个文件了： 看一下.h文件的内容吧： 123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class HelloNative */#ifndef _Included_HelloNative#define _Included_HelloNative#ifdef __cplusplusextern "C" &#123;#endif/* * Class: HelloNative * Method: sayHello * Signature: ()V */JNIEXPORT void JNICALL Java_HelloNative_sayHello (JNIEnv *, jclass);#ifdef __cplusplus&#125;#endif#endif 创建.c文件： 12 然后运行gcc命令来生成dll共享库 12 命令中的路径是电脑中jdk的安装路径\include 完成后这样就有5个文件了： 然后在用java命令运行一下java代码，就能成功在cmd通过java代码调用c的sayHello方法了 1java HelloNative 说明： 从gcc命令开始，没有图和真相了，那是因为我所有的笔记标签的文章都是回头看以前做的笔记的时候，重新整理记录一下，也有的是之前没有记录到的，整理的时候又重新学一遍；也有之前试验过但是现在环境不允许了。 不过又去了网上看了看帖子，别人的文章有的用的命令不一样，所以具体如何生成dll，尝试一下就行了，只要生成了dll就OK了 三、步骤总结：1总结一下步骤吧： 1 先创建java类，在类中加载需要的library，声明要调用的本地方法 2 使用javac命令编译.java文件，生成字节码文件.class 3 使用javah命令编译成.h文件，生成包含C声明头的文件 4 编写c文件（.c），然后通过gcc命令(或者vs C++环境下cl命令)生成dll 5 然后利用java命令运行Java代码检测是否成功 其实，上面的这个步骤是反着来的，是因为我们从java介入，往底层找的，真正的顺序应该是先写好的c方法生成dll共享库，然后jvm启动之后留在本地方法区中，随着我们写好java代码之后，如果需要用到本地方法，我们就去找相应的方法直接调用就行了(这部分可以简单看一下jvm方面的知识应该比较容易理解，好了，我再看看jvm的笔记)。]]></content>
      <categories>
        <category>java</category>
        <category>关键字</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用JPA创建原生sql(不使用实体类)]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F13%2F%E4%BD%BF%E7%94%A8JPA%E5%88%9B%E5%BB%BA%E5%8E%9F%E7%94%9Fsql-%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BD%93%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[[TOC] 一、描述 JPA很强大，嗯，没错，是很强大！ 它是通过JDK5.0注解或者XML描述对象-关系表的映射关系，并能够将在运行中的实体对象持久化到数据库中。 并且它也是面向对象查询，也就是将实体类与数据库的表映射，即使不会数据库的开发者，只要能看懂java的类，只要能熟练使用jpa，也能很便捷地操作数据库 当然，映射类有其好处，也有弊端。假如说，某个场景下，我需要查询多个表中的数据，并且每个表中只有一到两个字段有用，而整张表的字段又很多，所以有时候就不需要将每个表都完整映射成实体类（不然的话，每次查询就要多查询很多无用的垃圾信息） 今天遇到了这种场景，由于是多表联查，但是只需要其中各一个字段，其余的每个表十几个字段都没用。所以就不需要把每张表的数据都查询出来。而个人对于jpa也不熟练，所以踩了很多坑。下面就此记录： 二、实录（踩坑全过程，实力坑自己！Pain and happiness!想直接看结果，直接拉下去别看这段了） 想法1、返回map，不用实体类 1.dao层（Repository） 就是控制sql语句对数据库进行增删改查。 这里的接口很容易写，只需要继承JpaRepository&lt;entity,object&gt;接口就可以了# 这里需要注意： 1.entity，必须是被管理的类，也就是与数据库进行映射的实体类 所以，就坑在这了，一直报错说Repository什么什么类型必须是被映射管理的，而map却不是。奶奶的，继续想办法 想法2、 创建实体类（不过由于不懂，所以这里没有进行关系映射，就是一个单纯的javaBean，不用仔细说了失败！） ​ 注意： 1.实体类必须与数据库映射才算被映射管理（@Entity注解） 继续尝试 想法3、映射实体类(但是这次也只写了部分字段，自己需要的) ​ 注意： 加上注解标明映射之后，又特么脑残踩了个雷（鄙视自己一秒钟） 对于这个，说一下吧，由于最初没打算映射，并且需要的数据是多个表的，所以类名就自己起的名字。好家伙，提示table_name没有被映射过！我嘞个擦。所以在@Entity注解加上name属性： @Entity(name=”table_name”)最初的时候加错了，写成实体类的名字了，尴尬！这里其实要写表的名字，表明该实体类与那张表映射 与数据库映射的类必须有@Id标明主键(失败一次！吼，不想解释了) 这一点忍无可忍！错误信息说，表中为not null的字段，必须在实体类中映射！也就是实体类中必须有非空字段的属性！！！ 吼吼吼！！我连吼三次可以了吧！那我跟映射全部字段有什么区别呢？还是初衷吗？ 以上一环扣一环之后，想要按照之前想法，实体类，拜拜！ 经过以上绕的弯路，所以就又绕回来了。哼哼！于是乎：老子不用实体类了，也不继承JpaRepository。 想法4、注解托管Repository！ 奈斯！启动刚开始没报错，之前报错貌似跳过去了！突然之间，XXXXXX that could not be found，我真xxxx了，然后去网上找解决方法，要吐血！各种各样的方法，没用！直到我看到一个帖子： 一口老血啊！果断不找了！ （别学我，因为刚刚在找这个帖子的时候，无意间瞥见另一个帖子， 解决方案是：在Application启动类中加上注解：@EnableJpaRepositories(&quot;com.example.repository&quot;)来说明要扫描的类， 虽然之前也在启动类中加过注释，但我也记不清这个到底有没有尝试过了， 感觉很靠谱，这里说一下！失败了也别来找我,也有可能环境不同） 所以！这是一个死循环啊，想要用dao层Repository，OK的，继承JPARepository吧， 等等，我jpa有条件的，entity呢？ 好，给你！ 慢着，我entity不干，先给cp一个数据库表吧，我可不打酱油的！唉，给你cp个表吧， 停！cp随便你，但是我有孩子，得带过去，你去问问entity同不同意！ 尼玛，可怕！！！ 于是，果断放弃了从dao层入手。 三、解决方案 JPA很强大，嗯，没错，是很强大！ 又是这句话，没错，我们如果映射实体类的话，那么目前的情况就感觉无用数据太多，而且累赘，要映射好几张表 但是别怕，jpa不但能面向对象查询，还支持原生sql，能够让我们根据自己的想法来实现 第一种：使用注解@Query(value=”sqlString”) 第二种：entityManager.createNativeQuery(sqlString) 第一种，注解在dao层的方法上，由于我自动装配出问题了，并且及早地放弃了，所以没用， 第二种，上代码 123456Query query = entityManager.createNativeQuery("select * from user where id = ?");query.setParameter(1,"g10001");List list = query.getResultList();Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put("name1",objs.get(0)[0].toString()); map.put("name2",objs.get(0)[1].toString());...... 搞定！list是List&lt;Object[]&gt;类型，里面放的就是一条条数据，而Object[]数组里面是一条数据中的所有字段。 不过又见几个坑，是网上的帖子，代码如下： 123for(Object os : list)&#123; Map map = (Map)os;&#125; 我只求数组（实际上是Object类型的数组）强转Map这波操作！！！！没别的要求 四、诙谐的话语，搞笑而又逗逼！就跟老朋友聊骚，听老朋友牢骚。轻松吗？]]></content>
      <categories>
        <category>java</category>
        <category>框架</category>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>实录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql建表时设置日期默认值及默认修改时间]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F12%2Fmysql%E5%BB%BA%E8%A1%A8%E6%97%B6%E8%AE%BE%E7%BD%AE%E6%97%A5%E6%9C%9F%E9%BB%98%E8%AE%A4%E5%80%BC%E5%8F%8A%E9%BB%98%E8%AE%A4%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[[TOC] #一、简单说明 在做项目的时候，在数据库中基本上都会有关于日期的问题。其中不乏包括日期格式、运算、比较等等。不过这些都很常见了，今天要记录的点，非常简单，不过可能也是很多情况下忽略的东西。 关于这次记录的东西，就是mysql中时间格式的默认值。 很多时候，我们都会对一条数据的相关时间进行记录，比如创建日期，修改日期等等最常见的。而处理这些日期的大部分方法，一般是在后台中获取当前的时间，然后随着数据插入到表中进行保存。 下面，要说的是用mysql自带的方法来实现。（如果觉得没多大意义的话，请止步到此吧，如果想了解一下，请继续） #二、图文示例 这里使用的版本是MySQL 5.6 ###1.mysql的日期和时间类型（这里会展示一下各种时间格式，不想看的跳过） 先来看一下mysql中的日期和时间类型，以及其值的样子 - 在图中我们能够看到，我给所有的日期和时间类型赋值都是年/月/日 时:分:秒.毫秒 - 而最终查询出来的日期格式如列表展示，不同的类型，格式也不同 - 其中year类型只能赋值并保存年份，不过这个字段的赋值有点有意思的地方 ####1.1 year类型 我们先来看看不同的赋值的结果 1.首先赋值0 2.然后1 应该有人应该猜出来了吧,不过我很好奇的是，这个赋值到底范围是多少，于是在这个过程中又遇到了有趣的事情 3.然后： 1到这里就能看出来，mysql日期虽然年份能够不用写完整的4位，但是对于只写两位数，mysql中还是有点范围的70表示1970，而0表示的是2000，很显然，最多就是99表示1999了，然后从1-69表示的是2001-2069，所以mysql非完整的年份默认值范围0-99 4.完整年份最大值 1不要问我怎么来的，我无聊 ###2.正题：设置默认时间 1这个设置是创建该数据的当前时间 1.使用函数now() 1mysql中有函数可以在sql语句中直接使用（废话不解释了），now()都不陌生 1不过支持now()函数的只有datetime和timestamp两种类型，其他三种都不支持 2.current_（cur系列） 123我们可以利用default current_timestamp为timestamp类型的设置默认值不过很无奈的是，mysql中有current_date和current_time等，但是我这个版本却不能用， 3.自动记录修改时间 1在这里能够看到，id为1的这条数据时间变成了执行update时候的时间 1由于前两天接了新项目，所以写了一半就停下来了，今天有点时间，想着就写完它。勉强看，也算给自己做个记录]]></content>
      <categories>
        <category>DB</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>日期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
