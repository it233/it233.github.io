<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浮梦之殇</title>
  
  
  <link href="/it233.github.io/atom.xml" rel="self"/>
  
  <link href="https://it233.github.io/"/>
  <updated>2018-11-16T02:00:52.069Z</updated>
  <id>https://it233.github.io/</id>
  
  <author>
    <name>漠</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java详解jvm工作原理和流程</title>
    <link href="https://it233.github.io/2018/11/15/java%E8%AF%A6%E8%A7%A3jvm%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://it233.github.io/2018/11/15/java详解jvm工作原理和流程/</id>
    <published>2018-11-15T07:39:33.000Z</published>
    <updated>2018-11-16T02:00:52.069Z</updated>
    
    <content type="html"><![CDATA[<p>【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！</p><hr><p>[TOC]</p><h1 id="一、浅说java"><a href="#一、浅说java" class="headerlink" title="一、浅说java"></a>一、浅说java</h1><p>说起java,人们首先想到的是java编程语言,然而事实上,Java是一种技术,它由四方面组成:</p><ul><li>java编程语言</li><li>java类文件格式</li><li>java虚拟机</li><li>java应用程序接口(Java API)</li></ul><p>其关系如:</p><p><img src="/2018/11/15/java详解jvm工作原理和流程/java关系.png" alt=""></p><p>java平台由Java虚拟机和Java应用程序接口搭建,java语言则是进入这个平台的通道,用Java语言编写并编译的程序可以运行在这个平台上.</p><p>这个平台结构:</p><p><img src="/2018/11/15/java详解jvm工作原理和流程/平台结构.png" alt=""></p><p>运行期环境代表着Java平台,开发人员编写Java代码(.java文件),然后将之编译成字节码(.class)文件,在然后字节码被装入内存,一旦字节码进入虚拟机,它就会被解释器解释执行,或者是被即时代码发生器有选择的转换成机器码执行. </p><p>java程序经过一次编译之后，将java代码编译为字节码也就是class文件，然后在不同的操作系统上依靠不同的java虚拟机进行解释，最后再转换为不同平台的机器码，最终得到执行。这样我们是不是可以推演，如果要在mac系统上运行，是不是只需要安装mac java虚拟机就行了。 </p><p>JVM在它的生命周期中有一个明确的任务,那就是运行java程序,因此当Java程序员启动的时候,就产生JVM的一个实例;当程序运行结束的时候,该实例也就跟着消失了 </p><p>在Java平台的结构中,可以看出,Java虚拟机(JVM)处在核心的位置,是程序与底层操作系统和硬件无关的一个关键.下方是移植接口. </p><p>移植接口由两部分组成：适配器 和 Java操作系统</p><p>其中依赖于平台的部分被称为适配器</p><p>JVM通过移植接口在具体的平台和操作系统上实现;在JVM的上方是Java的基本类库和扩展类库以及他们的API,利用Java API编写的应用程序(application)和小程序(java applet)可以在任何Java平台上运行而无需考虑底层平台,就是因为有Java虚拟机(JVM实现了程序与操作系统的分离,从而实现了Java的平台无关性)</p><h1 id="二、JVM基本概念和运行过程"><a href="#二、JVM基本概念和运行过程" class="headerlink" title="二、JVM基本概念和运行过程"></a>二、JVM基本概念和运行过程</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念:"></a>1.基本概念:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JVM是可运行Java代码的假象计算机（虚拟计算机）</span><br></pre></td></tr></table></figure><p>JVM包括：</p><ul><li>一套字节码指令集</li><li>一组寄存器</li><li>一个栈</li><li>一个垃圾回收</li><li>堆</li><li>一个存储方法域</li></ul><p>JVM是运行在操作系统之上的,它与硬件没有直接的交互 </p><h2 id="2-运行过程"><a href="#2-运行过程" class="headerlink" title="2.运行过程"></a>2.运行过程</h2><p>Java源文件 通过 编译器 能够产生相应的 字节码文件(.Class文件) ,而字节码文件又通过 Java虚拟机中的解释器 编译成 特定机器上的机器码</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">java源文件</span>  <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;  <span class="comment">编译器</span>  <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;  <span class="comment">字节码文件</span></span><br><span class="line"><span class="comment">字节码文件</span>  <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">JVM</span>  <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;  <span class="comment">机器码</span></span><br></pre></td></tr></table></figure><p>每一种平台 的 解释器是不同的, 但是实现的 虚拟机 是 相同 的,这也就是Java为什么能够 跨平台 的原因了 </p><p>当一个 程序从开始运行 这时 虚拟机 就开始 实例化 了,  多个程序 启动就会存在 多个虚拟机实例. 程序 退出或关闭, 则虚拟机 实例消亡 ,  </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">注意:</span></span><br><span class="line">多个虚拟机实例之间数据不能共享</span><br></pre></td></tr></table></figure><h2 id="3-三种JVM"><a href="#3-三种JVM" class="headerlink" title="3.三种JVM:"></a>3.三种JVM:</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- Sun 公司的 HotSpot</span><br><span class="line">- BEA 公司的 JRockit</span><br><span class="line">- IBM 公司的 J9 JVM</span><br><span class="line"></span><br><span class="line">在 JDK1.7 及其以前我们所使用的都是 Sun 公司的 HotSpot, 但是由于 Sun公司 和 BEA公司都被 oracle 收购</span><br><span class="line"></span><br><span class="line">jdk1.8 将采用 Sun 公司的<span class="built_in"> HotSpot </span>和 BEA 公司的 JRockit 两个JVM中 精华 形成  jdk1.8的JVM</span><br></pre></td></tr></table></figure><h1 id="三、JVM的体系结构"><a href="#三、JVM的体系结构" class="headerlink" title="三、JVM的体系结构"></a>三、JVM的体系结构</h1><p><img src="/2018/11/15/java详解jvm工作原理和流程/jvm结构图1.png" alt=""></p><p><img src="/2018/11/15/java详解jvm工作原理和流程/jvm结构图2.png" alt=""></p><h2 id="1-Class-Loader类加载器"><a href="#1-Class-Loader类加载器" class="headerlink" title="1.Class Loader类加载器"></a>1.Class Loader类加载器</h2><p>负责加载.class文件,class文件在文件开头有特定的文件标示,并且ClassLoader负责class文件的加载等.但是至于它是否可以运行,则由Execution Engine(执行引擎)决定 </p><ul><li>定位和导入 二进制.class文件</li><li>验证 导入类的正确性</li><li>为类 分配 初始化 内存</li><li>帮助 解析 符号引用</li></ul><h2 id="2-Native-Interface-本地接口"><a href="#2-Native-Interface-本地接口" class="headerlink" title="2.Native Interface 本地接口"></a>2.Native Interface 本地接口</h2><p>本地接口的作用是 融合不同的编程语言为Java所用, 它的 初衷 是融合 C/C++ , Java诞生的时候C/C++横行的时候,想要立足,必须调用C/C++程序, 于是就在内存中专门开辟了一块区域处理标记为 native的代码.</p><p>具体做法: Native Method Stack中登记native 方法,在Execution Engine执行的时候加载native libraies(本地方法库)</p><p>不过目前该方法使用的越来越少了,除非是与硬件有关的应用,</p><p>如:</p><p>通过Java程序驱动打印机,或者Java系统管理生产设备,在企业级应用中已经比较少见</p><p>因为现在的 异构领域空间 的通信很发达 ,比如:可以使用 Socket通信, 也可以使用 Web Service等</p><h2 id="3-Excution-Engine-执行引擎"><a href="#3-Excution-Engine-执行引擎" class="headerlink" title="3.Excution Engine 执行引擎:"></a>3.Excution Engine 执行引擎:</h2><p>执行 包在 装载类 的方法中的 指令,也就是 方法</p><h2 id="4-Runtime-data-area-运行数据区"><a href="#4-Runtime-data-area-运行数据区" class="headerlink" title="4.Runtime data area 运行数据区:"></a>4.Runtime data area 运行数据区:</h2><p>虚拟机内存或者 JVM内存, 从整个 计算机内存中开辟 一块内存 存储 JVM用到的 对象,变量等</p><p>运行区数据又分很多小区,分别为：方法区  堆  虚拟机栈  本地方法栈 程序计数器 </p><h2 id="5-JVM数据运行区详解-栈管运行-堆管存储"><a href="#5-JVM数据运行区详解-栈管运行-堆管存储" class="headerlink" title="5.JVM数据运行区详解(栈管运行,堆管存储):"></a>5.JVM数据运行区详解(栈管运行,堆管存储):</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">说明: jvm调优主要就是 优化Heap堆和<span class="function"><span class="keyword">Method</span> <span class="title">Area</span>方法区</span></span><br></pre></td></tr></table></figure><p><img src="/2018/11/15/java详解jvm工作原理和流程/jvm数据运行区.png" alt=""></p><ul><li><p>方法区  Method Area </p><ul><li>方法区是各个线程共享的区域，</li><li>所有 字段  和 方法字节码 ,以及一些特殊方法如 构造函数, 接口代码 也在此定义.</li><li>简单说,所有 定义的方法的信息 都保存在该区域,属于 共享区间 </li><li>静态变量 + 常量 + 类信息 + 运行时常量池 存在方法区中 </li></ul></li><li><p>堆 </p><ul><li>java堆也是线程共享的区域，我们的类的实例就放在这个区域(而指向该实例变量的引用存在栈)，</li><li>可以想象你的一个系统会产生很多实例，因此java堆的空间也是最大的。</li><li>如果java堆空间不足了，程序会抛出OutOfMemoryError异常。 </li><li>也是 GC（垃圾回收机制） 主要的 回收区,  一个JVM 实例只存在 一个堆 类内存,堆内存的 大小 是可以 调节 的 </li></ul></li><li><p>虚拟机栈  VM Stack  </p><ul><li><p>栈是什么 ：栈也叫 栈内存, 主管Java 程序的运行, 是在  线程创建时 创建, 他的生命期是跟随 线程的生命期, 线程结束 栈内存也就 释放,  对于栈来说 不存在垃圾回收问题, 只要线程已结束该栈就over,生命周期和线程一致, 是 线程私有的 </p></li><li><p>基本类型 的变量和 对象的引用 变量都是在函数的 栈内存中分配 </p></li><li><p>栈存储什么：栈帧中主要保存 3类数据:</p><ul><li>本地变量(Local Variables): 输入参数和输出参数以及方法内的变量</li><li>栈操作( Operand Stack ): 记录出栈,入栈的操作</li><li>栈帧数据( Frame Data ): 包括类文件,方法等等</li></ul></li><li><p>栈运行原理</p><ul><li>栈中的 数据 都是以 栈帧的格式 存在, 栈帧是一个 内存区块, 是一个 数据集, 是一个有关 方法 和运行期 数据 的 数据集</li><li>当一个方法A被调用时就产生了一个栈帧F1,并被压入到栈中,A方法有调用了B方法,于是产生栈帧F2也被压入栈,B方法有调用了C方法,于是产生的栈帧F3也被压入栈……依次执行完毕后,先弹出后进……F3,再弹出F2,F1 </li><li>遵循 先进后出/后进先出 原则  </li></ul></li><li><p>就是说，java栈是每个线程私有的区域，它的生命周期与线程相同，一个线程对应一个java栈，每执行一个方法就会往栈中压入一个元素，这个元素叫“栈帧”，而栈帧中包括了方法中的局部变量、用于存放中间状态值的操作栈，这里面有很多细节。如果java栈空间不足了，程序会抛出StackOverflowError异常，想一想什么情况下会容易产生这个错误，对，递归，递归如果深度很深，就会执行大量的方法，方法越多java栈的占用空间越大。 </p></li></ul></li><li><p>本地方法栈  Native Method Stack </p><ul><li>本地方法栈角色和java栈类似，只不过它是用来表示执行本地方法的，它的具体做法是Native Method Stack中登记native方法，本地方法栈存放的方法调用本地方法接口，在Execution Engine执行时候加载native libraies ，最终调用本地方法库，实现与操作系统、硬件交互的目的。 </li></ul></li><li><p>程序计数器</p><ul><li>PC寄存器（有的这么叫，这里提一下），说到这里我们的类已经加载了，实例对象、方法、静态变量都去了自己该去的地方，那么问题来了，程序该怎么执行，哪个方法先执行，哪个方法后执行，这些指令执行的顺序就是PC寄存器在管，它的作用就是控制程序指令的执行顺序 （Register，也是记录，登记，寄存的意思，就是用来管理的）</li><li>每个线程都一个 程序计算器, 就是一个 指针, 指向  方法区中的 方法字节码 (下一个将要执行的指令代码),由  执行引擎读取  下一条指令,是一个 非常小 的内存空间,几乎可以 忽略不计 </li></ul></li></ul><h2 id="6-堆内存"><a href="#6-堆内存" class="headerlink" title="6.堆内存"></a>6.堆内存</h2><p>  堆内存分为3部分: </p><p>  <img src="/2018/11/15/java详解jvm工作原理和流程/堆内存.png" alt=""></p><p>  1.新生区</p><ul><li>新生区是 类 的 诞生,成长,消亡 的区域.</li><li>一个 类 在这里 产生,应用, 最后被 垃圾回收器收集,结束生命</li><li><p>新生区又分为两部分:</p><ul><li>伊甸区(Eden space) :所有的类都是在伊甸区被new出来的 </li><li>幸存者区(Survivor Space) :有两个,0区和1区 <ul><li>当伊甸区的空间用完时,程序有需要创建对象,JVM的垃圾回收器将对伊甸区进行垃圾回收(Minor GC),将伊甸区中的剩余对象移动到幸存0区, </li><li>若0取也满了,对该区域进行垃圾回收,然后移动到1区 </li><li>1区满了移动到养老区(Tenure Generation Space) </li><li>养老区满了,这时候将产生Major GC(FullGC),进行养老区的内存清理. </li><li>若养老区执行Full GC之后发现依然无法进行对象的保存,会产生OOM异常(OutOfMemoryError,内存溢出) </li><li>所以，如果出现java.lang.OutOfMemoryError:Java heap space异常,说明Java虚拟机的堆内存不够 ，原因有二：<ul><li>Java虚拟机的堆内存 设置 不够,可以通过参数 -Xms,  -Xmx  调整 (jvm调优方面会说)</li><li>代码中创建了 大量大对象,并且长时间 不能被 垃圾收集器 收集(存在被引用) </li></ul></li></ul></li></ul><p>2.养老区</p></li><li><p>用于保存从新生区筛选出来的Java对象,一般 池对象  都在这个区域活跃 </p></li><li>年老代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在） </li><li>内存大小相对会比较大，垃圾回收也相对没有那么频繁（譬如可能几个小时一次） </li><li>年老代主要采用压缩的方式来避免内存碎片（将存活对象移动到内存片的一边，也就是内存整理）。</li><li><p>当然，有些垃圾回收器（譬如CMS垃圾回收器）出于效率的原因，可能会不进行压缩。 （这些调优篇细讲）</p><p>3.永久区（Permanent Space ）</p></li><li><p>是一个 常驻内存区域 , 用于存放 JDK自身 所携带的 class,interface的元数据 </p></li><li>也就是说它存储的是 运行环境必须 的类信息,被装载进此区域的数据是 不会被  垃圾回收器 回收 掉的 </li><li>关闭JVM 才会释放  此区域所占用的内存 </li><li>如果出现java.lang.OutOfMemoryError:PermGen space,说明是Java虚拟机对永久代Perm内存设置不够 ，原因也有两点：<ul><li>程序启动需要加载大量的第三方jar包. 如:在一个tomcat下部署了太多的应用 </li><li>大量动态反射生成的类不断被加载,最终导致Perm区被占满 </li></ul></li><li>关于永久区的个版本：<ul><li>jdk1.6之前:常量池分配在永久带</li><li>jdk1.7:有,但已经逐步”去永久带”</li><li>jdk1.8之后:无(java.lang.OutOfMemoryError:PermGen space这种错误将不会出现在JDK1.8中)</li><li>下面两张图片解释一下</li></ul></li></ul><p><img src="/2018/11/15/java详解jvm工作原理和流程/永久区1.png" alt=""></p><p><img src="/2018/11/15/java详解jvm工作原理和流程/元空间.png" alt=""></p><h1 id="四、-方法区和堆内存的异议"><a href="#四、-方法区和堆内存的异议" class="headerlink" title="四、 方法区和堆内存的异议:"></a>四、 方法区和堆内存的异议:</h1><p>实际而言,方法区和堆一样,是各个线程共享的内存区域,它用于存储虚拟机加载的: </p><p>类信息+普通常量+静态常量+编译器变异后的代码</p><p>虽然JVM规范将方法区描述为堆的一个逻辑部分,但它却还有一个别名叫做Non-Heap(非堆),目的就是要和堆分开.</p><p>对于HotSpot虚拟机,很多开发者习惯将方法区称之为”永久代(Parmanent Gen)”,但严格本质上说两者不同,或者说使用永久代来实现方法区而已,永久代是方法区的一个实现,jdk1.7的版本中,已经将原本放在永久代的字符串常量池移走</p><p>常量池(Constant Pool)是方法区的一部分,class文件除了有类的版本,字段,方法,接口等描述信息外,还有一项信息就是常量池,这部分内容将在类加载后进入方法区的运行时常量池中存放.</p><h1 id="五、简单补充"><a href="#五、简单补充" class="headerlink" title="五、简单补充"></a>五、简单补充</h1><p>堆内存调优简介 </p><p><img src="/2018/11/15/java详解jvm工作原理和流程/堆内存优化简介.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;一、浅说java&quot;&gt;&lt;a href=&quot;#一、浅说java&quot; class=&quot;he
      
    
    </summary>
    
      <category term="java" scheme="https://it233.github.io/categories/java/"/>
    
      <category term="jvm" scheme="https://it233.github.io/categories/java/jvm/"/>
    
    
      <category term="笔记" scheme="https://it233.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java中的关键字native</title>
    <link href="https://it233.github.io/2018/11/15/Java%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97native/"/>
    <id>https://it233.github.io/2018/11/15/Java中的关键字native/</id>
    <published>2018-11-15T02:55:05.000Z</published>
    <updated>2018-11-15T09:31:30.530Z</updated>
    
    <content type="html"><![CDATA[<p>【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！</p><hr><p>[TOC]</p><h1 id="一、简单介绍"><a href="#一、简单介绍" class="headerlink" title="一、简单介绍"></a>一、简单介绍</h1><p>native关键字</p><ul><li><p>众所周知，java是跨平台的语言，既然跨平台，就要牺牲对底层的控制，所以java对于底层的控制就依赖于其他语言的帮助，而这就是native的作用</p></li><li><p>native是用作java和其他语言进行协作时用的，也就是native后的方法的实现不是用java写的。既然不是java写的，那肯定看不到它的源码了</p></li><li><p>native修饰的方法时一个原生态方法,方法对应的实现不是在当前文件,而是在用其他语言(如C或者C++)实现的文件中.并且被编译成了dll文件。</p></li><li>这些方法的实现体在dll文件中，jdk的源码中并不包含，所以是看不到的。对于不同的平台，他们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的</li><li>Java语言本身不能对操作系统底层进行访问和操作,但是可通过JNI接口调用其他语言来实现对底层的访问.</li><li>JNI是Java本机接口(Java Native Interface),是一个本机编程接口,是Java软件开发发工具箱(java Software Development Kit, SDK)的一部分.JNI允许Java代码使用以其他语言编写的代码和代码库.</li><li>Invocation API(JNI的一部分)可以用来将Java虚拟机(JVM)嵌入到本机应用程序中,从而允许程序员代码内部调用java代码</li><li>所以，native的意思就是通知操作系统，我需要这个方法，而你操作系统需要给我实现，我需要使用。而java只需要调用操作系统的方法就行了</li><li>java不是完美的，java的运行速度上比传统的C语言慢许多，java无法直接访问到底层操作系统等缺点。当然，解决方法就是上面说的利用native方法来扩展java程序的功能。以下有实践步骤：是之前做笔记的时候尝试的：</li></ul><h1 id="二、实践理解"><a href="#二、实践理解" class="headerlink" title="二、实践理解"></a>二、实践理解</h1><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用java调用<span class="keyword">C</span>的<span class="string">"sayHello"</span></span><br></pre></td></tr></table></figure><p>1.创建一个java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloNative</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"HelloNative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"static-access"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HelloNative().sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个sayHello()方法，native标识该方法的实现在非当前文件，在static静态快中加载的library(HelloNative)中</p><p>运行main()之后出现以下情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>报错信息时说找不到library(“HelloNative”)的路径，因为我们本地就没有这个文件</p><p>2.创建本地方法文件</p><p>我们将Java类HelloNative复制出来，（我给放在了D盘根目录，方便）</p><p>然后在控制台用javac命令将其编译成字节码文件，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">javac</span> <span class="selector-tag">HelloNative</span><span class="selector-class">.jave</span></span><br></pre></td></tr></table></figure><p>注意：如果命令输入目录与.java文件不在同一目录下，javac命令后的文件名要加路径，如图中d:\HelloNative.java：</p><p><img src="/2018/11/15/Java中的关键字native/Java中的关键字native.assets/cmd01.png" alt=""></p><p>然后在用havah编译，获得包含C声明头文件</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">javah HelloNative</span></span><br></pre></td></tr></table></figure><p>注意：在这里，我命令目录与文件目录不在同一路径，报错了，这个命令不会区别路径，而是在当前目录下找d:\HelloNative这个名字的文件，把d:\也当成文件名字的一部分</p><p>到此，我们一共有三个文件了：</p><p><img src="/2018/11/15/Java中的关键字native/Java中的关键字native.assets/files.png" alt=""></p><p>看一下.h文件的内容吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class HelloNative */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_HelloNative</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_HelloNative</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     HelloNative</span></span><br><span class="line"><span class="comment"> * Method:    sayHello</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_HelloNative_sayHello</span><br><span class="line">  (JNIEnv *, jclass);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>创建.c文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后运行gcc命令来生成dll共享库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>命令中的路径是电脑中jdk的安装路径\include</p><p>完成后这样就有5个文件了：</p><p><img src="/2018/11/15/Java中的关键字native/Java中的关键字native.assets/files5.png" alt=""></p><p>然后在用java命令运行一下java代码，就能成功在cmd通过java代码调用c的sayHello方法了</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">java HelloNative</span></span><br></pre></td></tr></table></figure><p>说明：</p><p>从gcc命令开始，没有图和真相了，那是因为我所有的笔记标签的文章都是回头看以前做的笔记的时候，重新整理记录一下，也有的是之前没有记录到的，整理的时候又重新学一遍；也有之前试验过但是现在环境不允许了。</p><p>不过又去了网上看了看帖子，别人的文章有的用的命令不一样，所以具体如何生成dll，尝试一下就行了，只要生成了dll就OK了</p><h1 id="三、步骤总结："><a href="#三、步骤总结：" class="headerlink" title="三、步骤总结："></a>三、步骤总结：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总结一下步骤吧：</span><br></pre></td></tr></table></figure><p>1 先创建java类，在类中加载需要的library，声明要调用的本地方法</p><p>2  使用javac命令编译.java文件，生成字节码文件.class</p><p>3  使用javah命令编译成.h文件，生成包含C声明头的文件</p><p>4  编写c文件（.c），然后通过gcc命令(或者vs C++环境下cl命令)生成dll</p><p>5  然后利用java命令运行Java代码检测是否成功</p><p>其实，上面的这个步骤是反着来的，是因为我们从java介入，往底层找的，真正的顺序应该是先写好的c方法生成dll共享库，然后jvm启动之后留在本地方法区中，随着我们写好java代码之后，如果需要用到本地方法，我们就去找相应的方法直接调用就行了(这部分可以简单看一下jvm方面的知识应该比较容易理解，好了，我再看看jvm的笔记)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;一、简单介绍&quot;&gt;&lt;a href=&quot;#一、简单介绍&quot; class=&quot;header
      
    
    </summary>
    
      <category term="java" scheme="https://it233.github.io/categories/java/"/>
    
      <category term="关键字" scheme="https://it233.github.io/categories/java/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    
      <category term="笔记" scheme="https://it233.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用JPA创建原生sql(不使用实体类)</title>
    <link href="https://it233.github.io/2018/11/13/%E4%BD%BF%E7%94%A8JPA%E5%88%9B%E5%BB%BA%E5%8E%9F%E7%94%9Fsql-%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BD%93%E7%B1%BB/"/>
    <id>https://it233.github.io/2018/11/13/使用JPA创建原生sql-不使用实体类/</id>
    <published>2018-11-13T05:19:38.000Z</published>
    <updated>2018-11-16T02:25:18.822Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一、描述"><a href="#一、描述" class="headerlink" title="一、描述"></a>一、描述</h1><ul><li><p>JPA很强大，嗯，没错，是很强大！</p><pre><code>它是通过JDK5.0注解或者XML描述对象-关系表的映射关系，并能够将在运行中的实体对象持久化到数据库中。</code></pre></li><li><p>并且它也是面向对象查询，也就是将实体类与数据库的表映射，即使不会数据库的开发者，只要能看懂java的类，只要能熟练使用jpa，也能很便捷地操作数据库</p></li><li><p>当然，映射类有其好处，也有弊端。假如说，某个场景下，我需要查询多个表中的数据，并且每个表中只有一到两个字段有用，而整张表的字段又很多，所以有时候就不需要将每个表都完整映射成实体类（不然的话，每次查询就要多查询很多无用的垃圾信息）</p></li><li><p>今天遇到了这种场景，由于是多表联查，但是只需要其中各一个字段，其余的每个表十几个字段都没用。所以就不需要把每张表的数据都查询出来。而个人对于jpa也不熟练，所以踩了很多坑。下面就此记录：</p></li></ul><h1 id="二、实录"><a href="#二、实录" class="headerlink" title="二、实录"></a>二、实录</h1><pre><code>（踩坑全过程，实力坑自己！Pain and happiness!想直接看结果，直接拉下去别看这段了）</code></pre><h3 id="想法1、"><a href="#想法1、" class="headerlink" title="想法1、"></a>想法1、</h3><p>返回map，不用实体类</p><p>1.dao层（Repository）</p><ul><li>就是控制sql语句对数据库进行增删改查。</li><li><p>这里的接口很容易写，只需要继承JpaRepository&lt;entity,object&gt;接口就可以了<br>#<br>  这里需要注意：<br>  1.entity，必须是被管理的类，也就是与数据库进行映射的实体类</p><p>  所以，就坑在这了，一直报错说Repository什么什么类型必须是被映射管理的，而map却不是。奶奶的，继续想办法</p><h3 id="想法2、"><a href="#想法2、" class="headerlink" title="想法2、"></a>想法2、</h3></li></ul><p>创建实体类（不过由于不懂，所以这里没有进行关系映射，就是一个单纯的javaBean，不用仔细说了失败！）</p><p>​    注意：<br>    1.实体类必须与数据库映射才算被映射管理（@Entity注解）</p><pre><code>继续尝试</code></pre><h3 id="想法3、"><a href="#想法3、" class="headerlink" title="想法3、"></a>想法3、</h3><p>映射实体类(但是这次也只写了部分字段，自己需要的)</p><p>​    注意：</p><ul><li>加上注解标明映射之后，又特么脑残踩了个雷（鄙视自己一秒钟）<ul><li>对于这个，说一下吧，由于最初没打算映射，并且需要的数据是多个表的，所以类名就自己起的名字。好家伙，提示table_name没有被映射过！我嘞个擦。所以在@Entity注解加上name属性：</li><li>@Entity(name=”table_name”)最初的时候加错了，写成实体类的名字了，尴尬！这里其实要写表的名字，表明该实体类与那张表映射</li></ul></li><li>与数据库映射的类必须有@Id标明主键(失败一次！吼，不想解释了)</li><li>这一点忍无可忍！错误信息说，表中为not null的字段，必须在实体类中映射！也就是实体类中必须有非空字段的属性！！！<ul><li>吼吼吼！！我连吼三次可以了吧！那我跟映射全部字段有什么区别呢？还是初衷吗？</li></ul></li><li>以上一环扣一环之后，想要按照之前想法，实体类，拜拜！</li><li>经过以上绕的弯路，所以就又绕回来了。哼哼！于是乎：老子不用实体类了，也不继承JpaRepository。</li></ul><h3 id="想法4、"><a href="#想法4、" class="headerlink" title="想法4、"></a>想法4、</h3><p>注解托管Repository！</p><pre><code>奈斯！启动刚开始没报错，之前报错貌似跳过去了！突然之间，XXXXXX that could not be found，我真xxxx了，然后去网上找解决方法，要吐血！各种各样的方法，没用！直到我看到一个帖子：</code></pre><p><img src="/2018/11/13/使用JPA创建原生sql-不使用实体类/1.png" alt="帖子截图"></p><pre><code>一口老血啊！果断不找了！（别学我，因为刚刚在找这个帖子的时候，无意间瞥见另一个帖子，解决方案是：在Application启动类中加上注解：@EnableJpaRepositories(&quot;com.example.repository&quot;)来说明要扫描的类，虽然之前也在启动类中加过注释，但我也记不清这个到底有没有尝试过了，感觉很靠谱，这里说一下！失败了也别来找我,也有可能环境不同）所以！这是一个死循环啊，想要用dao层Repository，OK的，继承JPARepository吧，等等，我jpa有条件的，entity呢？ 好，给你！慢着，我entity不干，先给cp一个数据库表吧，我可不打酱油的！唉，给你cp个表吧，停！cp随便你，但是我有孩子，得带过去，你去问问entity同不同意！尼玛，可怕！！！于是，果断放弃了从dao层入手。</code></pre><h1 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h1><ul><li><p>JPA很强大，嗯，没错，是很强大！</p><p>  又是这句话，没错，我们如果映射实体类的话，那么目前的情况就感觉无用数据太多，而且累赘，要映射好几张表<br>  但是别怕，jpa不但能面向对象查询，还支持原生sql，能够让我们根据自己的想法来实现</p></li><li><p>第一种：使用注解@Query(value=”sqlString”)</p></li><li><p>第二种：entityManager.createNativeQuery(sqlString)</p><p>  第一种，注解在dao层的方法上，由于我自动装配出问题了，并且及早地放弃了，所以没用，</p><p>  第二种，上代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Query query = entityManager.createNativeQuery(<span class="string">"select * from user where id = ?"</span>);</span><br><span class="line">query.setParameter(<span class="number">1</span>,<span class="string">"g10001"</span>);</span><br><span class="line">List list = query.getResultList();</span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   map.put(<span class="string">"name1"</span>,objs.get(<span class="number">0</span>)[<span class="number">0</span>].toString());</span><br><span class="line">   map.put(<span class="string">"name2"</span>,objs.get(<span class="number">0</span>)[<span class="number">1</span>].toString());......</span><br></pre></td></tr></table></figure><p>搞定！list是List&lt;Object[]&gt;类型，里面放的就是一条条数据，而Object[]数组里面是一条数据中的所有字段。</p><p>不过又见几个坑，是网上的帖子，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object os : list)&#123;</span><br><span class="line">Map map = (Map)os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我只求数组（实际上是Object类型的数组）强转Map这波操作！！！！没别的要求</p><h1 id="四、"><a href="#四、" class="headerlink" title="四、"></a>四、</h1><pre><code>诙谐的话语，搞笑而又逗逼！就跟老朋友聊骚，听老朋友牢骚。轻松吗？</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;一、描述&quot;&gt;&lt;a href=&quot;#一、描述&quot; class=&quot;headerlink&quot; title=&quot;一、描述&quot;&gt;&lt;/a&gt;一、描述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JPA很强大，嗯，没错，是很强大！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;它是通过JDK
      
    
    </summary>
    
      <category term="java" scheme="https://it233.github.io/categories/java/"/>
    
      <category term="框架" scheme="https://it233.github.io/categories/java/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="JPA" scheme="https://it233.github.io/categories/java/%E6%A1%86%E6%9E%B6/JPA/"/>
    
    
      <category term="实录" scheme="https://it233.github.io/tags/%E5%AE%9E%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql建表时设置日期默认值及默认修改时间</title>
    <link href="https://it233.github.io/2018/11/12/mysql%E5%BB%BA%E8%A1%A8%E6%97%B6%E8%AE%BE%E7%BD%AE%E6%97%A5%E6%9C%9F%E9%BB%98%E8%AE%A4%E5%80%BC%E5%8F%8A%E9%BB%98%E8%AE%A4%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4/"/>
    <id>https://it233.github.io/2018/11/12/mysql建表时设置日期默认值及默认修改时间/</id>
    <published>2018-11-12T03:10:06.000Z</published>
    <updated>2018-11-15T09:32:08.975Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>#一、简单说明<br>    在做项目的时候，在数据库中基本上都会有关于日期的问题。其中不乏包括日期格式、运算、比较等等。不过这些都很常见了，今天要记录的点，非常简单，不过可能也是很多情况下忽略的东西。</p><pre><code>关于这次记录的东西，就是mysql中时间格式的默认值。很多时候，我们都会对一条数据的相关时间进行记录，比如创建日期，修改日期等等最常见的。而处理这些日期的大部分方法，一般是在后台中获取当前的时间，然后随着数据插入到表中进行保存。下面，要说的是用mysql自带的方法来实现。（如果觉得没多大意义的话，请止步到此吧，如果想了解一下，请继续）</code></pre><p>#二、图文示例</p><pre><code>这里使用的版本是MySQL 5.6</code></pre><p>###1.mysql的日期和时间类型（这里会展示一下各种时间格式，不想看的跳过）</p><pre><code>先来看一下mysql中的日期和时间类型，以及其值的样子</code></pre><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql日期和时间类型.png" alt="mysql的日期和时间类型"></p><pre><code>- 在图中我们能够看到，我给所有的日期和时间类型赋值都是年/月/日 时:分:秒.毫秒- 而最终查询出来的日期格式如列表展示，不同的类型，格式也不同- 其中year类型只能赋值并保存年份，不过这个字段的赋值有点有意思的地方</code></pre><p>####1.1 year类型</p><pre><code>我们先来看看不同的赋值的结果</code></pre><p>1.首先赋值0</p><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql-year-0.png" alt="mysql-year-0"></p><p>2.然后1</p><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql-year-1.png" alt="mysql-year-0"></p><pre><code>应该有人应该猜出来了吧,不过我很好奇的是，这个赋值到底范围是多少，于是在这个过程中又遇到了有趣的事情</code></pre><p>3.然后：</p><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql建表时设置日期默认值及默认修改时间.assets/mysql-year-69.png" alt="mysql-year-69.png"></p><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql建表时设置日期默认值及默认修改时间.assets/mysql-year-70.png" alt="mysql-year-70.png"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">到这里就能看出来，mysql日期虽然年份能够不用写完整的<span class="number">4</span>位，但是对于只写两位数，mysql中还是有点范围的<span class="number">70</span>表示<span class="number">1970</span>，而<span class="number">0</span>表示的是<span class="number">2000</span>，很显然，最多就是<span class="number">99</span>表示<span class="number">1999</span>了，然后从<span class="number">1</span><span class="number">-69</span>表示的是<span class="number">2001</span><span class="number">-2069</span>，所以mysql非完整的年份默认值范围<span class="number">0</span><span class="number">-99</span></span><br></pre></td></tr></table></figure><p>4.完整年份最大值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不要问我怎么来的，我无聊</span><br></pre></td></tr></table></figure><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql建表时设置日期默认值及默认修改时间.assets/mysql-time-maxvalue.png" alt="mysql-time-maxvalue.png"></p><p>###2.正题：设置默认时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个设置是创建该数据的当前时间</span><br></pre></td></tr></table></figure><p>1.使用函数now()</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql中有函数可以在sql语句中直接使用（废话不解释了），<span class="built_in">now</span>()都不陌生</span><br></pre></td></tr></table></figure><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql建表时设置日期默认值及默认修改时间.assets/mysql-default-now.png" alt="mysql-default-now.png"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不过支持<span class="built_in">now</span>()函数的只有datetime和timestamp两种类型，其他三种都不支持</span><br></pre></td></tr></table></figure><p>2.current_（cur系列）</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们可以利用<span class="keyword">default</span> current_timestamp为timestamp类型的设置默认值</span><br><span class="line"></span><br><span class="line">不过很无奈的是，mysql中有current_date和current_time等，但是我这个版本却不能用，</span><br></pre></td></tr></table></figure><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql建表时设置日期默认值及默认修改时间.assets/mysql-default-cur.png" alt="cur.png"></p><p>3.自动记录修改时间</p><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql建表时设置日期默认值及默认修改时间.assets/default-update-insert.png" alt="default-update-insert.png"></p><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql建表时设置日期默认值及默认修改时间.assets/default-update.png" alt="default-update.png"></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在这里能够看到，<span class="built_in">id</span>为<span class="number">1</span>的这条数据时间变成了执行update时候的时间</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于前两天接了新项目，所以写了一半就停下来了，今天有点时间，想着就写完它。勉强看，也算给自己昨个记录</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;#一、简单说明&lt;br&gt;    在做项目的时候，在数据库中基本上都会有关于日期的问题。其中不乏包括日期格式、运算、比较等等。不过这些都很常见了，今天要记录的点，非常简单，不过可能也是很多情况下忽略的东西。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;关于这次记录的
      
    
    </summary>
    
      <category term="DB" scheme="https://it233.github.io/categories/DB/"/>
    
      <category term="MySQL" scheme="https://it233.github.io/categories/DB/MySQL/"/>
    
    
      <category term="mysql" scheme="https://it233.github.io/tags/mysql/"/>
    
      <category term="日期" scheme="https://it233.github.io/tags/%E6%97%A5%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://it233.github.io/2018/11/09/hello-world/"/>
    <id>https://it233.github.io/2018/11/09/hello-world/</id>
    <published>2018-11-09T09:28:16.849Z</published>
    <updated>2018-11-09T07:30:41.525Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="其他" scheme="https://it233.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://it233.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
</feed>
