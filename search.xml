<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java后台访问接口restTemplate方式GET访问入参数组的问题]]></title>
    <url>%2Fit233.github.io%2F2019%2F01%2F04%2Fjava%E5%90%8E%E5%8F%B0%E8%AE%BF%E9%97%AE%E6%8E%A5%E5%8F%A3restTemplate%E6%96%B9%E5%BC%8FGET%E8%AE%BF%E9%97%AE%E5%85%A5%E5%8F%82%E6%95%B0%E7%BB%84%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、前言（废话）​ 在微服务项目的过程中，我们肯定会去调用其他服务的接口来满足自身业务的需求。 ​ 在这种情况下，有很多种访问别的接口的方式，不过个人用的比较顺手的还是restTemplate。 ​ 其提供的很多方法都很实用，就不一一列举了。接下来要说的是使用restTemplate方式访问GET接口的时候，我们一般的做法就是在url后面拼接参数，不过有个问题就是，如果我们入参是一个数组，并且这个数组还不确定到底有多少个元素，怎么办？ ​ 那么就是这篇文章要说的内容了 二、场景​ 在这里说一下问题的场景： ​ 现有一个接口：根据券编码（code）查询优惠券信息（支持批量查询）接口 ​ 简单说就是这个接口呢，可以入参一个code数组来批量查询券的信息。 ​ 而现在的业务需求是，从接口A中查询出来一组数据，其中能够获得券编码集合，现在要获得这些券的详细信息 三、分析（不以为意的可以跳过）我们知道，现在我们有了券code数组，剩下的就是访问券信息查询的接口，OK，按照我们之前的常用做法，在后面拼接参数。 我们也知道，如果我们的入参是一个数组，那么我们可以以这种形式来传递参数： 1https://****/****/****/**?code=1&amp;code=2&amp;code=3 这样，接口在获得参数的时候就能获得一个code数组 1httpServletRequest.getParameterValues("code");//["1","2","3"] OK，这样没错的，入参没问题，取值也没毛病，现在的问题并不是在于入参和取值，而是如何入参？ 我们现在面临的问题是，这个数组我们并不知道长度，里面元素到底有几个，参数拼接？后面少拼接了肯定不行，那么到底拼接多少个？心里没有底，也没有什么做法能够有保障拼接没问题 现在的做法有以下几种（可能更多）： 循环查询，每次入参一个券code 循环拼接入参，数组中有多少个元素，就拼接多少个code 直接入参数组 这个问题在四来解释 四、问题解析对于第三点提出的三种方式： 一、：循环查询 12345678910111213//设置请求头和主体 HttpHeaders httpHeaders = new HttpHeaders(); httpHeaders.add(MIXING_SERVICE_KEY, MIXING_SERVICE_VALUE); httpHeaders.setContentType(MediaType.APPLICATION_JSON); HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; httpEntity = new HttpEntity(httpHeaders); List&lt;String&gt; couponCodes = new ArrayList&lt;&gt;();//券号集合 for (int i = 0; i &lt; couponCodes.size(); i++) &#123; String url = MIXING_SERVICE_URL + RequestUrlConstant.COUPON + "/detail?code="+couponCodes.get(i);//拼接访问接口路径 ResponseEntity&lt;JSONObject&gt; exchange = restTemplate.exchange(url, HttpMethod.GET, httpEntity, JSONObject.class);//调用访问接口 &#125; OK，这样的做法是及其不推荐使用的，因为我们每有一个编号code，就要调用一次接口，这样是很影响性能的，即使使用第二种方法，也不推荐使用这种方法 二、循环拼接入参 12345678910111213HttpHeaders httpHeaders = new HttpHeaders(); httpHeaders.add(MIXING_SERVICE_KEY, MIXING_SERVICE_VALUE); httpHeaders.setContentType(MediaType.APPLICATION_JSON); HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; httpEntity = new HttpEntity(httpHeaders); List&lt;String&gt; couponCodes = new ArrayList&lt;&gt;(); String url = MIXING_SERVICE_URL + RequestUrlConstant.COUPON + "/detail?"; for (int i = 0; i &lt; couponCodes.size(); i++) &#123; url += "code="+couponCodes.get(i)+"&amp;"; &#125; ResponseEntity&lt;JSONObject&gt; exchange = restTemplate.exchange(url, HttpMethod.GET, httpEntity, JSONObject.class); 这样的话，虽然也有循环，会比第一种方法好很多，起嘛不用每个code都调用一次接口来查询，性能是提升了很多，但是却感觉有点累赘，另外我们调试的时候也会影响我们的视觉，url有可能拼接的特别特别长，参数都有可能找不清楚 三、直接入参数组 这种方式，也许之前用的不多，也是这次的目的 123456789101112HttpHeaders httpHeaders = new HttpHeaders();httpHeaders.add(MIXING_SERVICE_KEY, MIXING_SERVICE_VALUE);httpHeaders.setContentType(MediaType.APPLICATION_JSON);HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; httpEntity = new HttpEntity(httpHeaders);List&lt;String&gt; couponCodes = new ArrayList&lt;&gt;();Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;();paramMap.put("couponCodes", couponCodes);String url = MIXING_SERVICE_URL + RequestUrlConstant.COUPON + "/detail?code=&#123;couponCodes&#125;";ResponseEntity&lt;JSONObject&gt; exchange = restTemplate.exchange(url, HttpMethod.GET, httpEntity, JSONObject.class, paramMap); 这里我们需要将url中的参数使用占位符code={couponCodes} 然后我们调用的resTemplate.exchage()方法使用其重载方法exchange(url, HttpMethod.GET, httpEntity, JSONObject.class, paramMap); 最后一个paramMap就是参数，这样我们就能够将map中的couponCodes与url中的参数code={couponCodes}对应起来 不过这样的做法，其他参数没问题，唯独入参是数组的时候，会出现问题： 数组中的第一个元素和最后一个元素会丢失，具体原因，尚未研究，所以我的做法是，在集合的第一个位置和最后一个位置分别加入一个无关紧要的元素 12345678910couponCodes.add(""); if (prestoreVouchers != null) prestoreVouchers.stream().forEach((item) -&gt; couponCodes.add(JSONObject.parseObject(JSONObject.toJSONString(item)).getString("code"))); if (cashVouchers != null) cashVouchers.stream().forEach(item -&gt; couponCodes.add(JSONObject.parseObject(JSONObject.toJSONString(item)).getString("code"))); if (presentGiftVouchers != null) presentGiftVouchers.stream().forEach(item -&gt; couponCodes.add(JSONObject.parseObject(JSONObject.toJSONString(item)).getString("code"))); if (guideVouchers != null) guideVouchers.stream().forEach(item -&gt; couponCodes.add(JSONObject.parseObject(JSONObject.toJSONString(item)).getString("guideVoucherCode"))); couponCodes.add(""); 在获取code数组之前和最后，分别加入一个空字符串元素就行了]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对象的扩展]]></title>
    <url>%2Fit233.github.io%2F2018%2F12%2F19%2F%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[属性的简洁表示法ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 123456789const foo = 'bar';const baz = &#123;foo&#125;;baz // &#123;foo: "bar"&#125;// 等同于const baz = &#123;foo: foo&#125;;// 等同于const baz = &#123;foo: "bar"&#125;; 上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。 1234567891011function f(x, y) &#123; return &#123;x, y&#125;;&#125;// 等同于function f(x, y) &#123; return &#123;x: x, y: y&#125;;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125; 除了属性简写，方法也可以简写。 12345678910111213const o = &#123; method() &#123; return "Hello!"; &#125;&#125;;// 等同于const o = &#123; method: function() &#123; return "Hello!"; &#125;&#125;; 下面是一个实际的例子。 12345678910111213let birth = '2000/01/01';const Person = &#123; name: '张三', //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log('我的名字是', this.name); &#125;&#125;; 这种写法用于函数的返回值，将会非常方便。 12345678function getPoint() &#123; const x = 1; const y = 10; return &#123;x, y&#125;;&#125;getPoint()// &#123;x:1, y:10&#125; CommonJS 模块输出一组变量，就非常合适使用简洁写法。 123456789101112131415161718192021let ms = &#123;&#125;;function getItem (key) &#123; return key in ms ? ms[key] : null;&#125;function setItem (key, value) &#123; ms[key] = value;&#125;function clear () &#123; ms = &#123;&#125;;&#125;module.exports = &#123; getItem, setItem, clear &#125;;// 等同于module.exports = &#123; getItem: getItem, setItem: setItem, clear: clear&#125;; 属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。 1234567891011121314const cart = &#123; _wheels: 4, get wheels () &#123; return this._wheels; &#125;, set wheels (value) &#123; if (value &lt; this._wheels) &#123; throw new Error('数值太小了！'); &#125; this._wheels = value; &#125;&#125; 注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。 123456789const obj = &#123; class () &#123;&#125;&#125;;// 等同于var obj = &#123; 'class': function() &#123;&#125;&#125;; 上面代码中，class是字符串，所以不会因为它属于关键字，而导致语法解析报错。 如果某个方法的值是一个 Generator 函数，前面需要加上星号。 12345const obj = &#123; * m() &#123; yield 'hello world'; &#125;&#125;; 属性名表达式JavaScript 定义对象的属性，有两种方法。 12345// 方法一obj.foo = true;// 方法二obj['a' + 'bc'] = 123; 上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。 但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。 1234var obj = &#123; foo: true, abc: 123&#125;; ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。 123456let propKey = 'foo';let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;; 下面是另一个例子。 12345678910let lastWord = 'last word';const a = &#123; 'first word': 'hello', [lastWord]: 'world'&#125;;a['first word'] // "hello"a[lastWord] // "world"a['last word'] // "world" 表达式还可以用于定义方法名。 1234567let obj = &#123; ['h' + 'ello']() &#123; return 'hi'; &#125;&#125;;obj.hello() // hi 注意，属性名表达式与简洁表示法，不能同时使用，会报错。 12345678// 报错const foo = 'bar';const bar = 'abc';const baz = &#123; [foo] &#125;;// 正确const foo = 'bar';const baz = &#123; [foo]: 'abc'&#125;; 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。 123456789const keyA = &#123;a: 1&#125;;const keyB = &#123;b: 2&#125;;const myObject = &#123; [keyA]: 'valueA', [keyB]: 'valueB'&#125;;myObject // Object &#123;[object Object]: "valueB"&#125; 上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。 方法的 name 属性函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。 1234567const person = &#123; sayName() &#123; console.log('hello!'); &#125;,&#125;;person.sayName.name // "sayName" 上面代码中，方法的name属性返回函数名（即方法名）。 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。 123456789101112const obj = &#123; get foo() &#123;&#125;, set foo(x) &#123;&#125;&#125;;obj.foo.name// TypeError: Cannot read property 'name' of undefinedconst descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');descriptor.get.name // "get foo"descriptor.set.name // "set foo" 有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。 123456(new Function()).name // "anonymous"var doSomething = function() &#123; // ...&#125;;doSomething.bind().name // "bound doSomething" 如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。 12345678const key1 = Symbol('description');const key2 = Symbol();let obj = &#123; [key1]() &#123;&#125;, [key2]() &#123;&#125;,&#125;;obj[key1].name // "[description]"obj[key2].name // "" 上面代码中，key1对应的 Symbol 值有描述，key2没有。 属性的可枚举性和遍历可枚举性对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 12345678let obj = &#123; foo: 123 &#125;;Object.getOwnPropertyDescriptor(obj, 'foo')// &#123;// value: 123,// writable: true,// enumerable: true,// configurable: true// &#125; 描述对象的enumerable属性，称为”可枚举性“，如果该属性为false，就表示某些操作会忽略当前属性。 目前，有四个操作会忽略enumerable为false的属性。 for...in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 这四个操作之中，前三个是 ES5 就有的，最后一个Object.assign()是 ES6 新增的。其中，只有for...in会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for...in操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的toString方法，以及数组的length属性，就通过“可枚举性”，从而避免被for...in遍历到。 12345Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable// falseObject.getOwnPropertyDescriptor([], 'length').enumerable// false 上面代码中，toString和length属性的enumerable都是false，因此for...in不会遍历到这两个继承自原型的属性。 另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。 12Object.getOwnPropertyDescriptor(class &#123;foo() &#123;&#125;&#125;.prototype, 'foo').enumerable// false 总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for...in循环，而用Object.keys()代替。 属性的遍历ES6 一共有 5 种方法可以遍历对象的属性。 （1）for…in for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 （2）Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 （3）Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 （4）Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。 （5）Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。 首先遍历所有数值键，按照数值升序排列。 其次遍历所有字符串键，按照加入时间升序排列。 最后遍历所有 Symbol 键，按照加入时间升序排列。 12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// ['2', '10', 'b', 'a', Symbol()] 上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 Symbol 属性。 super 关键字我们知道，this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。 12345678910111213const proto = &#123; foo: 'hello'&#125;;const obj = &#123; foo: 'world', find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find() // "hello" 上面代码中，对象obj.find()方法之中，通过super.foo引用了原型对象proto的foo属性。 注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。 12345678910111213141516// 报错const obj = &#123; foo: super.foo&#125;// 报错const obj = &#123; foo: () =&gt; super.foo&#125;// 报错const obj = &#123; foo: function () &#123; return super.foo &#125;&#125; 上面三种super的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。 JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。 1234567891011121314151617const proto = &#123; x: 'hello', foo() &#123; console.log(this.x); &#125;,&#125;;const obj = &#123; x: 'world', foo() &#123; super.foo(); &#125;&#125;Object.setPrototypeOf(obj, proto);obj.foo() // "world" 上面代码中，super.foo指向原型对象proto的foo方法，但是绑定的this却还是当前对象obj，因此输出的就是world。 对象的扩展运算符《数组的扩展》一章中，已经介绍过扩展运算符（...）。 123const [a, ...b] = [1, 2, 3];a // 1b // [2, 3] ES2018 将这个运算符引入了对象。 解构赋值对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。 1234let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125; 上面代码中，变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。 由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。 12let &#123; x, y, ...z &#125; = null; // 运行时错误let &#123; x, y, ...z &#125; = undefined; // 运行时错误 解构赋值必须是最后一个参数，否则会报错。 12let &#123; ...x, y, z &#125; = obj; // 句法错误let &#123; x, ...y, ...z &#125; = obj; // 句法错误 上面代码中，解构赋值不是最后一个参数，所以会报错。 注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。 1234let obj = &#123; a: &#123; b: 1 &#125; &#125;;let &#123; ...x &#125; = obj;obj.a.b = 2;x.a.b // 2 上面代码中，x是解构赋值所在的对象，拷贝了对象obj的a属性。a属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。 另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。 123456let o1 = &#123; a: 1 &#125;;let o2 = &#123; b: 2 &#125;;o2.__proto__ = o1;let &#123; ...o3 &#125; = o2;o3 // &#123; b: 2 &#125;o3.a // undefined 上面代码中，对象o3复制了o2，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。 下面是另一个例子。 12345678const o = Object.create(&#123; x: 1, y: 2 &#125;);o.z = 3;let &#123; x, ...newObj &#125; = o;let &#123; y, z &#125; = newObj;x // 1y // undefinedz // 3 上面代码中，变量x是单纯的解构赋值，所以可以读取对象o继承的属性；变量y和z是扩展运算符的解构赋值，只能读取对象o自身的属性，所以变量z可以赋值成功，变量y取不到值。ES6 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式，所以上面代码引入了中间变量newObj，如果写成下面这样会报错。 12let &#123; x, ...&#123; y, z &#125; &#125; = o;// SyntaxError: ... must be followed by an identifier in declaration contexts 解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。 12345678function baseFunction(&#123; a, b &#125;) &#123; // ...&#125;function wrapperFunction(&#123; x, y, ...restConfig &#125;) &#123; // 使用 x 和 y 参数进行操作 // 其余参数传给原始函数 return baseFunction(restConfig);&#125; 上面代码中，原始函数baseFunction接受a和b作为参数，函数wrapperFunction在baseFunction的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。 扩展运算符对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。 123let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125; 由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。 123let foo = &#123; ...['a', 'b', 'c'] &#125;;foo// &#123;0: "a", 1: "b", 2: "c"&#125; 对象的扩展运算符等同于使用Object.assign()方法。 123let aClone = &#123; ...a &#125;;// 等同于let aClone = Object.assign(&#123;&#125;, a); 上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。 1234567891011121314151617// 写法一const clone1 = &#123; __proto__: Object.getPrototypeOf(obj), ...obj&#125;;// 写法二const clone2 = Object.assign( Object.create(Object.getPrototypeOf(obj)), obj);// 写法三const clone3 = Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)) 上面代码中，写法一的__proto__属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。 扩展运算符可以用于合并两个对象。 123let ab = &#123; ...a, ...b &#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b); 如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。 1234567let aWithOverrides = &#123; ...a, x: 1, y: 2 &#125;;// 等同于let aWithOverrides = &#123; ...a, ...&#123; x: 1, y: 2 &#125; &#125;;// 等同于let x = 1, y = 2, aWithOverrides = &#123; ...a, x, y &#125;;// 等同于let aWithOverrides = Object.assign(&#123;&#125;, a, &#123; x: 1, y: 2 &#125;); 上面代码中，a对象的x属性和y属性，拷贝到新对象后会被覆盖掉。 这用来修改现有对象部分的属性就很方便了。 1234let newVersion = &#123; ...previousVersion, name: 'New Name' // Override the name property&#125;; 上面代码中，newVersion对象自定义了name属性，其他属性全部复制自previousVersion对象。 如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。 12345let aWithDefaults = &#123; x: 1, y: 2, ...a &#125;;// 等同于let aWithDefaults = Object.assign(&#123;&#125;, &#123; x: 1, y: 2 &#125;, a);// 等同于let aWithDefaults = Object.assign(&#123; x: 1, y: 2 &#125;, a); 与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。 1234const obj = &#123; ...(x &gt; 1 ? &#123;a: 1&#125; : &#123;&#125;), b: 2,&#125;; 如果扩展运算符后面是一个空对象，则没有任何效果。 12&#123;...&#123;&#125;, a: 1&#125;// &#123; a: 1 &#125; 如果扩展运算符的参数是null或undefined，这两个值会被忽略，不会报错。 1let emptyObject = &#123; ...null, ...undefined &#125;; // 不报错 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。 1234567891011121314151617// 并不会抛出错误，因为 x 属性只是被定义，但没执行let aWithXGetter = &#123; ...a, get x() &#123; throw new Error('not throw yet'); &#125;&#125;;// 会抛出错误，因为 x 属性被执行了let runtimeError = &#123; ...a, ...&#123; get x() &#123; throw new Error('throw now'); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>实录</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的扩展]]></title>
    <url>%2Fit233.github.io%2F2018%2F12%2F18%2F%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[扩展运算符含义扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12345678console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll('div')]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 该运算符主要用于函数调用。 12345678910function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;const numbers = [4, 38];add(...numbers) // 42 上面代码中，array.push(...items)和add(...numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。 扩展运算符与正常的函数参数可以结合使用，非常灵活。 123function f(v, w, x, y, z) &#123; &#125;const args = [0, 1];f(-1, ...args, 2, ...[3]); 扩展运算符后面还可以放置表达式。 1234const arr = [ ...(x &gt; 0 ? ['a'] : []), 'b',]; 如果扩展运算符后面是一个空数组，则不产生任何效果。 12[...[], 1]// [1] 注意，扩展运算符如果放在括号中，JavaScript 引擎就会认为这是函数调用，否则就会报错。 12345(...[1,2])// Uncaught SyntaxError: Unexpected numberconsole.log((...[1,2]))// Uncaught SyntaxError: Unexpected number 上面两种情况都会报错，因为扩展运算符所在的括号不是函数调用，而console.log(...[1, 2])就不会报错，因为这时是函数调用。 实录代码： 简单使用扩展运算符： 1234567891011function f(a,b,c,d,e,f)&#123; console.log(a) console.log(b) console.log(c) console.log(d) console.log(e) console.log(f)&#125;let nums = [1,5,34,8,3,44]f(...nums) 输出结果： 12345615348344 这里简单使用，数组元素个数与函数参数个数一致，能顺利将数组中的元素序列化成函数的入参，并正确取到值 与入参混和使用 1234567891011function f(a,b,c,d,e,f)&#123; console.log(a) console.log(b) console.log(c) console.log(d) console.log(e) console.log(f)&#125;let nums = [1,5,34,8,3,44]f(2, ...nums) 输出结果： 1234562153483 这里是在数组前面多加了一个入参，这样函数的第一个参数毋庸置疑就是2，而后面剩余的参数，依照顺序与数组中的元素进行匹配，取相应的值 与入参混和使用2 1234567891011function f(a,b,c,d,e,f)&#123; console.log(a) console.log(b) console.log(c) console.log(d) console.log(e) console.log(f)&#125;let nums = [1,5,34,8]f(...nums,100) 输出结果： 12345615348100undefined 这里我将数组中的元素删掉了两个，从上一个示例中能够看出，如果前面元素已经将函数参数全部匹配，之后的参数将无效。所以能够看出，如果前面数组之中的元素个数少于函数的入参个数，那么后面的参数是能够取到的，否则，之后的入参将不会有效果 数组为空 1234567891011function f(a,b,c,d,e,f)&#123; console.log(a) console.log(b) console.log(c) console.log(d) console.log(e) console.log(f)&#125;let nums = []f(...nums,100) 输出结果： 123456100undefinedundefinedundefinedundefinedundefined 按照之前的说法，函数调用之后，使用扩展运算符将数组入参，将会依照顺序进行匹配，那么如果数组为空怎么办？那自然是匹配不到了，也就等于是没有入参，所以说空数组是无效的 替代函数的 apply 方法由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。 12345678910111213// ES5 的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f(x, y, z) &#123; // ...&#125;let args = [0, 1, 2];f(...args); 下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。 12345678// ES5 的写法Math.max.apply(null, [14, 3, 77])// ES6 的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77); 上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。 另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。 123456789// ES5的 写法var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];Array.prototype.push.apply(arr1, arr2);// ES6 的写法let arr1 = [0, 1, 2];let arr2 = [3, 4, 5];arr1.push(...arr2); 上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。 下面是另外一个例子。 1234// ES5new (Date.bind.apply(Date, [null, 2015, 1, 1]))// ES6new Date(...[2015, 1, 1]); 扩展运算符的应用（1）复制数组 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。 12345const a1 = [1, 2];const a2 = a1;a2[0] = 2;a1 // [2, 2] 上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。 ES5 只能用变通方法来复制数组。 12345const a1 = [1, 2];const a2 = a1.concat();a2[0] = 2;a1 // [1, 2] 上面代码中，a1会返回原数组的克隆，再修改a2就不会对a1产生影响。 扩展运算符提供了复制数组的简便写法。 12345const a1 = [1, 2];// 写法一const a2 = [...a1];// 写法二const [...a2] = a1; 上面的两种写法，a2都是a1的克隆。 （2）合并数组 扩展运算符提供了数组合并的新写法。 1234567891011const arr1 = ['a', 'b'];const arr2 = ['c'];const arr3 = ['d', 'e'];// ES5 的合并数组arr1.concat(arr2, arr3);// [ 'a', 'b', 'c', 'd', 'e' ]// ES6 的合并数组[...arr1, ...arr2, ...arr3]// [ 'a', 'b', 'c', 'd', 'e' ] 不过，这两种方法都是浅拷贝，使用的时候需要注意。 12345678const a1 = [&#123; foo: 1 &#125;];const a2 = [&#123; bar: 2 &#125;];const a3 = a1.concat(a2);const a4 = [...a1, ...a2];a3[0] === a1[0] // truea4[0] === a1[0] // true 上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了原数组的成员，会同步反映到新数组。 （3）与解构赋值结合 扩展运算符可以与解构赋值结合起来，用于生成数组。 1234// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = list 下面是另外一些例子。 1234567891011const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = ["foo"];first // "foo"rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 12345const [...butLast, last] = [1, 2, 3, 4, 5];// 报错const [first, ...middle, last] = [1, 2, 3, 4, 5];// 报错 （4）字符串 扩展运算符还可以将字符串转为真正的数组。 12[...'hello']// [ "h", "e", "l", "l", "o" ] 上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。 12'x\uD83D\uDE80y'.length // 4[...'x\uD83D\uDE80y'].length // 3 上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。 12345function length(str) &#123; return [...str].length;&#125;length('x\uD83D\uDE80y') // 3 凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。 1234567let str = 'x\uD83D\uDE80y';str.split('').reverse().join('')// 'y\uDE80\uD83Dx'[...str].reverse().join('')// 'y\uD83D\uDE80x' 上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。 （5）实现了 Iterator 接口的对象 任何 Iterator 接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。 12let nodeList = document.querySelectorAll('div');let array = [...nodeList]; 上面代码中，querySelectorAll方法返回的是一个NodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。 对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。 123456789let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// TypeError: Cannot spread non-iterable object.let arr = [...arrayLike]; 上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。 （6）Map 和 Set 结构，Generator 函数 扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。 1234567let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);let arr = [...map.keys()]; // [1, 2, 3] Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 1234567const go = function*()&#123; yield 1; yield 2; yield 3;&#125;;[...go()] // [1, 2, 3] 上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。 如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。 12const obj = &#123;a: 1, b: 2&#125;;let arr = [...obj]; // TypeError: Cannot spread non-iterable object Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。 下面是一个类似数组的对象，Array.from将它转为真正的数组。 123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 1234567891011// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).filter(p =&gt; &#123; return p.textContent.length &gt; 100;&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; 上面代码中，querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用filter方法。 只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。 12345Array.from('hello')// ['h', 'e', 'l', 'l', 'o']let namesSet = new Set(['a', 'b'])Array.from(namesSet) // ['a', 'b'] 上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被Array.from转为真正的数组。 如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。 12Array.from([1, 2, 3])// [1, 2, 3] 值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。 1234567// arguments对象function foo() &#123; const args = [...arguments];&#125;// NodeList对象[...document.querySelectorAll('div')] 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 12Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] 上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。 123const toArray = (() =&gt; Array.from ? Array.from : obj =&gt; [].slice.call(obj))(); Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] 下面的例子是取出一组 DOM 节点的文本内容。 1234567let spans = document.querySelectorAll('span.name');// map()let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);// Array.from()let names2 = Array.from(spans, s =&gt; s.textContent) 下面的例子将数组中布尔值为false的成员转为0。 12Array.from([1, , 2, , 3], (n) =&gt; n || 0)// [1, 0, 2, 0, 3] 另一个例子是返回各种数据的类型。 12345function typesOf () &#123; return Array.from(arguments, value =&gt; typeof value)&#125;typesOf(null, [], NaN)// ['object', 'object', 'number'] 如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。 Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。 12Array.from(&#123; length: 2 &#125;, () =&gt; 'jack')// ['jack', 'jack'] 上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。 Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。 123function countSymbols(string) &#123; return Array.from(string).length;&#125; Array.of()Array.of方法用于将一组值，转换为数组。 123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] 上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。 Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。 1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。 Array.of方法可以用下面的代码模拟实现。 123function ArrayOf()&#123; return [].slice.call(arguments);&#125; 数组实例的 copyWithin()数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 1Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 这三个参数都应该是数值，如果不是，会自动转为数值。 12[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] 上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。 下面是更多例子。 123456789101112131415161718192021// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将3号位复制到0号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125;// 将2号位到数组结束，复制到0号位let i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署 TypedArray 的 copyWithin 方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 数组实例的 find() 和 findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 12[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5 上面代码找出数组中第一个小于 0 的成员。 123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 12345function f(v)&#123; return v &gt; this.age;&#125;let person = &#123;name: 'John', age: 20&#125;;[10, 12, 26, 15].find(f, person); // 26 上面的代码中，find函数接收了第二个参数person对象，回调函数中的this对象指向person对象。 另外，这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。 12345[NaN].indexOf(NaN)// -1[NaN].findIndex(y =&gt; Object.is(NaN, y))// 0 上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。 数组实例的 fill()fill方法使用给定值，填充一个数组。 12345['a', 'b', 'c'].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] 上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。 fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 12['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] 上面代码表示，fill方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。 123456789let arr = new Array(3).fill(&#123;name: "Mike"&#125;);arr[0].name = "Ben";arr// [&#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;]let arr = new Array(3).fill([]);arr[0].push(5);arr// [[5], [5], [5]] 数组实例的 entries()，keys() 和 values()ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b" 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。 12345let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value); // [0, 'a']console.log(entries.next().value); // [1, 'b']console.log(entries.next().value); // [2, 'c'] 数组实例的 includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。 123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。 12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。 123if (arr.indexOf(el) !== -1) &#123; // ...&#125; indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。 12[NaN].indexOf(NaN)// -1 includes使用的是不一样的判断算法，就没有这个问题。 12[NaN].includes(NaN)// true 下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。 123456const contains = (() =&gt; Array.prototype.includes ? (arr, value) =&gt; arr.includes(value) : (arr, value) =&gt; arr.some(el =&gt; el === value))();contains(['foo', 'bar'], 'baz'); // =&gt; false 另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。 Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。 Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。 数组实例的 flat()，flatMap()数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。 12[1, 2, [3, 4]].flat()// [1, 2, 3, 4] 上面代码中，原数组的成员里面有一个数组，flat()方法将子数组的成员取出来，添加在原来的位置。 flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。 12345[1, 2, [3, [4, 5]]].flat()// [1, 2, 3, [4, 5]][1, 2, [3, [4, 5]]].flat(2)// [1, 2, 3, 4, 5] 上面代码中，flat()的参数为2，表示要“拉平”两层的嵌套数组。 如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。 12[1, [2, [3]]].flat(Infinity)// [1, 2, 3] 如果原数组有空位，flat()方法会跳过空位。 12[1, 2, , 4, 5].flat()// [1, 2, 4, 5] flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。 123// 相当于 [[2, 4], [3, 6], [4, 8]].flat()[2, 3, 4].flatMap((x) =&gt; [x, x * 2])// [2, 4, 3, 6, 4, 8] flatMap()只能展开一层数组。 123// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()[1, 2, 3, 4].flatMap(x =&gt; [[x * 2]])// [[2], [4], [6], [8]] 上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此flatMap()返回的还是一个嵌套数组。 flatMap()方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。 123arr.flatMap(function callback(currentValue[, index[, array]]) &#123; // ...&#125;[, thisArg]) flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this。 数组的空位数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。 1Array(3) // [, , ,] 上面代码中，Array(3)返回一个具有 3 个空位的数组。 注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。 120 in [undefined, undefined, undefined] // true0 in [, , ,] // false 上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。 ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。 forEach(), filter(), reduce(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 1234567891011121314151617181920212223// forEach方法[,'a'].forEach((x,i) =&gt; console.log(i)); // 1// filter方法['a',,'b'].filter(x =&gt; true) // ['a','b']// every方法[,'a'].every(x =&gt; x==='a') // true// reduce方法[1,,2].reduce((x,y) =&gt; x+y) // 3// some方法[,'a'].some(x =&gt; x !== 'a') // false// map方法[,'a'].map(x =&gt; 1) // [,1]// join方法[,'a',undefined,null].join('#') // "#a##"// toString方法[,'a',undefined,null].toString() // ",a,," ES6 则是明确将空位转为undefined。 Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。 12Array.from(['a',,'b'])// [ "a", undefined, "b" ] 扩展运算符（...）也会将空位转为undefined。 12[...['a',,'b']]// [ "a", undefined, "b" ] copyWithin()会连空位一起拷贝。 1[,'a','b',,].copyWithin(2,0) // [,"a",,"a"] fill()会将空位视为正常的数组位置。 1new Array(3).fill('a') // ["a","a","a"] for...of循环也会遍历空位。 123456let arr = [, ,];for (let i of arr) &#123; console.log(1);&#125;// 1// 1 上面代码中，数组arr有两个空位，for...of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。 entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。 1234567891011121314// entries()[...[,'a'].entries()] // [[0,undefined], [1,"a"]]// keys()[...[,'a'].keys()] // [0,1]// values()[...[,'a'].values()] // [undefined,"a"]// find()[,'a'].find(x =&gt; true) // undefined// findIndex()[,'a'].findIndex(x =&gt; true) // 0 由于空位的处理规则非常不统一，所以建议避免出现空位。]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>实录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于js浮点计算解析实录]]></title>
    <url>%2Fit233.github.io%2F2018%2F12%2F17%2F%E5%85%B3%E4%BA%8Ejs%E6%B5%AE%E7%82%B9%E8%AE%A1%E7%AE%97%E8%A7%A3%E6%9E%90%E5%AE%9E%E5%BD%95%2F</url>
    <content type="text"><![CDATA[直奔话题： 这次记录的是关于浮点（小数）计算，而做前端的人都会遇到，两个小数直接进行运算可能会出现这样或那样的精确度的问题，也很苦恼，这里属于个人兴趣，实录研究了一下，仅此将整个研究过程记录下来 我们就以最简单的为例，来进行展示：0.1+0.2=？？？ 1console.log(0.1+0.2) //0.30000000000000004 结果不是0.3，而是约等于0.3的值，为什么会这样呢？ 在网上查了很多资料，我们应该知道，数值类型在计算机中的保存形式是二进制 于是就研究了一下关于二进制的相关信息 好了，由于研究的时候用了很多时间才搞明白原因，所以时间不多，废话不多说，直接展示 首先我们来看一下0.1和0.2以及0.3的二进制 123console.log(0.1.toString(2)) //0.0001100110011001100110011001100110011001100110011001101console.log(0.2.toString(2)) //0.001100110011001100110011001100110011001100110011001101console.log(0.3.toString(2)) //0.010011001100110011001100110011001100110011001100110011 哇，好长，而且有没有发现，0.1的二进制和0.2的二进制长度不一样，少了一位？ 好吧，先解释一下： 0.1的二进制就是：0.000 1100 1100 1100 1100 ….（后面是无限循环的） 0.2的二进制就是：0.001 1001 1001 1001 1001 ….（后面是无限循环的） 这就造成了一种后果：无限循环的数字怎么能完全地表示出来？答案肯定是不可能的嘛，就算我们能够跟数学中一样，用循环符号来表示无限循环小数，但是我们做运算的时候怎么办？还不是要≈（没错，约等于） 那么我们约等于的时候也要知道要在哪一位截断，别急，IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持 53 位二进制位 为了验证一下，我们来看看0.1+0.2计算之后的值转换为二进制是多少位吧 1console.log((0.1+0.2).toString(2).length) //54 是54位，为什么？因为我们转为了string，连小数点(.)也算进去了，所以二进制数字还是53位，好了，这个不纠结，想弄明白可以去找找小数在计算机中的存储形式看看吧，我也没看过呢 这样的话，我们就把0.1和0.2各自的二进制截取一下： //0.000 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1|101 //0.001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1|01 上面是我标记的要截取的位置，用“|”符号隔开，后面的就是要舍弃的 我们都知道，约等于一般都是四舍五入，那么二进制怎么四舍五入呢？很简单，十进制五入，因为五是十的一般，那么二进制的一般就是1，所以是1就进一位，所以结果就是 //0.000 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1101 0 //0.001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1 计算一下结果： 就跟十进制一样相加，只不过是满二进一 //0.010 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 1 这个结果转换一下成十进制： 其他的可以自行计算，按照这个方法实际体验一下]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>实录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数的扩展]]></title>
    <url>%2Fit233.github.io%2F2018%2F12%2F17%2F%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[函数参数的默认值基本用法ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 12345678function log(x, y) &#123; y = y || 'World'; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello World 上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值。 为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。 123if (typeof y === 'undefined') &#123; y = 'World';&#125; ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 1234567function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。下面是另一个例子。 1234567function Point(x = 0, y = 0) &#123; this.x = x; this.y = y;&#125;const p = new Point();p // &#123; x: 0, y: 0 &#125; 除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。 参数变量是默认声明的，所以不能用let或const再次声明。 1234function foo(x = 5) &#123; let x = 1; // error const x = 2; // error&#125; 上面代码中，参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。 使用参数默认值时，函数不能有同名参数。 12345678910// 不报错function foo(x, x, y) &#123; // ...&#125;// 报错function foo(x, x, y = 1) &#123; // ...&#125;// SyntaxError: Duplicate parameter name not allowed in this context 另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。 123456789let x = 99;function foo(p = x + 1) &#123; console.log(p);&#125;foo() // 100x = 100;foo() // 101 上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。 与解构赋值默认值结合使用参数默认值可以与解构赋值的默认值，结合起来使用。 12345678function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined 5foo(&#123;x: 1&#125;) // 1 5foo(&#123;x: 1, y: 2&#125;) // 1 2foo() // TypeError: Cannot read property 'x' of undefined 上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。 12345function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123; console.log(x, y);&#125;foo() // undefined 5 上面代码指定，如果没有提供参数，函数foo的参数默认为一个空对象。 下面是另一个解构赋值默认值的例子。 123456789function fetch(url, &#123; body = '', method = 'GET', headers = &#123;&#125; &#125;) &#123; console.log(method);&#125;fetch('http://example.com', &#123;&#125;)// "GET"fetch('http://example.com')// 报错 上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。 123456function fetch(url, &#123; body = '', method = 'GET', headers = &#123;&#125; &#125; = &#123;&#125;) &#123; console.log(method);&#125;fetch('http://example.com')// "GET" 上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。 作为练习，请问下面两种写法有什么差别？ 123456789// 写法一function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;// 写法二function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125; 上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。 123456789101112131415161718// 函数没有参数的情况m1() // [0, 0]m2() // [0, 0]// x 和 y 都有值的情况m1(&#123;x: 3, y: 8&#125;) // [3, 8]m2(&#123;x: 3, y: 8&#125;) // [3, 8]// x 有值，y 无值的情况m1(&#123;x: 3&#125;) // [3, 0]m2(&#123;x: 3&#125;) // [3, undefined]// x 和 y 都无值的情况m1(&#123;&#125;) // [0, 0];m2(&#123;&#125;) // [undefined, undefined]m1(&#123;z: 3&#125;) // [0, 0]m2(&#123;z: 3&#125;) // [undefined, undefined] 参数默认值的位置通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。 12345678910111213141516171819// 例一function f(x = 1, y) &#123; return [x, y];&#125;f() // [1, undefined]f(2) // [2, undefined])f(, 1) // 报错f(undefined, 1) // [1, 1]// 例二function f(x, y = 5, z) &#123; return [x, y, z];&#125;f() // [undefined, 5, undefined]f(1) // [1, 5, undefined]f(1, ,2) // 报错f(1, undefined, 2) // [1, 5, 2] 上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。 如果传入undefined，将触发该参数等于默认值，null则没有这个效果。 123456function foo(x = 5, y = 6) &#123; console.log(x, y);&#125;foo(undefined, null)// 5 null 上面代码中，x参数对应undefined，结果触发了默认值，y参数等于null，就没有触发默认值。 函数的 length 属性指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。 123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。 这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入length属性。 1(function(...args) &#123;&#125;).length // 0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 12(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 作用域一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 1234567var x = 1;function f(x, y = x) &#123; console.log(y);&#125;f(2) // 2 上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。 再看下面的例子。 12345678let x = 1;function f(y = x) &#123; let x = 2; console.log(y);&#125;f() // 1 上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。 如果此时，全局变量x不存在，就会报错。 123456function f(y = x) &#123; let x = 2; console.log(y);&#125;f() // ReferenceError: x is not defined 下面这样写，也会报错。 1234567var x = 1;function foo(x = x) &#123; // ...&#125;foo() // ReferenceError: x is not defined 上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。 如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。 12345678let foo = 'outer';function bar(func = () =&gt; foo) &#123; let foo = 'inner'; console.log(func());&#125;bar(); // outer 上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层的全局变量foo，因此输出outer。 如果写成下面这样，就会报错。 123456function bar(func = () =&gt; foo) &#123; let foo = 'inner'; console.log(func());&#125;bar() // ReferenceError: foo is not defined 上面代码中，匿名函数里面的foo指向函数外层，但是函数外层并没有声明变量foo，所以就报错了。 下面是一个更复杂的例子。 123456789var x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123; var x = 3; y(); console.log(x);&#125;foo() // 3x // 1 上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。 如果将var x = 3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。 123456789var x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123; x = 3; y(); console.log(x);&#125;foo() // 2x // 1 应用利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。 12345678910function throwIfMissing() &#123; throw new Error('Missing parameter');&#125;function foo(mustBeProvided = throwIfMissing()) &#123; return mustBeProvided;&#125;foo()// Error: Missing parameter 上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。 从上面代码还可以看到，参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（注意函数名throwIfMissing之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。 另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。 1function foo(optional = undefined) &#123; ··· &#125; rest 参数ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 1234567891011function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。 下面是一个 rest 参数代替arguments变量的例子。 1234567// arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); 上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。 arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子。 123456789function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); console.log(item); &#125;);&#125;var a = [];push(a, 1, 2, 3) 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 1234// 报错function f(a, ...b, c) &#123; // ...&#125; 函数的length属性，不包括 rest 参数。 123(function(a) &#123;&#125;).length // 1(function(...a) &#123;&#125;).length // 0(function(a, ...b) &#123;&#125;).length // 1 严格模式从 ES5 开始，函数内部可以设定为严格模式。 1234function doSomething(a, b) &#123; 'use strict'; // code&#125; ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 12345678910111213141516171819202122232425// 报错function doSomething(a, b = a) &#123; 'use strict'; // code&#125;// 报错const doSomething = function (&#123;a, b&#125;) &#123; 'use strict'; // code&#125;;// 报错const doSomething = (...a) =&gt; &#123; 'use strict'; // code&#125;;const obj = &#123; // 报错 doSomething(&#123;a, b&#125;) &#123; 'use strict'; // code &#125;&#125;; 这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。 12345// 报错function doSomething(value = 070) &#123; 'use strict'; return value;&#125; 上面代码中，参数value的默认值是八进制数070，但是严格模式下不能用前缀0表示八进制，所以应该报错。但是实际上，JavaScript 引擎会先成功执行value = 070，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。 虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。 两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。 12345'use strict';function doSomething(a, b = a) &#123; // code&#125; 第二种是把函数包在一个无参数的立即执行函数里面。 123456const doSomething = (function () &#123; 'use strict'; return function(value = 42) &#123; return value; &#125;;&#125;()); name 属性函数的name属性，返回该函数的函数名。 12function foo() &#123;&#125;foo.name // "foo" 这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。 需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。 1234567var f = function () &#123;&#125;;// ES5f.name // ""// ES6f.name // "f" 上面代码中，变量f等于一个匿名函数，ES5 和 ES6 的name属性返回的值不一样。 如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。 1234567const bar = function baz() &#123;&#125;;// ES5bar.name // "baz"// ES6bar.name // "baz" Function构造函数返回的函数实例，name属性的值为anonymous。 1(new Function).name // "anonymous" bind返回的函数，name属性值会加上bound前缀。 1234function foo() &#123;&#125;;foo.bind(&#123;&#125;).name // "bound foo"(function()&#123;&#125;).bind(&#123;&#125;).name // "bound " 箭头函数基本用法ES6 允许使用“箭头”（=&gt;）定义函数。 123456var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 12345// 报错let getTempItem = id =&gt; &#123; id: id, name: "Temp" &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: "Temp" &#125;); 下面是一种特殊情况，虽然可以运行，但会得到错误的结果。 12let foo = () =&gt; &#123; a: 1 &#125;;foo() // undefined 上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值。 如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。 1let fn = () =&gt; void doesNotReturn(); 箭头函数可以与变量解构结合使用。 123456const full = (&#123; first, last &#125;) =&gt; first + ' ' + last;// 等同于function full(person) &#123; return person.first + ' ' + person.last;&#125; 箭头函数使得表达更加简洁。 12const isEven = n =&gt; n % 2 === 0;const square = n =&gt; n * n; 上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。 箭头函数的一个用处是简化回调函数。 1234567// 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x); 另一个例子是 1234567// 正常函数写法var result = values.sort(function (a, b) &#123; return a - b;&#125;);// 箭头函数写法var result = values.sort((a, b) =&gt; a - b); 下面是 rest 参数与箭头函数结合的例子。 123456789const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5)// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)// [1,[2,3,4,5]] 使用注意点箭头函数有几个使用注意点。 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。 12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。 1234567891011121314151617function Timer() &#123; this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100);setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100);// s1: 3// s2: 0 上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1被更新了 3 次，而timer.s2一次都没更新。 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。 123456789101112var handler = &#123; id: '123456', init: function() &#123; document.addEventListener('click', event =&gt; this.doSomething(event.type), false); &#125;, doSomething: function(type) &#123; console.log('Handling ' + type + ' for ' + this.id); &#125;&#125;; 上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 所以，箭头函数转成 ES5 的代码如下。 123456789101112131415// ES6function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;// ES5function foo() &#123; var _this = this; setTimeout(function () &#123; console.log('id:', _this.id); &#125;, 100);&#125; 上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。 请问下面的代码之中有几个this？ 123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log('id:', this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。 12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log('args:', arguments); &#125;, 100);&#125;foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。 另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。 123456(function() &#123; return [ (() =&gt; this.x).bind(&#123; x: 'inner' &#125;)() ];&#125;).call(&#123; x: 'outer' &#125;);// ['outer'] 上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。 长期以来，JavaScript 语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。 不适用场合由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数。 第一个场合是定义函数的方法，且该方法内部包括this。 123456const cat = &#123; lives: 9, jumps: () =&gt; &#123; this.lives--; &#125;&#125; 上面代码中，cat.jumps()方法是一个箭头函数，这是错误的。调用cat.jumps()时，如果是普通函数，该方法内部的this指向cat；如果写成上面那样的箭头函数，使得this指向全局对象，因此不会得到预期结果。 第二个场合是需要动态this的时候，也不应使用箭头函数。 1234var button = document.getElementById('press');button.addEventListener('click', () =&gt; &#123; this.classList.toggle('on');&#125;); 上面代码运行时，点击按钮会报错，因为button的监听函数是一个箭头函数，导致里面的this就是全局对象。如果改成普通函数，this就会动态指向被点击的按钮对象。 另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。 嵌套的箭头函数箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。 12345678910function insert(value) &#123; return &#123;into: function (array) &#123; return &#123;after: function (afterValue) &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array; &#125;&#125;; &#125;&#125;;&#125;insert(2).into([1, 3]).after(1); //[1, 2, 3] 上面这个函数，可以使用箭头函数改写。 123456let insert = (value) =&gt; (&#123;into: (array) =&gt; (&#123;after: (afterValue) =&gt; &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array;&#125;&#125;)&#125;);insert(2).into([1, 3]).after(1); //[1, 2, 3] 下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。 123456789const pipeline = (...funcs) =&gt; val =&gt; funcs.reduce((a, b) =&gt; b(a), val);const plus1 = a =&gt; a + 1;const mult2 = a =&gt; a * 2;const addThenMult = pipeline(plus1, mult2);addThenMult(5)// 12 如果觉得上面的写法可读性比较差，也可以采用下面的写法。 12345const plus1 = a =&gt; a + 1;const mult2 = a =&gt; a * 2;mult2(plus1(5))// 12 箭头函数还有一个功能，就是可以很方便地改写 λ 演算。 123456// λ演算的写法fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))// ES6的写法var fix = f =&gt; (x =&gt; f(v =&gt; x(x)(v))) (x =&gt; f(v =&gt; x(x)(v))); 上面两种写法，几乎是一一对应的。由于 λ 演算对于计算机科学非常重要，这使得我们可以用 ES6 作为替代工具，探索计算机科学。 双冒号运算符箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。 函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。 123456789101112foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments);const hasOwnProperty = Object.prototype.hasOwnProperty;function hasOwn(obj, key) &#123; return obj::hasOwnProperty(key);&#125; 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。 1234567var method = obj::obj.foo;// 等同于var method = ::obj.foo;let log = ::console.log;// 等同于var log = console.log.bind(console); 如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。 123456import &#123; map, takeWhile, forEach &#125; from "iterlib";getPlayers()::map(x =&gt; x.character())::takeWhile(x =&gt; x.strength &gt; 100)::forEach(x =&gt; console.log(x)); 尾调用优化什么是尾调用？尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 123function f(x)&#123; return g(x);&#125; 上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。 以下三种情况，都不属于尾调用。 123456789101112131415// 情况一function f(x)&#123; let y = g(x); return y;&#125;// 情况二function f(x)&#123; return g(x) + 1;&#125;// 情况三function f(x)&#123; g(x);&#125; 上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。 1234function f(x)&#123; g(x); return undefined;&#125; 尾调用不一定出现在函数尾部，只要是最后一步操作即可。 123456function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。 尾调用优化尾调用之所以与其他调用不同，就在于它的特殊的调用位置。 我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 123456789101112131415function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 1234567function addOne(a)&#123; var one = 1; function inner(b)&#123; return b + one; &#125; return inner(a);&#125; 上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。 尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 123456function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 123456function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。 非尾递归的 Fibonacci 数列实现如下。 123456789function Fibonacci (n) &#123; if ( n &lt;= 1 ) &#123;return 1&#125;; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;Fibonacci(10) // 89Fibonacci(100) // 堆栈溢出Fibonacci(500) // 堆栈溢出 尾递归优化过的 Fibonacci 数列实现如下。 123456789function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return ac2&#125;; return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity 由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。 递归函数的改写尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？ 两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。 12345678910function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;function factorial(n) &#123; return tailFactorial(n, 1);&#125;factorial(5) // 120 上面代码通过一个正常形式的阶乘函数factorial，调用尾递归函数tailFactorial，看起来就正常多了。 函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。 1234567891011121314function currying(fn, n) &#123; return function (m) &#123; return fn.call(this, m, n); &#125;;&#125;function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;const factorial = currying(tailFactorial, 1);factorial(5) // 120 上面代码通过柯里化，将尾递归函数tailFactorial变为只接受一个参数的factorial。 第二种方法就简单多了，就是采用 ES6 的函数默认值。 123456function factorial(n, total = 1) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5) // 120 上面代码中，参数total有默认值1，所以调用时不用提供这个值。 总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。 严格模式ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。 func.arguments：返回调用时函数的参数。 func.caller：返回调用当前函数的那个函数。 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。 123456function restricted() &#123; 'use strict'; restricted.caller; // 报错 restricted.arguments; // 报错&#125;restricted(); 尾递归优化的实现尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。 它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。 下面是一个正常的递归函数。 12345678910function sum(x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y - 1); &#125; else &#123; return x; &#125;&#125;sum(1, 100000)// Uncaught RangeError: Maximum call stack size exceeded(…) 上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归 100000 次，就会报错，提示超出调用栈的最大次数。 蹦床函数（trampoline）可以将递归执行转为循环执行。 123456function trampoline(f) &#123; while (f &amp;&amp; f instanceof Function) &#123; f = f(); &#125; return f;&#125; 上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。 然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。 1234567function sum(x, y) &#123; if (y &gt; 0) &#123; return sum.bind(null, x + 1, y - 1); &#125; else &#123; return x; &#125;&#125; 上面代码中，sum函数的每次执行，都会返回自身的另一个版本。 现在，使用蹦床函数执行sum，就不会发生调用栈溢出。 12trampoline(sum(1, 100000))// 100001 蹦床函数并不是真正的尾递归优化，下面的实现才是。 1234567891011121314151617181920212223242526272829function tco(f) &#123; var value; var active = false; var accumulated = []; return function accumulator() &#123; accumulated.push(arguments); if (!active) &#123; active = true; while (accumulated.length) &#123; value = f.apply(this, accumulated.shift()); &#125; active = false; return value; &#125; &#125;;&#125;var sum = tco(function(x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y - 1) &#125; else &#123; return x &#125;&#125;);sum(1, 100000)// 100001 上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。 函数参数的尾逗号ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。 此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。 123456789function clownsEverywhere( param1, param2) &#123; /* ... */ &#125;clownsEverywhere( 'foo', 'bar'); 上面代码中，如果在param2或bar后面加一个逗号，就会报错。 如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数clownsEverywhere添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。 123456789function clownsEverywhere( param1, param2,) &#123; /* ... */ &#125;clownsEverywhere( 'foo', 'bar',); 这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>实录</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6Promise用法介绍]]></title>
    <url>%2Fit233.github.io%2F2018%2F12%2F17%2FES6Promise%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。 那就new一个 1234567var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('执行完成'); resolve('随便什么数据'); &#125;, 2000);&#125;); Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。不过在我们开始阶段可以先这么理解，后面再细究概念。 在上面的代码中，我们执行了一个异步操作，也就是setTimeout，2秒后，输出“执行完成”，并且调用resolve方法。 1234567891011function runAsync()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('执行完成'); resolve('随便什么数据'); &#125;, 2000); &#125;); return p; &#125;runAsync() 这时候你应该有两个疑问：1.包装这么一个函数有毛线用？2.resolve(‘随便什么数据’);这是干毛的？ 12345runAsync().then(function(data)&#123; console.log(data); //后面可以用传过来的数据做些其他操作 //......&#125;); 在runAsync()的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到我们在runAsync中调用resolve时传的的参数。运行这段代码，会在2秒后输出“执行完成”，紧接着输出“随便什么数据”。 这时候你应该有所领悟了，原来then里面的函数就跟我们平时的回调函数一个意思，能够在runAsync这个异步任务执行完成之后被执行。这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。 12345678910function runAsync(callback)&#123; setTimeout(function()&#123; console.log('执行完成'); callback('随便什么数据'); &#125;, 2000);&#125;runAsync(function(data)&#123; console.log(data);&#125;); 效果也是一样的，还费劲用Promise干嘛。那么问题来了，有多层回调该怎么办？如果callback也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个callback2，然后给callback传进去吧。而Promise的优势在于，可以在then方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。 链式操作的用法123456789101112runAsync1().then(function(data)&#123; console.log(data); return runAsync2();&#125;).then(function(data)&#123; console.log(data); return runAsync3();&#125;).then(function(data)&#123; console.log(data);&#125;); 这样能够按顺序，每隔两秒输出每个异步回调中的内容，在runAsync2中传给resolve的数据，能在接下来的then方法中拿到。运行结果如下： 猜猜runAsync1、runAsync2、runAsync3这三个函数都是如何定义的？没错，就是下面这样 123456789101112131415161718192021222324252627282930function runAsync1()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('异步任务1执行完成'); resolve('随便什么数据1'); &#125;, 1000); &#125;); return p; &#125;function runAsync2()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('异步任务2执行完成'); resolve('随便什么数据2'); &#125;, 2000); &#125;); return p; &#125;function runAsync3()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('异步任务3执行完成'); resolve('随便什么数据3'); &#125;, 2000); &#125;); return p; &#125; 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了，比如我们把上面的代码修改成这样： 123456789101112runAsync1().then(function(data)&#123; console.log(data); return runAsync2();&#125;).then(function(data)&#123; console.log(data); return '直接返回数据'; //这里直接返回数据&#125;).then(function(data)&#123; console.log(data);&#125;); 那么输出就变成了这样： reject的用法123456789101112131415161718192021222324252627function getNumber()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; var num = Math.ceil(Math.random()*10); //生成1-10的随机数 if(num&lt;=5)&#123; resolve(num); &#125; else&#123; reject('数字太大了'); &#125; &#125;, 2000); &#125;); return p; &#125;getNumber().then( function(data)&#123; console.log('resolved'); console.log(data); &#125;, function(reason, data)&#123; console.log('rejected'); console.log(reason); &#125;); getNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为失败的原因。 运行getNumber并且在then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果： 或者 catch的用法123456789getNumber().then(function(data)&#123; console.log('resolved'); console.log(data);&#125;).catch(function(reason)&#123; console.log('rejected'); console.log(reason);&#125;); 效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。请看下面的代码： 12345678910getNumber().then(function(data)&#123; console.log('resolved'); console.log(data); console.log(somedata); //此处的somedata未定义&#125;).catch(function(reason)&#123; console.log('rejected'); console.log(reason);&#125;); 在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果： 也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能。 all的用法Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。我们仍旧使用上面定义好的runAsync1、runAsync2、runAsync3这三个函数，看下面的例子： 12345Promise.all([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123; console.log(results);&#125;); 用Promise.all来执行，all接收一个数组参数，里面的值最终都算返回Promise对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到then里面。那么，三个异步操作返回的数据哪里去了呢？都在then里面呢，all会把所有异步操作的结果放进一个数组中传给then，就是上面的results。所以上面代码的输出结果就是： 有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。 这里要说明的一点就是：但是有个前提，就是结果全是fulfilled状态，假如中间有个结果时rejected状态了，即使其他异步函数没有结果，这时也会调用all方法。 如果其中有个异步操作执行失败，那么就不会再显示其他执行成功的异步操作返回的数据，即会直接进入catch() 12345678910111213141516171819202122//这里我们将润Async2()异步操作中执行rejectfunction runAsync2()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('异步任务2执行完成'); // resolve('随便什么数据2'); reject("2错了") &#125;, 2000); &#125;); return p; &#125;//异常捕获一下Promise.all([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123; console.log(results);&#125;).catch(function(data)&#123; console.log(data)&#125;); race的用法all方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是race方法，这个词本来就是赛跑的意思。race的用法与all一样，我们把上面runAsync1的延时改为1秒来看一下： 12345Promise.race([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123; console.log(results);&#125;); 这三个异步操作同样是并行执行的。结果你应该可以猜到，1秒后runAsync1已经执行完了，此时then里面的就执行了。结果是这样的： 你猜对了吗？不完全，是吧。在then里面的回调开始执行时，runAsync2()和runAsync3()并没有停止，仍旧再执行。于是再过1秒后，输出了他们结束的标志。 这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下： 12345678910111213141516171819202122232425262728//请求某个图片资源function requestImg()&#123; var p = new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; resolve('图片请求成功'); &#125;, 2000); &#125;); return p;&#125;//延时函数，用于给请求计时function timeout()&#123; var p = new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; reject('图片请求超时'); &#125;, 5000); &#125;); return p;&#125;Promise.race([requestImg(), timeout()]).then(function(results)&#123; console.log(results);&#125;).catch(function(reason)&#123; console.log(reason);&#125;); 这里使用setTimeOut()来模拟请求图片时的延时，当请求时间小于超时时间的时候，会正常执行.then()回调，反之，则执行catch()回调]]></content>
      <tags>
        <tag>Promise</tag>
        <tag>实录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数值的扩展]]></title>
    <url>%2Fit233.github.io%2F2018%2F12%2F11%2F%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[二进制和八进制表示法ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。 120b111110111 === 503 // true0o767 === 503 // true 从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示。 12345678910// 非严格模式(function()&#123; console.log(0o11 === 011);&#125;)() // true// 严格模式(function()&#123; 'use strict'; console.log(0o11 === 011);&#125;)() // Uncaught SyntaxError: Octal literals are not allowed in strict mode. 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。 12let n1 = new Number('0b111') // 7let n2 = new Number('0o10') // 8 Number.isFinite(), Number.isNaN()ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。 Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。 12345678Number.isFinite(15); // trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite('foo'); // falseNumber.isFinite('15'); // falseNumber.isFinite(true); // false 注意，如果参数类型不是数值，Number.isFinite一律返回false。 Number.isNaN()用来检查一个值是否为NaN。 1234567Number.isNaN(NaN) // trueNumber.isNaN(15) // falseNumber.isNaN('15') // falseNumber.isNaN(true) // falseNumber.isNaN(9/NaN) // trueNumber.isNaN('true' / 0) // trueNumber.isNaN('true' / 'true') // true 如果参数类型不是NaN，Number.isNaN一律返回false。 它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。 说明：js中对于运算，并不只是只有数值类型的才能参与运算，例如true，false，字符串形式的数值’0’这些都可以参与运算，js会在运算之前将所有参与运算的元素转换成统一类型(数值)然后在进行运算，+运算例外（+还代表字符串的拼接符）。 所以以上代码 : 9/NaN结果为NaN， ‘true’ / 0 = NaN / 0 =NaN， ‘true’ / ‘true’ = NaN / NaN = NaN 12345678910isFinite(25) // trueisFinite("25") // trueNumber.isFinite(25) // trueNumber.isFinite("25") // falseisNaN(NaN) // trueisNaN("NaN") // trueNumber.isNaN(NaN) // trueNumber.isNaN("NaN") // falseNumber.isNaN(1) // false Number.parseInt(), Number.parseFloat()ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 1234567// ES5的写法parseInt('12.34') // 12parseFloat('123.45#') // 123.45// ES6的写法Number.parseInt('12.34') // 12Number.parseFloat('123.45#') // 123.45 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 12Number.parseInt === parseInt // trueNumber.parseFloat === parseFloat // true Number.isInteger()Number.isInteger()用来判断一个数值是否为整数。 12Number.isInteger(25) // trueNumber.isInteger(25.1) // false JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。 12Number.isInteger(25) // trueNumber.isInteger(25.0) // true 如果参数不是数值，Number.isInteger返回false。 1234Number.isInteger() // falseNumber.isInteger(null) // falseNumber.isInteger('15') // falseNumber.isInteger(true) // false 注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。 1Number.isInteger(3.0000000000000002) // true 上面代码中，Number.isInteger的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。 类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，Number.isInteger也会误判。 12Number.isInteger(5E-324) // falseNumber.isInteger(5E-325) // true 上面代码中，5E-325由于值太小，会被自动转为0，因此返回true。 总之，如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。 Number.EPSILONES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。 对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。 123456Number.EPSILON === Math.pow(2, -52)// trueNumber.EPSILON// 2.220446049250313e-16Number.EPSILON.toFixed(20)// "0.00000000000000022204" Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。 引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。 123456780.1 + 0.2// 0.300000000000000040.1 + 0.2 - 0.3// 5.551115123125783e-175.551115123125783e-17.toFixed(20)// '0.00000000000000005551' 上面代码解释了，为什么比较0.1 + 0.2与0.3得到的结果是false。 10.1 + 0.2 === 0.3 // false Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。 125.551115123125783e-17 &lt; Number.EPSILON * Math.pow(2, 2)// true 因此，Number.EPSILON的实质是一个可以接受的最小误差范围。 123456789function withinErrorMargin (left, right) &#123; return Math.abs(left - right) &lt; Number.EPSILON * Math.pow(2, 2);&#125;0.1 + 0.2 === 0.3 // falsewithinErrorMargin(0.1 + 0.2, 0.3) // true1.1 + 1.3 === 2.4 // falsewithinErrorMargin(1.1 + 1.3, 2.4) // true 上面的代码为浮点数运算，部署了一个误差检查函数。 安全整数和 Number.isSafeInteger()JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。 1234567Math.pow(2, 53) // 90071992547409929007199254740992 // 90071992547409929007199254740993 // 9007199254740992Math.pow(2, 53) === Math.pow(2, 53) + 1// true 上面代码中，超出 2 的 53 次方之后，一个数就不精确了。 ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。 123456789Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1// trueNumber.MAX_SAFE_INTEGER === 9007199254740991// trueNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER// trueNumber.MIN_SAFE_INTEGER === -9007199254740991// true 上面代码中，可以看到 JavaScript 能够精确表示的极限。 Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。 123456789101112131415Number.isSafeInteger('a') // falseNumber.isSafeInteger(null) // falseNumber.isSafeInteger(NaN) // falseNumber.isSafeInteger(Infinity) // falseNumber.isSafeInteger(-Infinity) // falseNumber.isSafeInteger(3) // trueNumber.isSafeInteger(1.2) // falseNumber.isSafeInteger(9007199254740990) // trueNumber.isSafeInteger(9007199254740992) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false 这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。 123456Number.isSafeInteger = function (n) &#123; return (typeof n === 'number' &amp;&amp; Math.round(n) === n &amp;&amp; Number.MIN_SAFE_INTEGER &lt;= n &amp;&amp; n &lt;= Number.MAX_SAFE_INTEGER);&#125; 实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。 123456789Number.isSafeInteger(9007199254740993)// falseNumber.isSafeInteger(990)// trueNumber.isSafeInteger(9007199254740993 - 990)// true9007199254740993 - 990// 返回结果 9007199254740002// 正确答案应该是 9007199254740003 上面代码中，9007199254740993不是一个安全整数，但是Number.isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存。 129007199254740993 === 9007199254740992// true 所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。 12345678910111213141516function trusty (left, right, result) &#123; if ( Number.isSafeInteger(left) &amp;&amp; Number.isSafeInteger(right) &amp;&amp; Number.isSafeInteger(result) ) &#123; return result; &#125; throw new RangeError('Operation cannot be trusted!');&#125;trusty(9007199254740993, 990, 9007199254740993 - 990)// RangeError: Operation cannot be trusted!trusty(1, 2, 3)// 3 Math 对象的扩展ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。 Math.trunc()Math.trunc方法用于去除一个数的小数部分，返回整数部分。 12345Math.trunc(4.1) // 4Math.trunc(4.9) // 4Math.trunc(-4.1) // -4Math.trunc(-4.9) // -4Math.trunc(-0.1234) // -0 对于非数值，Math.trunc内部使用Number方法将其先转为数值。 1234Math.trunc('123.456') // 123Math.trunc(true) //1Math.trunc(false) // 0Math.trunc(null) // 0 对于空值和无法截取整数的值，返回NaN。 1234Math.trunc(NaN); // NaNMath.trunc('foo'); // NaNMath.trunc(); // NaNMath.trunc(undefined) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.trunc = Math.trunc || function(x) &#123; return x &lt; 0 ? Math.ceil(x) : Math.floor(x);&#125;; Math.sign()Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。 它会返回五种值。 参数为正数，返回+1； 参数为负数，返回-1； 参数为 0，返回0； 参数为-0，返回-0; 其他值，返回NaN。 12345Math.sign(-5) // -1Math.sign(5) // +1Math.sign(0) // +0Math.sign(-0) // -0Math.sign(NaN) // NaN 如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。 12345678Math.sign('') // 0Math.sign(true) // +1Math.sign(false) // 0Math.sign(null) // 0Math.sign('9') // +1Math.sign('foo') // NaNMath.sign() // NaNMath.sign(undefined) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 1234567Math.sign = Math.sign || function(x) &#123; x = +x; // convert to a number if (x === 0 || isNaN(x)) &#123; return x; &#125; return x &gt; 0 ? 1 : -1;&#125;; Math.cbrt()Math.cbrt方法用于计算一个数的立方根。 1234Math.cbrt(-1) // -1Math.cbrt(0) // 0Math.cbrt(1) // 1Math.cbrt(2) // 1.2599210498948734 对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。 12Math.cbrt('8') // 2Math.cbrt('hello') // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 1234Math.cbrt = Math.cbrt || function(x) &#123; var y = Math.pow(Math.abs(x), 1/3); return x &lt; 0 ? -y : y;&#125;; Math.clz32()JavaScript 的整数使用 32 位二进制形式表示，Math.clz32方法返回一个数的 32 位无符号整数形式有多少个前导 0。 12345Math.clz32(0) // 32Math.clz32(1) // 31Math.clz32(1000) // 22Math.clz32(0b01000000000000000000000000000000) // 1Math.clz32(0b00100000000000000000000000000000) // 2 上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是0b1，只占 1 位，所以 32 位之中有 31 个前导 0；1000 的二进制形式是0b1111101000，一共有 10 位，所以 32 位之中有 22 个前导 0。 clz32这个函数名就来自”count leading zero bits in 32-bit binary representation of a number“（计算一个数的 32 位二进制形式的前导 0 的个数）的缩写。 左移运算符（&lt;&lt;）与Math.clz32方法直接相关。 12345Math.clz32(0) // 32Math.clz32(1) // 31Math.clz32(1 &lt;&lt; 1) // 30Math.clz32(1 &lt;&lt; 2) // 29Math.clz32(1 &lt;&lt; 29) // 2 对于小数，Math.clz32方法只考虑整数部分。 12Math.clz32(3.2) // 30Math.clz32(3.9) // 30 对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算。 12345678Math.clz32() // 32Math.clz32(NaN) // 32Math.clz32(Infinity) // 32Math.clz32(null) // 32Math.clz32('foo') // 32Math.clz32([]) // 32Math.clz32(&#123;&#125;) // 32Math.clz32(true) // 31 Math.imul()Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。 123Math.imul(2, 4) // 8Math.imul(-1, 8) // -8Math.imul(-2, -2) // 4 如果只考虑最后 32 位，大多数情况下，Math.imul(a, b)与a * b的结果是相同的，即该方法等同于(a * b)|0的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。 1(0x7fffffff * 0x7fffffff)|0 // 0 上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。Math.imul方法可以返回正确的值 1。 1Math.imul(0x7fffffff, 0x7fffffff) // 1 Math.fround()Math.fround方法返回一个数的32位单精度浮点数形式。 对于32位单精度格式来说，数值精度是24个二进制位（1 位隐藏位与 23 位有效位），所以对于 -224 至 224 之间的整数（不含两个端点），返回结果与参数本身一致。 123Math.fround(0) // 0Math.fround(1) // 1Math.fround(2 ** 24 - 1) // 16777215 如果参数的绝对值大于 224，返回的结果便开始丢失精度。 12Math.fround(2 ** 24) // 16777216Math.fround(2 ** 24 + 1) // 16777216 Math.fround方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。 12345678// 未丢失有效精度Math.fround(1.125) // 1.125Math.fround(7.25) // 7.25// 丢失精度Math.fround(0.3) // 0.30000001192092896Math.fround(0.7) // 0.699999988079071Math.fround(1.0000000123) // 1 对于 NaN 和 Infinity，此方法返回原值。对于其它类型的非数值，Math.fround 方法会先将其转为数值，再返回单精度浮点数。 12345678Math.fround(NaN) // NaNMath.fround(Infinity) // InfinityMath.fround('5') // 5Math.fround(true) // 1Math.fround(null) // 0Math.fround([]) // 0Math.fround(&#123;&#125;) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.fround = Math.fround || function (x) &#123; return new Float32Array([x])[0];&#125;; Math.hypot()Math.hypot方法返回所有参数的平方和的平方根。 1234567Math.hypot(3, 4); // 5Math.hypot(3, 4, 5); // 7.0710678118654755Math.hypot(); // 0Math.hypot(NaN); // NaNMath.hypot(3, 4, 'foo'); // NaNMath.hypot(3, 4, '5'); // 7.0710678118654755Math.hypot(-3); // 3 上面代码中，3 的平方加上 4 的平方，等于 5 的平方。 如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。 对数方法ES6 新增了 4 个对数相关方法。 （1） Math.expm1() Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1。 123Math.expm1(-1) // -0.6321205588285577Math.expm1(0) // 0Math.expm1(1) // 1.718281828459045 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.expm1 = Math.expm1 || function(x) &#123; return Math.exp(x) - 1;&#125;; （2）Math.log1p() Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。 1234Math.log1p(1) // 0.6931471805599453Math.log1p(0) // 0Math.log1p(-1) // -InfinityMath.log1p(-2) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.log1p = Math.log1p || function(x) &#123; return Math.log(1 + x);&#125;; （3）Math.log10() Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。 12345Math.log10(2) // 0.3010299956639812Math.log10(1) // 0Math.log10(0) // -InfinityMath.log10(-2) // NaNMath.log10(100000) // 5 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.log10 = Math.log10 || function(x) &#123; return Math.log(x) / Math.LN10;&#125;; （4）Math.log2() Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。 1234567Math.log2(3) // 1.584962500721156Math.log2(2) // 1Math.log2(1) // 0Math.log2(0) // -InfinityMath.log2(-2) // NaNMath.log2(1024) // 10Math.log2(1 &lt;&lt; 29) // 29 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.log2 = Math.log2 || function(x) &#123; return Math.log(x) / Math.LN2;&#125;; 双曲函数方法ES6 新增了 6 个双曲函数方法。 Math.sinh(x) 返回x的双曲正弦（hyperbolic sine） Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine） Math.tanh(x) 返回x的双曲正切（hyperbolic tangent） Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine） Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine） Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent） 指数运算符ES2016 新增了一个指数运算符（**）。 122 ** 2 // 42 ** 3 // 8 这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。 123// 相当于 2 ** (3 ** 2)2 ** 3 ** 2// 512 上面代码中，首先计算的是第二个指数运算符，而不是第一个。 指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。 1234567let a = 1.5;a **= 2;// 等同于 a = a * a;let b = 4;b **= 3;// 等同于 b = b * b * b; 注意，V8 引擎的指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。 12345Math.pow(99, 99)// 3.697296376497263e+19799 ** 99// 3.697296376497268e+197 上面代码中，两个运算结果的最后一位有效数字是有差异的。]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>实录</tag>
        <tag>数值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则的扩展]]></title>
    <url>%2Fit233.github.io%2F2018%2F12%2F11%2F%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[RegExp 构造函数在 ES5 中，RegExp构造函数的参数有两种情况。 第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。 123var regex = new RegExp('xyz', 'i');// 等价于var regex = /xyz/i; 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。 123var regex = new RegExp(/xyz/i);// 等价于var regex = /xyz/i; 但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。 12var regex = new RegExp(/xyz/, 'i');// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。 12new RegExp(/abc/ig, 'i').flags// "i" 上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。 字符串的正则方法字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。 ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split] u 修饰符ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。 12/^\uD83D/u.test('\uD83D\uDC2A') // false/^\uD83D/.test('\uD83D\uDC2A') // true 上面代码中，\uD83D\uDC2A是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为false。 一旦加上u修饰符号，就会修改下面这些正则表达式的行为。 （1）点字符 点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。 1234var s = '𠮷';/^.$/.test(s) // false/^.$/u.test(s) // true 上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。 （2）Unicode 字符表示法 ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。 123/\u&#123;61&#125;/.test('a') // false/\u&#123;61&#125;/u.test('a') // true/\u&#123;20BB7&#125;/u.test('𠮷') // true 上面代码表示，如果不加u修饰符，正则表达式无法识别\u{61}这种表示法，只会认为这匹配 61 个连续的u。 （3）量词 使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。 1234/a&#123;2&#125;/.test('aa') // true/a&#123;2&#125;/u.test('aa') // true/𠮷&#123;2&#125;/.test('𠮷𠮷') // false/𠮷&#123;2&#125;/u.test('𠮷𠮷') // true （4）预定义模式 u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符。 12/^\S$/.test('𠮷') // false/^\S$/u.test('𠮷') // true 上面代码的\S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。 利用这一点，可以写出一个正确返回字符串长度的函数。 123456789function codePointLength(text) &#123; var result = text.match(/[\s\S]/gu); return result ? result.length : 0;&#125;var s = '𠮷𠮷';s.length // 4codePointLength(s) // 2 （5）i 修饰符 有些 Unicode 字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K。 12/[a-z]/i.test('\u212A') // false/[a-z]/iu.test('\u212A') // true 上面代码中，不加u修饰符，就无法识别非规范的K字符。 RegExp.prototype.unicode 属性正则实例对象新增unicode属性，表示是否设置了u修饰符。 12345const r1 = /hello/;const r2 = /hello/u;r1.unicode // falser2.unicode // true 上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。 y 修饰符除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。 y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 123456789var s = 'aaa_aa_a';var r1 = /a+/g;var r2 = /a+/y;r1.exec(s) // ["aaa"]r2.exec(s) // ["aaa"]r1.exec(s) // ["aa"]r2.exec(s) // null 上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。 如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。 12345var s = 'aaa_aa_a';var r = /a+_/y;r.exec(s) // ["aaa_"]r.exec(s) // ["aa_"] 上面代码每次匹配，都是从剩余字符串的头部开始。 使用lastIndex属性，可以更好地说明y修饰符。 12345678910111213141516const REGEX = /a/g;// 指定从2号位置（y）开始匹配REGEX.lastIndex = 2;// 匹配成功const match = REGEX.exec('xaya');// 在3号位置匹配成功match.index // 3// 下一次匹配从4号位开始REGEX.lastIndex // 4// 4号位开始匹配失败REGEX.exec('xaya') // null 上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。 y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。 123456789101112131415const REGEX = /a/y;// 指定从2号位置开始匹配REGEX.lastIndex = 2;// 不是粘连，匹配失败REGEX.exec('xaya') // null// 指定从3号位置开始匹配REGEX.lastIndex = 3;// 3号位置是粘连，匹配成功const match = REGEX.exec('xaya');match.index // 3REGEX.lastIndex // 4 实际上，y修饰符号隐含了头部匹配的标志^。 12/b/y.exec('aba')// null 上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。 下面是字符串对象的replace方法的例子。 12const REGEX = /a/gy;'aaxa'.replace(REGEX, '-') // '--xa' 上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。 单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。 12'a1a2a3'.match(/a\d/y) // ["a1"]'a1a2a3'.match(/a\d/gy) // ["a1", "a2", "a3"] y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。 12345678910111213141516const TOKEN_Y = /\s*(\+|[0-9]+)\s*/y;const TOKEN_G = /\s*(\+|[0-9]+)\s*/g;tokenize(TOKEN_Y, '3 + 4')// [ '3', '+', '4' ]tokenize(TOKEN_G, '3 + 4')// [ '3', '+', '4' ]function tokenize(TOKEN_REGEX, str) &#123; let result = []; let match; while (match = TOKEN_REGEX.exec(str)) &#123; result.push(match[1]); &#125; return result;&#125; 上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。 1234tokenize(TOKEN_Y, '3x + 4')// [ '3' ]tokenize(TOKEN_G, '3x + 4')// [ '3', '+', '4' ] 上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。 RegExp.prototype.sticky 属性与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。 12var r = /hello\d/y;r.sticky // true RegExp.prototype.flags 属性ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。 123456789// ES5 的 source 属性// 返回正则表达式的正文/abc/ig.source// "abc"// ES6 的 flags 属性// 返回正则表达式的修饰符/abc/ig.flags// 'gi' s 修饰符：dotAll 模式正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。 所谓行终止符，就是该字符表示一行的终结。以下四个字符属于”行终止符“。 U+000A 换行符（\n） U+000D 回车符（\r） U+2028 行分隔符（line separator） U+2029 段分隔符（paragraph separator） 12/foo.bar/.test('foo\nbar')// false 上面代码中，因为.不匹配\n，所以正则表达式返回false。 但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。 12/foo[^]bar/.test('foo\nbar')// true 这种解决方案毕竟不太符合直觉，ES2018 引入s修饰符，使得.可以匹配任意单个字符。 1/foo.bar/s.test('foo\nbar') // true 这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。 1234567const re = /foo.bar/s;// 另一种写法// const re = new RegExp('foo.bar', 's');re.test('foo\nbar') // truere.dotAll // truere.flags // 's' /s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。 后行断言JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。 ”先行断言“指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。”先行否定断言“指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。 12/\d+(?=%)/.exec('100% of US presidents have been male') // ["100"]/\d+(?!%)/.exec('that’s all 44 of them') // ["44"] 上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，”先行断言“括号之中的部分（(?=%)），是不计入返回结果的。 “后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\$)\d+/。”后行否定断言“则与”先行否定断言“相反，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!\$)\d+/。 12/(?&lt;=\$)\d+/.exec('Benjamin Franklin is on the $100 bill') // ["100"]/(?&lt;!\$)\d+/.exec('it’s is worth about €90') // ["90"] 上面的例子中，“后行断言”的括号之中的部分（(?&lt;=\$)），也是不计入返回结果。 下面的例子是使用后行断言进行字符串替换。 123const RE_DOLLAR_PREFIX = /(?&lt;=\$)foo/g;'$foo %foo foo'.replace(RE_DOLLAR_PREFIX, 'bar');// '$bar %foo foo' 上面代码中，只有在美元符号后面的foo才会被替换。 “后行断言”的实现，需要先匹配/(?&lt;=y)x/的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。 首先，后行断言的组匹配，与正常情况下结果是不一样的。 12/(?&lt;=(\d+)(\d+))$/.exec('1053') // ["", "1", "053"]/^(\d+)(\d+)$/.exec('1053') // ["1053", "105", "3"] 上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。 其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。 12/(?&lt;=(o)d\1)r/.exec('hodor') // null/(?&lt;=\1d(o))r/.exec('hodor') // ["r", "o"] 上面代码中，如果后行断言的反斜杠引用（\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。 Unicode 属性类ES2018 引入了一种新的类的写法\p{...}和\P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。 12const regexGreekSymbol = /\p&#123;Script=Greek&#125;/u;regexGreekSymbol.test('π') // true 上面代码中，\p{Script=Greek}指定匹配一个希腊文字母，所以匹配π成功。 Unicode 属性类要指定属性名和属性值。 1\p&#123;UnicodePropertyName=UnicodePropertyValue&#125; 对于某些属性，可以只写属性名，或者只写属性值。 12\p&#123;UnicodePropertyName&#125;\p&#123;UnicodePropertyValue&#125; \P{…}是\p{…}的反向匹配，即匹配不满足条件的字符。 注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用\p和\P会报错，ECMAScript 预留了这两个类。 由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。 12const regex = /^\p&#123;Decimal_Number&#125;+$/u;regex.test('𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼') // true 上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。 \p{Number}甚至能匹配罗马数字。 12345// 匹配所有数字const regex = /^\p&#123;Number&#125;+$/u;regex.test('²³¹¼½¾') // trueregex.test('㉛㉜㉝') // trueregex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true 下面是其他一些例子。 123456789101112131415// 匹配所有空格\p&#123;White_Space&#125;// 匹配各种文字的所有字母，等同于 Unicode 版的 \w[\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W[^\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]// 匹配 Emoji/\p&#123;Emoji_Modifier_Base&#125;\p&#123;Emoji_Modifier&#125;?|\p&#123;Emoji_Presentation&#125;|\p&#123;Emoji&#125;\uFE0F/gu// 匹配所有的箭头字符const regexArrows = /^\p&#123;Block=Arrows&#125;+$/u;regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true 具名组匹配简介正则表达式使用圆括号进行组匹配。 1const RE_DATE = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/; 上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。 123456const RE_DATE = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;const matchObj = RE_DATE.exec('1999-12-31');const year = matchObj[1]; // 1999const month = matchObj[2]; // 12const day = matchObj[3]; // 31 组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。 ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。 123456const RE_DATE = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/;const matchObj = RE_DATE.exec('1999-12-31');const year = matchObj.groups.year; // 1999const month = matchObj.groups.month; // 12const day = matchObj.groups.day; // 31 上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?&lt;year&gt;），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。 具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。 如果具名组没有匹配，那么对应的groups对象属性会是undefined。 12345const RE_OPT_A = /^(?&lt;as&gt;a+)?$/;const matchObj = RE_OPT_A.exec('');matchObj.groups.as // undefined'as' in matchObj.groups // true 上面代码中，具名组as没有找到匹配，那么matchObj.groups.as属性值就是undefined，并且as这个键名在groups是始终存在的。 解构赋值和替换有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。 123let &#123;groups: &#123;one, two&#125;&#125; = /^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u.exec('foo:bar');one // footwo // bar 字符串替换时，使用$&lt;组名&gt;引用具名组。 1234let re = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u;'2015-01-02'.replace(re, '$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;')// '02/01/2015' 上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。 replace方法的第二个参数也可以是函数，该函数的参数序列如下。 123456789101112'2015-01-02'.replace(re, ( matched, // 整个匹配结果 2015-01-02 capture1, // 第一个组匹配 2015 capture2, // 第二个组匹配 01 capture3, // 第三个组匹配 02 position, // 匹配开始的位置 0 S, // 原字符串 2015-01-02 groups // 具名组构成的一个对象 &#123;year, month, day&#125; ) =&gt; &#123; let &#123;day, month, year&#125; = groups; return `$&#123;day&#125;/$&#123;month&#125;/$&#123;year&#125;`;&#125;); 具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。 引用如果要在正则表达式内部引用某个“具名组匹配”，可以使用\k&lt;组名&gt;的写法。 123const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/;RE_TWICE.test('abc!abc') // trueRE_TWICE.test('abc!ab') // false 数字引用（\1）依然有效。 123const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\1$/;RE_TWICE.test('abc!abc') // trueRE_TWICE.test('abc!ab') // false 这两种引用语法还可以同时使用。 123const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/;RE_TWICE.test('abc!abc!abc') // trueRE_TWICE.test('abc!abc!ab') // false String.prototype.matchAll如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。 123456789101112131415var regex = /t(e)(st(\d?))/g;var string = 'test1test2test3';var matches = [];var match;while (match = regex.exec(string)) &#123; matches.push(match);&#125;matches// [// ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"],// ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"],// ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]// ] 上面代码中，while循环取出每一轮的正则匹配，一共三轮。 目前有一个提案，增加了String.prototype.matchAll方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。 1234567891011const string = 'test1test2test3';// g 修饰符加不加都可以const regex = /t(e)(st(\d?))/g;for (const match of string.matchAll(regex)) &#123; console.log(match);&#125;// ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"]// ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"]// ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"] 上面代码中，由于string.matchAll(regex)返回的是遍历器，所以可以用for...of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。 遍历器转为数组是非常简单的，使用...运算符和Array.from方法就可以了。 12345// 转为数组方法一[...string.matchAll(regex)]// 转为数组方法二Array.from(string.matchAll(regex));]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串的扩展]]></title>
    <url>%2Fit233.github.io%2F2018%2F12%2F07%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[ES6 加强了对Unicode的支持，并且扩展了字符串对象 字符串的Unicode表示法javaScript允许采用 \uxxxx 形式表示一个字符，其中xxxx表示字符的Unicode码点 12"\u0061"// "a" 但是，这种表示法只限于码点在 \u0000 ~ \uFFFF之间的字符，超出这个范围的字符串必须用两个双字节的形式表示 12345"\uD842\uDFB7"// "𠮷""\u20BB7"// " 7" 如上，如果\u后面跟上超过0xFFFF的数值（如：\20BB7），JavaScript会理解成\u20BB+7 由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟一个7 ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。 1234567891011"\u&#123;20BB7&#125;"// "𠮷""\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"// "ABC"let hello = 123;hell\u&#123;6F&#125; // 123'\u&#123;1F680&#125;' === '\uD83D\uDE80'// true 上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。 有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。 1234567891011"\u&#123;20BB7&#125;"// "𠮷""\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"// "ABC"let hello = 123;hell\u&#123;6F&#125; // 123'\u&#123;1F680&#125;' === '\uD83D\uDE80'// true 上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。 有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。 12345'\z' === 'z' // true'\172' === 'z' // true'\x7A' === 'z' // true'\u007A' === 'z' // true'\u&#123;7A&#125;' === 'z' // true codePointAt()JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。 1234567var s = "𠮷";s.length // 2s.charAt(0) // ''s.charAt(1) // ''s.charCodeAt(0) // 55362s.charCodeAt(1) // 57271 上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。 ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。 123456let s = '𠮷a';s.codePointAt(0) // 134071s.codePointAt(1) // 57271s.codePointAt(2) // 97 codePointAt方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt方法的结果与charCodeAt方法相同。 总之，codePointAt方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。 codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下。 疑问：既然用索引0表示第一个字，并且能够渠道完整的”𠮷”的码点，为什么索引为1还是取到”𠮷”的后两个码点？而索引为2才是取到第二个字符？没搞懂，实验出来确实是如上的结果！那么这样就会出现这样一种情况：一个字符串，里面的字符不确定到底是两个字节还是四个字节，也就是说不确定一个字符包含的码点到底是一个还是两个，这样取值的时候怎么办？就会出现位置无法确定！ 先来看下面的代码： 123456let s = '𠮷a';for (let ch of s) &#123; console.log(ch.codePointAt(0).toString(16));&#125;// 20bb7// 61 这里说明一下：在ES6环境下（ES5不知道，因为没有在ES5环境下测试过”𠮷a”这个字符串），使用split()将s拆成数组，数组长度为3，就是跟上面的结果一样，使用charAt()，根据索引取值，0和1都是只能取“𠮷”字的前两个字节和后两个字节，所以，这里就用for循环，注意是of，不能用in，使用in取得的是split()之后的索引（0，1，2），除了使用循环之外，还可以使用变量的解构赋值： 12345let s = '𠮷a';let [one,two] = sconsole.log(one,two)//20bb7 //61 以上两种方式,目前只想到了这两种能够完全获取字符串中完整的单个字符的码点方法 注意：对象的解构赋值也是长度为3，不可行，substr()、sbustring()、split()等等这些方法，都不行。就连indexOf(“a”)获得的索引都是2，很尴尬的结果 接下来，我们可以判断一个字符到底是两个字节还是四个字节组成的： 123456function is32Bit(c) &#123; return c.codePointAt(0) &gt; 0xFFFF;&#125;is32Bit("𠮷") // trueis32Bit("a") // false String.fromCodePoint()ES5 提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）。 12String.fromCharCode(0x20BB7)// "ஷ" 上面代码中，String.fromCharCode不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。 ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反 1234String.fromCodePoint(0x20BB7)// "𠮷"String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y'// true 上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。 如上第三行String.fromCodePoint(0x78, 0x1f680, 0x79)返回的字符串是：x🚀y 注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。 字符串的遍历器接口之前有说过（变量的解构赋值），实验表明，字符串是具备Iterator接口的，也就是能够循环，即遍历接口，这是ES6位字符串添加的，这样字符串就可以使用for…of循环便利，上面代码有例子，就不列举了 当然，除了便于遍历字符串，这个遍历器最大的有点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点 12345678910for (let i = 0; i &lt; text.length; i++) &#123; console.log(text[i]);&#125;// " "// " "for (let i of text) &#123; console.log(i);&#125;// "𠮷" 上面代码中，字符串text只有一个字符，但是for循环会认为它包含两个字符（都不可打印），而for...of循环会正确识别出这一个字符。 normalize()许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。 这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别 1234'\u01D1'==='\u004F\u030C' //false'\u01D1'.length // 1'\u004F\u030C'.length // 2 上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。 ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。 12'\u01D1'.normalize() === '\u004F\u030C'.normalize()// true normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。 NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。 12'\u004F\u030C'.normalize('NFC').length // 1'\u004F\u030C'.normalize('NFD').length // 2 上面代码表示，NFC参数返回字符的合成形式，NFD参数返回字符的分解形式。 不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。 includes(), startsWith(), endsWith()传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 12345let s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true 这三个方法都支持第二个参数，表示开始搜索的位置。 12345let s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false 上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。 123'x'.repeat(3) // "xxx"'hello'.repeat(2) // "hellohello"'na'.repeat(0) // "" 参数如果是小数，会被舍弃小数部分取整。 1'na'.repeat(2.9) // "nana" 如果repeat的参数是负数或者Infinity，会报错。 1234'na'.repeat(Infinity)// RangeError'na'.repeat(-1)// RangeError 但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。 1'na'.repeat(-0.9) // "" 参数NaN等同于 0。 1'na'.repeat(NaN) // "" 如果repeat的参数是字符串，则会先转换成数字。 12'na'.repeat('na') // ""'na'.repeat('3') // "nanana" padStart()，padEnd()ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 12345'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' 上面代码中，padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。 如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。 12'xxx'.padStart(2, 'ab') // 'xxx''xxx'.padEnd(2, 'ab') // 'xxx' 如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。 12'abc'.padStart(10, '0123456789')// '0123456abc' 如果省略第二个参数，默认使用空格补全长度。 12'x'.padStart(4) // ' x''x'.padEnd(4) // 'x ' padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。 123'1'.padStart(10, '0') // "0000000001"'12'.padStart(10, '0') // "0000000012"'123456'.padStart(10, '0') // "0000123456" 另一个用途是提示字符串格式。 12'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12" matchAll()matchAll方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。 模板字符串传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。 123456$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); 上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。 12345$('#result').append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 12345678910111213// 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 1let greeting = `\`Yo\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 上面代码中，所有模板字符串的空格和换行，都是被保留的，比如&lt;ul&gt;标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`.trim()); 模板字符串中嵌入变量，需要将变量名写在${}之中。 123456789101112function authorize(user, action) &#123; if (!user.hasPrivilege(action)) &#123; throw new Error( // 传统写法为 // 'User ' // + user.name // + ' is not authorized to do ' // + action // + '.' `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`); &#125;&#125; 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 123456789101112let x = 1;let y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`// "1 + 2 = 3"`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`// "1 + 4 = 5"let obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;`// "3" 模板字符串之中还能调用函数。 123456function fn() &#123; return "Hello World";&#125;`foo $&#123;fn()&#125; bar`// foo Hello World bar 如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。 如果模板字符串中的变量没有声明，将报错。 123// 变量place没有声明let msg = `Hello, $&#123;place&#125;`;// 报错 由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。 12`Hello $&#123;'World'&#125;`// "Hello World" 模板字符串甚至还能嵌套。 12345678const tmpl = addrs =&gt; ` &lt;table&gt; $&#123;addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt; `).join('')&#125; &lt;/table&gt;`; 上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。 123456789101112131415const data = [ &#123; first: '&lt;Jane&gt;', last: 'Bond' &#125;, &#123; first: 'Lars', last: '&lt;Croft&gt;' &#125;,];console.log(tmpl(data));// &lt;table&gt;//// &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;//// &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;//// &lt;/table&gt; 如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。 123456789// 写法一let str = 'return ' + '`Hello $&#123;name&#125;!`';let func = new Function('name', str);func('Jack') // "Hello Jack!"// 写法二let str = '(name) =&gt; `Hello $&#123;name&#125;!`';let func = eval.call(null, str);func('Jack') // "Hello Jack!" 实例：模板编译下面，我们来看一个通过模板字符串，生成正式模板的实例。 1234567let template = `&lt;ul&gt; &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt;`; 上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%...%&gt;放置 JavaScript 代码，使用&lt;%= ... %&gt;输出 JavaScript 表达式。 怎么编译这个模板字符串呢？ 一种思路是将其转换为 JavaScript 表达式字符串。 1234567echo('&lt;ul&gt;');for(let i=0; i &lt; data.supplies.length; i++) &#123; echo('&lt;li&gt;'); echo(data.supplies[i]); echo('&lt;/li&gt;');&#125;;echo('&lt;/ul&gt;'); 这个转换使用正则表达式就行了。 12345678let evalExpr = /&lt;%=(.+?)%&gt;/g;let expr = /&lt;%([\s\S]+?)%&gt;/g;template = template .replace(evalExpr, '`); \n echo( $1 ); \n echo(`') .replace(expr, '`); \n $1 \n echo(`');template = 'echo(`' + template + '`);'; 然后，将template封装在一个函数里面返回，就可以了。 1234567891011121314let script =`(function parse(data)&#123; let output = ""; function echo(html)&#123; output += html; &#125; $&#123; template &#125; return output;&#125;)`;return script; 将上面的内容拼装成一个模板编译函数compile。 12345678910111213141516171819202122232425function compile(template)&#123; const evalExpr = /&lt;%=(.+?)%&gt;/g; const expr = /&lt;%([\s\S]+?)%&gt;/g; template = template .replace(evalExpr, '`); \n echo( $1 ); \n echo(`') .replace(expr, '`); \n $1 \n echo(`'); template = 'echo(`' + template + '`);'; let script = `(function parse(data)&#123; let output = ""; function echo(html)&#123; output += html; &#125; $&#123; template &#125; return output; &#125;)`; return script;&#125; compile函数的用法如下。 1234567let parse = eval(compile(template));div.innerHTML = parse(&#123; supplies: [ "broom", "mop", "cleaner" ] &#125;);// &lt;ul&gt;// &lt;li&gt;broom&lt;/li&gt;// &lt;li&gt;mop&lt;/li&gt;// &lt;li&gt;cleaner&lt;/li&gt;// &lt;/ul&gt; 标签模板模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 123alert`123`// 等同于alert(123) 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 123456let a = 5;let b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;// 等同于tag(['Hello ', ' world ', ''], 15, 50); 上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。 函数tag依次会接收到多个参数。 123456789function tag(stringArr, value1, value2)&#123; // ...&#125;// 等同于function tag(stringArr, ...values)&#123; // ...&#125; tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。 tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。 tag函数所有参数的实际值如下。 第一个参数：[&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;] 第二个参数: 15 第三个参数：50 也就是说，tag函数实际上以下面的形式调用。 1tag(['Hello ', ' world ', ''], 15, 50) 我们可以按照需要编写tag函数的代码。下面是tag函数的一种写法，以及运行结果。 1234567891011121314151617181920let a = 5;let b = 10;function tag(s, v1, v2) &#123; console.log(s[0]); console.log(s[1]); console.log(s[2]); console.log(v1); console.log(v2); return "OK";&#125;tag`Hello $&#123; a + b &#125; world $&#123; a * b&#125;`;// "Hello "// " world "// ""// 15// 50// "OK" 下面是一个更复杂的例子。 123456789101112131415161718let total = 30;let msg = passthru`The total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`;function passthru(literals) &#123; let result = ''; let i = 0; while (i &lt; literals.length) &#123; result += literals[i++]; if (i &lt; arguments.length) &#123; result += arguments[i]; &#125; &#125; return result;&#125;msg // "The total is 30 (31.5 with tax)" 上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。 passthru函数采用 rest 参数的写法如下。 12345678910function passthru(literals, ...values) &#123; let output = ""; let index; for (index = 0; index &lt; values.length; index++) &#123; output += literals[index] + values[index]; &#125; output += literals[index] return output;&#125; “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。 123456789101112131415161718let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; let s = templateData[0]; for (let i = 1; i &lt; arguments.length; i++) &#123; let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, "&amp;amp;") .replace(/&lt;/g, "&amp;lt;") .replace(/&gt;/g, "&amp;gt;"); // Don't escape special characters in the template. s += templateData[i]; &#125; return s;&#125; 上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。 12345let sender = '&lt;script&gt;alert("abc")&lt;/script&gt;'; // 恶意代码let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;message// &lt;p&gt;&amp;lt;script&amp;gt;alert("abc")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt; 标签模板的另一个应用，就是多语言转换（国际化处理）。 12i18n`Welcome to $&#123;siteName&#125;, you are visitor number $&#123;visitorNumber&#125;!`// "欢迎访问xxx，您是第xxxx位访问者！" 模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。 123456789// 下面的hashTemplate函数// 是一个自定义的模板处理函数let libraryHtml = hashTemplate` &lt;ul&gt; #for book in $&#123;myBooks&#125; &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt; #end &lt;/ul&gt;`; 除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。 123456789jsx` &lt;div&gt; &lt;input ref='input' onChange='$&#123;this.handleChange&#125;' defaultValue='$&#123;this.state.value&#125;' /&gt; $&#123;this.state.value&#125; &lt;/div&gt;` 上面的代码通过jsx函数，将一个 DOM 字符串转为 React 对象。你可以在 Github 找到jsx函数的具体实现。 下面则是一个假想的例子，通过java函数，在 JavaScript 代码之中运行 Java 代码。 12345678java`class HelloWorldApp &#123; public static void main(String[] args) &#123; System.out.println(“Hello World!”); // Display the string. &#125;&#125;`HelloWorldApp.main(); 模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。 12console.log`123`// ["123", raw: Array[1]] 上面代码中，console.log接受的参数，实际上是一个数组。该数组有一个raw属性，保存的是转义后的原字符串。 请看下面的例子。 1234567tag`First line\nSecond line`function tag(strings) &#123; console.log(strings.raw[0]); // strings.raw[0] 为 "First line\\nSecond line" // 打印输出 "First line\nSecond line"&#125; 上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[&quot;First line\nSecond line&quot;]，那么strings.raw数组就是[&quot;First line\\nSecond line&quot;]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\n视为\\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。 String.raw()ES6 还为原生的 String 对象，提供了一个raw方法。 String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。 12345String.raw`Hi\n$&#123;2+3&#125;!`;// 返回 "Hi\\n5!"String.raw`Hi\u000A!`;// 返回 "Hi\\u000A!" 如果原字符串的斜杠已经转义，那么String.raw会进行再次转义。 12String.raw`Hi\\n`// 返回 "Hi\\\\n" String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。 String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。 12345String.raw(&#123; raw: 'test' &#125;, 0, 1, 2);// 't0e1s2t'// 等同于String.raw(&#123; raw: ['t','e','s','t'] &#125;, 0, 1, 2); 作为函数，String.raw的代码实现基本如下。 12345678910String.raw = function (strings, ...values) &#123; let output = ''; let index; for (index = 0; index &lt; values.length; index++) &#123; output += strings.raw[index] + values[index]; &#125; output += strings.raw[index] return output;&#125; 模板字符串的限制前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。 举例来说，标签模板里面可以嵌入 LaTEX 语言。 1234567891011function latex(strings) &#123; // ...&#125;let document = latex`\newcommand&#123;\fun&#125;&#123;\textbf&#123;Fun!&#125;&#125; // 正常工作\newcommand&#123;\unicode&#125;&#123;\textbf&#123;Unicode!&#125;&#125; // 报错\newcommand&#123;\xerxes&#125;&#123;\textbf&#123;King!&#125;&#125; // 报错Breve over the h goes \u&#123;h&#125;ere // 报错` 上面代码中，变量document内嵌的模板字符串，对于 LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。 模板字符串会将\u00FF和\u{42}当作 Unicode 字符进行转义，所以\unicode解析时报错；而\x56会被当作十六进制字符串转义，所以\xerxes会报错。也就是说，\u和\x在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。 为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。 12345function tag(strs) &#123; strs[0] === undefined strs.raw[0] === "\\unicode and \\u&#123;55&#125;";&#125;tag`\unicode and \u&#123;55&#125;` 上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为undefined，但是raw属性依然可以得到原始字符串，因此tag函数还是可以对原字符串进行处理。 注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。 1let bad = `bad escape sequence: \unicode`; // 报错]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>实录</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量的解构赋值]]></title>
    <url>%2Fit233.github.io%2F2018%2F12%2F05%2F%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[数组的解构赋值基本用法ES6 允许按照一定模式，从数据和对象中提取值，对变量进行赋值，这被称为解构（Destructuring） 之前，为变量赋值，只能为变量一个个地直接指定值，如： 123let a = 1;let b = 2;let c = 3; ES6 之后允许写成： 1let [a, b, c] = [1, 2, 3]; 上面代码表示，从数组[1,2,3]中取值，按照对应位置,分别给变量a，b，c进行赋值 本质上，这种写法属于“匹配模式”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 嵌套赋值如下代码 1234let [a,[b,c]] = [1,[2,3]]a//1b//2c//3 这里代码结构互相嵌套，数组里面嵌套数组，不过只要能够在右边结构中找到相对应的位置，依然能够赋值成功 不完全解构12345678910let [,,d] = [1,2,3,4]d//3let [e] = [1,2,3,4]e//1let [a] = [[1,2]]a//[1,2] 如上代码所展示，等号两边结构模式相同（都为数组），那么就会根据左边的结构，在右边的结构中寻找对应位置的值进行赋值 但是，如果分析右边结构之后，找不到与之对应的值，那么该位置的变量则为undefined: 123let [a,b] = [[1,2]]a//[1]b//undefined 以上两种情况都属于不完全解构，指的是虽然等号两边的模式都一样，但是数据结构却有不同，导致等号两边的结构并不能完全对应起来，但是这样并不影响解构赋值的使用。 这样一来的结果，就是如果能够在等号右边对应位置找到对应的值，那么左边的变量就会赋予该值，否则为undefined rest参数在结构赋值的时候，还支持rest参数，这样的参数能够在不完全结构的情况下，将所有值保存起来。 需要说明注意的是： rest参数必须放在所有参数的最后面，因为这是一个用来扫尾的参数，简单来说就是当左边参数不够接收右边元素的时候，右边还有剩余的元素，那么解构将会直接将剩余的元素原封不动全部丢给rest参数 根据第一条，rest参数必须是最后一个，所以也就是说，rest参数也只能有一个 rest参数写法如下： 123let [a,...b] = [1,2,3]a//1b//[2,3] 上面代码，等号左边采用了rest参数…b，表示匹配完之前的参数之后，等号右边剩余的所有元素直接给b（不论结构） 123456789let [,a,...b] = [1,2,[3,4]]a//2b//[3,4]let [a,...b] = [1,2,3,&#123;name:"小明"&#125;]a//1b//[2,3,Object],这个Object就是&#123;name:"1"&#125;//如下打印name值是"小明"console.log(b[2].name) 以上情况是在右边有多余元素的情况，那么假如右边元素少于左边参数： 123let [,a,...b] = [1,2]a//2b//[] 回想一下之前说的解构赋值，如果没有匹配的元素，其值就是undefined，但是这里的b在没有匹配到元素赋值的时候，确实一个空数组[] 简单解释一下： 既然我们的b是rest参数，也就是接收解构赋值的时候，需要考虑到，我们剩余的元素还有可能有多个，那么我们接受多个数组中的元素，自然是用数组来接收。 所以这个rest参数就是一个空数组，当解构完之后，右边元素还有剩余，就将元素按顺序一个一个地原封塞到rest参数中，而如果没有剩余元素了，那么就不用塞了，rest参数就保持一个空数组了 解构原理如果等号右边的解构不是一个可以遍历的解构(详情参考Iterator)，那么解构操作会报错 12345678let [a] = 1;let [b] = false;let [c] = NaN;let [d] = undefined;let [e] = null;let [f] = &#123;&#125;;//以上这些均会报错： is not iterable 以上的代码语句，等号右边的值，要么是转为对象以后不具备Iterator接口（前5个表单时），要么本身就不具备Iterator接口（第六个表达式） 也就是说右边的数据要能够进行循环 说道这里，就要说一下字符串类型了，先看下面代码： 123456let [a,b,c,d,...e] = "这是一个字符串"a//这b//是c//一d//个e//['字','符','串'] 其实说白了，字符串也就是一串字符，即多个字符的数组(集合)，按照一定顺序组成的一串文字。因此，在字符串解构赋值的时候，字符串被转换成了一个类似数组的对象 同时，对于set结构，也可以使用数组的结构赋值 12let [x, y, z] = new Set(['a', 'b', 'c']);x // "a" 事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值 12345678910function* hhh() &#123; let a = 0; let b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;let [a,b,c,d,e,f] = hhh();console.log(a,b,c,d,e,f)//0 1 1 2 3 5 以上代码，hhh()是一个Generator函数，原生具有Iterator接口，解构赋值会依次从这个接口获取值 默认值解构赋值能够制定默认值，也就是当没有找到对应的元素给其赋值的时候，会采取制定的值为其赋值 如： 123456789let [a = '1'] = []a//1let [b,c='3'] = [5]b//5c//let [d = '1'] = ['aaa']d//aaa 需要注意的是，ES6 内部使用雅阁想等运算符 (===)来判断一个位置是否有值。所以只有当一个数组成员严格等于undefined，默认值才会生效 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 如上面代码，一个值为null，默认值却没有生效，是因为null === undefined为false 另外，如果一个默认值是一个表达式（函数也属于一个表达式），那么这个表达式是惰性求值的，也就是只有在使用到这个表达式的时候，才会去运行求值 12345function f() &#123; console.log('aaa');&#125;let [x = f()] = [1]; 上面代码不会执行f()函数，因为x能够在右边取到值，不会触发默认值 默认值也可以引用解构赋值的其他变量，但是该变量必须是在引用之前已经声明的 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError: y is not defined 这个在之前的let &amp; const说过，就不赘述了 对象的解构赋值解构赋值不仅可以用于数组，还可以用于对象 基本用法1let &#123;a&#125; = &#123;a:"这是a"&#125; 对象的解构赋值其数组的解构赋值模式一样，不过要注意的是，对象的解构赋值，是匹配等号右边对象中的属性名来赋值 如上面代码，let{a} ，会在右边的对象中{}找a这个名字的属性，然后取值赋值给左边的a，如果右边对象中没有这个属性，那么就为undefined, 如下代码 1let &#123;a&#125; = &#123;b:"这是b,不是a"&#125; 同时，因为是按照对象的属性名进行匹配，所以并不是想数组一样要按照严格的顺序 1let &#123;a,b&#125; = &#123;b:"这是b,不是a",a:"这才是a"&#125; 而如果我们变量名与属性名不一致，但是还想要取到某个属性的值，我们可以这么写： 1let &#123;a:b&#125; = &#123;c:"这是c",a:"这才是a"&#125; 在上面代码中，b才是变量，左边的a只是为了对应右边属性a，是说b要取属性a的值，这样变量b就会赋予属性a的值：”这才是a” 这样来说，对象的解构赋值可以看成以下代码的简写： 123let&#123;a:a,b:b&#125; = &#123;a:"这是a",b:"这是b"&#125;//简写为：let&#123;a,b&#125; = &#123;a:"这是a",b:"这是b"&#125; 嵌套赋值与数组一样，对象解构也能用于嵌套结构 12345678910let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World" 不过要注意并且要明白的是：这里的p是模式，不是变量，因此不会被赋值， 如果p也要作为变量赋值，可以这么写： 1234567891011let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World"p // ["Hello", &#123;y: "World"&#125;] 更复杂一点的嵌套如下： 12345678910111213const node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // Object &#123;start: Object&#125;start // Object &#123;line: 1, column: 5&#125; 上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量 这种嵌套赋值几乎很少用，一般基本的赋值就能满足大部分应用需求 默认值对象的解构赋值也可以指定默认值 123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;;y // 3var &#123;x: y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong" 与数组默认值一样的是，想要默认值生效的条件也是对象的属性值严格等于undefined，属性值为null的时候并不会导致默认值生效 同时，如果解构失败，变量的值也会等于undefined，也能致使默认值生效 我们都知道，数组本质就是一个特殊的对象，因此可以对数组进行对象属性的解构： 1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3 注意 如果解构模式是签到的对象，而且子对象所在的父属性不存在，那么将会报错 12// 报错let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;; 这里简答说明一下： 按照解构流程，我们会根据解构模式去对象中匹配foo属性（此属性根据解构模式来看也是一个模式（即对象）），而此时对象中没有foo属性，那么这个对象就是undefined，而我们再看解构模式中，要取的是该模式（foo）的属性bar，所以就应该是foo.bar，但是此时foo对象为undefined，故报错 还要注意的一点是，如果想要将一个已经声明的let变量用于对象解构赋值，必须要非常小心，先看如下代码： 1234// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 这个写法错误的原因是，我们用let声明了一个变量x，然后在{x}中使用这个变量，但是实际上JavaScript引擎会将{x}理解成一个代码块，这样就会发生语法上的错误。 如何解决这样的问题，我们可以不将大括号写在首行，这样可以避免将其解释为代码块 12let x;(&#123;x&#125; = &#123;x: 1&#125;); 对于这一点，接下来进行解释： 圆括号的问题解构赋值虽然很方便，但是解析起来并不容日，对于编译器来说，一个式子到底是模式，还是表达式，从一开始是不知道的，只有等到解析的时候（解析到或者解析不到等号）才能知道 由此带来的问题是，如果模式中出现圆括号怎么处理 ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号 但是这条规则实际上不那么容易辨别，处理起来也相当麻烦。因此，如果可能，尽量不要在模式中放置圆括号 不能使用圆括号以下解构赋值不能使用圆括号 #### 变量赋值语句 12345678let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 以上6个语句都会报错，因为他们都是变量声明语句，模式不能使用圆括号 #### 函数参数 要知道函数参数也是属于变量声明，因此不能带有圆括号 1234// 报错function f([(z)]) &#123; return z; &#125;// 报错function f([z,(x)]) &#123; return x; &#125; 赋值语句的模式123// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5]; 上面代码将整个模式放在圆括号之中，导致报错。 12// 报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; 上面代码将一部分模式放在圆括号之中，导致报错。 可以使用圆括号可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号 123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 上面三行语句可以正确执行， 其一、因为首先他们都是赋值语句，而不是生命语句 其二、他们的圆括号部分都不属于模式的一部分 第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象，然后在进行对象解构赋值 123let &#123;a,toString:b&#125; = 123a//undefinedb//b是function toString()&#123;.....&#125;, 这里的b是一个函数，是Number.prototype.toString指向的函数toString(){} 相应地，数字可以转为Number对象，那么布尔值也有对象Boolean 1let &#123;toString: s&#125; = true; 这里的s跟b一样，不过s是Boolean.prototype.toString 解构赋值的规则是，只要等号右边的值不是对象或者数组，就先将其转为对象，然后在进行对象解构赋值 不过要注意的是undefined和null都无法转为对象，所以对他们进行解构赋值，都会报错 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值函数的参数也可以使用解构赋值 12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。 下面是另一个例子。 12[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 默认值函数参数的解构也可以使用默认值 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。 从另一个角度来讲，如下的代码也是一种设置默认值的方式，但是却与上面的代码有很大差别： 12345678function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以当在整个参数为undefined的时候，才会致使默认值生效，所以会得到与前一种写法不同的结果。 解构赋值的用途变量的结构赋值用途很多，以下几个场景就能体验其优点： 变量值互换1234let x = 1;let y = 2;[x, y] = [y, x]; 如果按照以前的方式，我们还需要通过第三方中间量来帮助进行互换，而使用解构赋值的方式，可以直接进行变量值的交换，这样的写法不仅简介，而且易读，语义非常清晰 从函数返回多个值我们都知道，想要一个函数返回多个值的话，我们需要利用数组或者对象，将着多个值借助数组或者对象带出来。不过比较麻烦的是，取值的问题。而有了解构赋值，那么取值的时候就会非常方便 12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据在解析JSON对象的数据时，解构赋值就显得尤为便利了 12345678910let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] 函数参数的默认值我们应该这么做过，为了保证代码容错性，经常需要对函数的入参进行验证，防止出现空指针的异常 而我们通过解构赋值来给函数参数指定默认值，就不需要再在函数中判断参数，然后再给默认值的代码了 1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125; = &#123;&#125;) &#123; // ... do stuff&#125;; map结构的循环遍历我们都知道，想要获取map的值要通过key来获取，而map的key一般可以是没有任何规律，所以想要循环就不会像数组那样简单。 不过我们可以通过解构赋值来方便低解决这个问题 Map结构原生支持Iterator接口，配合变量的解构赋值，获取key和value就如下： 1234567const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125; 输入模块的指定方法加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰 1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map"); 这些场景下，能够使用变量的解构赋值，都会是一种很便捷的方法，足以体现出解构赋值的强大]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>实录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[let&const]]></title>
    <url>%2Fit233.github.io%2F2018%2F12%2F04%2Flet%26const%2F</url>
    <content type="text"><![CDATA[let命令简述 ES6新增了let命令用来生命变量，而在之前写js的时候，我们都习惯了使用var，而let的用法也与之相似。 而存在了var命令来声明变量，为什么还要有let命令。 众所周知，使用var的话会出现很多的问题，如变量提升导致的各种赋值、取值的错误问题等等，想必前端的这类问题遇到不少。 为了有效的规避此类的问题，特推出了let命令。使用let声明的变量，只会在let命令所在的代码块内有效，也就是除了包含let命令的作用域，其他地方是访问不到这个变量的 代码实验下面实录实验代码 先来看一下var命令声明的变量 1234&#123; var a = 10&#125;console.log(a) //10 这个代码运行之后，能够打印出a的值为10，然而我们的变量a是在{}区域中定义的，而console.log(a)是在该区域外面访问a，也就是在上一级调用低级区域中的变量，但是依然能够进行访问 再来看一下let 12345&#123; let a = 10 console.log(a)//10&#125;console.log(a)//ReferenceError: a is not defined 这个代码运行第三行会打印10，而第5行会报错：ReferenceError: a is not defined 这就是let的作用，在{}区域中定义的a，在该区域外（上级区域）是无法访问到该变量的，这样就不存在变量提升的问题了,而a变量也就只能作用在｛｝区域中 问题研究 然后给大家展示一个很有趣的问题 12345678910var b = 0;for(var a = 0;a &lt;10;a++)&#123; setTimeout(() =&gt; &#123; b += a; console.log("for-"+a+":"+b) &#125;, 1000);&#125;var a = 5;b+=a;console.log("0-9累加总和+5为："+b) 按照正常逻辑，我们这块代码是要进行统计0-9累加的和，我们分析这段代码： 先声明变量b为0，方便最后保存总和 写for循环，进行0-9的累加 然后定义变量a=5，b计算完之后再累加5，然后输出结果 正常逻辑算下来应该是45+5 = 50 结果呢？ 我想，和我一样先学java后来学js的人，起初很痛苦吧。为什么呢？为什么呢？ 这个具体如何解释我也不太能理解，到底for循环的a与后面定义的a是否同一个？还是后面定义的把之前的给覆盖掉了？分不太清，只知道在等1s之后，执行b+=a的时候，拿到的a是5，最后赋值为5的那个a 除此之外，还有一个比较好玩的是：把后面var a = 5去掉，又会出现另一个问题 分析解释 实验之前的那个循环把var改成let，会出现什么情况 12345678910var b = 0for(let a = 0;a &lt;10;a++)&#123; setTimeout(() =&gt; &#123; b += a console.log("for-"+a+":"+b) &#125;, 1000);&#125;var a = 5;b+=a;console.log("0-9累加总和+5为："+b) 虽然顺序有问题（setTimeout()函数异步延时），但是最终结果是正确的 好了，我们来看一下之前说的去掉后面定义的var会出现什么问题 var： 123456for(var a = 0;a &lt;10;a++)&#123; setTimeout(() =&gt; &#123; console.log("for-"+a) &#125;, 1000);&#125;console.log() 为了方便，我们只保留了循环，结果如下 let： 123456for(let a = 0;a &lt;10;a++)&#123; setTimeout(() =&gt; &#123; console.log("for-"+a) &#125;, 1000);&#125;console.log() 结果： 为什么会出现这样的情况，别急，我们来调试一下看看会不会发现什么： 我们先来看看var： 断点就打在第一行，for，然后启动调试，注意看变量这块 在这里要说一下刚刚大家能够看到，我们这张图是启动调试之后未做任何操作的第一张图，但是这时候Local中就已经存在了a，这是为什么？是node.js在遇到变量声明的时候，会将声明放在第一行，先声明变量，然后在继续执行 当我们走到第二行，那么a就创建成功了，我们来观察变量看看有什么值得注意的？ 看到Local下面a。这是本地变量。而之前为undefined，通过第一行的赋值之后(声明被提升到了上面，所以第一行只完成了一个赋值)，它的值是0 接下来我们一直调试到第六行，然后能发现这个情况： 然后我们放开调试，直接执行到底 然后我们来看看let 调试走一步 这里出现了Block：这是块级作用域，ES6新加的，后面会说到。这就是不同，这样就说明这个for中声明的a就是只能作用在这个块中，其他地方用不了，也拿不到，所以结果是，不说了。都知道了 唯一性 大家应该知道，使用var命令声明的变量，任何时候都可以重复声明，而所有变量都是指向同一个全局变量 123var a = 0console.log(a) //0var a = 10 而使用let命令声明的变量却不同，也就是说let声明的变量只能有一个，不能与已存在的变量重名 123var a = 0console.log(a)let a = 10 //SyntaxError: Identifier 'a' has already been declared 不只是在之后声明，在之前声明也是报错（为什么?已经解释过了）： 123let a = 0console.log(a)var a = 10 //SyntaxError: Identifier 'a' has already been declared 总结 var指令 var声明的变量a，在全局范围内都有效，所以全局只有一个变量a 在循环中，每一次循环，变量a的值都会发生改变，如果a的声明执行为var，循环内的a指向的就是全局的a 使用var指令如果先声明了一个变量a，之后又使用var指令声明一个变量a，这个时候不会报错，两个变量a都是指向同一个变量，也只有一个变量a var声明的变量a，在任何时候调用的，都是当前a的值，也就是我们使用setTimeOut（）延时调用a的时候，所有a都是最后一个值 var命令会发生变量提升现象，即在变量声明之前可以使用，不过值为undefined。也就是之前说的，node.js执行代码之前，先把var声明的变量都提升到最前面，先声明所有变量，值为undefined，在继续执行后面的代码，遇到赋值的时候就赋值，调用的时候就调用 let指令 let指令声明的a，只在当前当前的作用域内有效 在循环中，let声明的a，只在本轮循环中有效，所以每次循环的a其实都是一个新的变量 每次循环的a都是新的变量，却能够知道上一轮循环a的值，是因为JavaScript引擎内部会记住上一轮循环的值，初始化本轮的变量a时，就在上一轮循环的基础上进行计算 for循环的特别之处：设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域 使用let声明的变量，不会发生变量提升，所以在声明它之前，该变量相当于(为什么是相当于，看完后面希望理解)是不存在的，如果在声明之前调用该变量，会报错 使用let声明的变量，在同一个区域之中是唯一的，即无论以哪种形式声明了变量a，在该区域中之后的代码里都无法再使用let声明变量a 暂时性死区简述 所说的暂时性死区，就是在let命令声明变量之前，该变量都是不可用的，这一部分代码区间就称为暂时性死区 例如有一段代码，有一块区域占据总代码的第10~30行，其中有let命令声明的变量在该区域的第20行，那么这块区域的第10~20行就是该变量的“暂时性死区”（temporal dead zone，TDZ） 变量绑定区域与TDZ所谓的变量绑定区域，就是指如果一个块级作用域内存在let命令声明的变量a，那么这个变量就会绑定这个区域，并且不会再受到外部的影响，及时在外部又声明了与该变量相同名称的变量a，也不会影响到这个区域中的变量a 如： 12345var a = 0&#123; console.log(a)//0 var a = 10&#125; 在这段代码中，存在一个var命令的变量a，但是在块级区域的代码中又进行了一次变量a的声明(var)，这样的代码是可以通过的 但是有这种情况： 12345var a = 0&#123; console.log(a) let a = 10 //ReferenceError: a is not defined&#125; 这里有两点：变量绑定区域以及暂时性死区 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就是用这些变量的，就会报错 所以在代码行2~5这个区块之间，存在let声明的变量a，那么1声明的变量a对于2~5这个区块就是无效的，因为let a已经绑定了这个区块，同时因为let变量的唯一性，不允许var变量再来插足。而2~4行，就是let a的死区，是无法调用变量a的 “暂时性死区”也就意味着typeof不再是一个百分之百安全的操作 下面为对比代码： 1234567console.log(typeof a) //undefinedvar a = 0&#123; console.log(typeof b) //undefined console.log(typeof a) //报错：ReferenceError: a is not defined let a = 10&#125; 这里的代码能够看得出来 var变量因为变量提升，所以在声明代码之前就能调用，只不过是undefined 如果没有声明的变量，他就是undefined 但是let变量在声明之前，虽然也是undefined，但是规定在死区中是无法调用的，会报错 配图如下： 关于隐蔽死区的示例示例一、函数入参12345function fun(x = y, y = 2)&#123; //ReferenceError: y is not defined return [x,y]&#125;a = fun()console.log(a) 以上代码的意思就是定义一个函数，这个函数有两个参数，x和y 并且给两个参数默认值，x的默认值是y的值，y的默认值是2 这里会报错:ReferenceError: y is not defined(可能某些情况下不会报错) 为什么会报错，简单说一下： 首先，这里报错y，是第一个参数的x = y这里报错，这里的y未找到 为什么？因为在这个fun()的区块中，有声明y，不过是第二个参数声明的，所以在第一个参数调用就是y的死区， 如果将两个参数互换一下位置，那么这段代码就能正确执行了 12345function bar(y = 2 , x = y)&#123; return [x,y]&#125;a = bar()console.log(a) //Array(2) [2, 2] #### 实例二、声明赋值 1234var a = aconsole.log(a) //undefinedlet b = b //ReferenceError: b is not definedconsole.log(b) 这里依旧是死区的问题，上面的对比代码，var a= a赋值的时候运行正常，是因为var变量没有死区的 而let b = b报错，是因为=后的b属于调用变量b，而这个区块中有声明b的let命令，所以在b没有完全声明之前调用了b，这就是一个死区 块级作用域在ES5中只有全局作用域和函数作用域，没有块级作用域，这样会带来很多问题： 问题一、内层变量可能会覆盖外层变量12345var a = new Date();function fun()&#123; console.log(a) //Wed Dec 05 2018 14:21:35 GMT+0800 (中国标准时间) &#123;&#125;&#125;fun() 而如果是这样： 123456var a = new Date();function fun()&#123; console.log(a) //undefined var a = 123&#125;fun() 为什么会这样呢？是因为变量提升，由于在fun()中也有声明a变量，所以a变量的声明就提升到了函数最顶端进行声明，这时候a就是undefined，这个时候是因为fun()的a覆盖了上层的a 问题二、区块变量泄露为全局变量12345var s = 'abcdefg'for(var i = 0;i&lt;s.length;i++)&#123; console.log(s[i])&#125;console.log(i) //7 这里在循环结束之后，i的值依然存在，还是能够获取到 ES6的块级作用域let实际上是为JavaScript新增了块级作用域 示例代码： 12345678910111213141516function fun()&#123; var a = 5 if(true)&#123; var a = 10 &#125; console.log("a:",a)&#125;function fun2()&#123; let b = 5 if(true)&#123; let b = 10; &#125; console.log(b)&#125;fun()//10fun2()//5 从这段代码的执行结果能够看得出来，var变量内层变量会影响到上层变量，但是let变量却不会 之前说过，let变量是绑定区域的，所以在一个区域中，同样的变量（名字相同）只会存在一个 而如果下层let变量与上层let变量同名的话，不会互相影响，采用就近原则 同时块级作用域的出现，也使得立即执行函数表达式不再必要了 块级作用域与函数声明函数能不能在块级作用域之中声明？ ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域中声明 如下代码： 123456789101112if (true) &#123; function fun() &#123; console.log("fun") &#125;&#125;try &#123; function fun2() &#123; console.log("fun2") &#125;&#125; catch (e) &#123; console.log(e)&#125; 其实以上两种函数声明，根据ES5的规定都是非法的 但是浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上米昂两种情况实际上都能运行，不会报错。 而ES6引入了块级作用域，明确允许在块级作用域之中声明函数 同时，ES6规定，块级作用域之中。函数声明语句的行为类似于let，在块级作用域之外不能被引用 除此之外：需要注意的是，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响，为了减轻因此产生的不兼容问题，ES6在附录B里规定，浏览器的实现可不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数 函数声明类似于var，即会提升到全局作用域或函数作用域的头部 同时，函数声明还会提升到所在的块级作用域的头部 注意：上面三条规则只对ES6的的浏览器有效，其他环境的而实现不用遵守，还是将块级作用域的函数声明当作let处理 所以，考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数， 如果确实需要，也应该写成函数表达式，而不是函数声明语句： 123456789101112131415&#123; //函数声明语句 let a = 'abcdefg' function f() &#123; return a &#125;&#125;&#123; //函数表达式 let b = 'abcdefg' let fu = function fun() &#123; return b &#125;&#125; 注意： 我们都知道，写块级（如if，循环），如果区域中只有一行代码，可以省略大括号 但是在块级作用域声明函数，即使如这样形式的函数： function fun(){} 这也不是代表只有一行代码，所以如果在块级作用域声明函数，如果没有块级作用域的大括号，会报错 const命令基本用法const是声明一个常量，这个常量是只读的，就是能够读取其值，但是不能改变它的值 const常量注意点1. 常量一旦声明之后，就不能改变123const a = 0;a = 3;// TypeError: Assignment to constant variable. 2.常量的值必须在声明的时候就立即初始化，不能留到以后赋值12const a;// SyntaxError: Missing initializer in const declaration const命令####１.作用域 const的作用域与let命令相同：只在声明所在的块级作用域有效 2.暂时性死区const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明之后使用 3.唯一性const声明的常量,也与let一样,在同一块级区域中不可重复声明，具有唯一性 const本质题外话做过后台，有研究过常量的人，应该知道，所说的常量，指的就是这个变量在栈中保存的值不会改变。而如果是指向某个对象的话，那么就是执行某个对象的地址不能改变，而对象中的属性可以随意改变。 简述const实际上也是如此，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的书怒不得改动。 对于简单类型的数据（数值、字符创、布尔），值就保存在变量指向的那个内存地址，因此等同于常量。 但是对于符合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保持这个指针是固定不变的（总是指向某一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了 如下代码： 123456const a = &#123;&#125;;// 为 a 添加一个属性，可以成功a.prop = 123;a.prop // 123// 将 a 指向另一个对象，就会报错a = &#123;&#125;; // TypeError: "a" is read-only 1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 ### 扩展 冻结对象如果真的想将对象冻结，即对象已经创建，其数据结构不能改变，要用Object.freeze方法 12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 除此之外，如果还要将对象的属性冻结，下面代码是一个能够将对象彻底冻结的函数 12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; 原理就是如果对象的属性还是对象的话，就递归调用，将这个对象冻结，直到所有对象属性全部被冻结 ES6 声明变量的六种方法ES5只有两种声明变量的方法：var命令和function命令。 ES6除了添加let和const命令，还有另外两种声明变量的方法：import命令和class命令 顶层对象顶层对象的属性顶层对象，在浏览器环境指的就是window对象，在Node指的就是global对象 ES5之中，顶层对象的属性与全局变量是等价的 12345window.a = 1;a // 1a = 2;window.a // 2 这个代码，顶层对象的属性赋值与全局变量的赋值，是同一件事，也就是说全局变量 就是 顶层对象的属性 顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。 这样的设计带来几个很大的问题： 首先是没法在编译时就报出变量未声明的错误，只有运行时材能知道（因为全局变量很可能是顶层对象的属性创造的，而属性的创造是动态的） 其次，程序员很容易不知不倦就创建了全局变量 最后，顶层对象的属性是导出可以有读写的，这非常不利于模块化编程 另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的 ES6为了改变这一点， 一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性 另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性 也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined 这段代码中，全局变量a由var命令声明，所以它是顶层对象的属性； 全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined global对象ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的 浏览器里面，顶层对象是window，但是Node和Web Worker没有window 浏览器和Web Worker里面，self也指向顶层对象，但是Node没有self Node里面，顶层对象是global，但其他环境都不支持 同一段代码为了能够在各种环境都能取到顶层对象，现在一般是使用this变量，但是有局限性： 全局环境中，this会返回顶层对象。但是Node模块和ES6模块中，this返回的是当前模块 函数里面的this，如果函数不是作为对象的方法运行，而是淡村作为函数运行，this会指向顶层对象。但是严格模式下，这时this会返回undefined 不管是严格模式还是普通模式，new Function(‘return this’)()总会返回全局对象。但是如果浏览器用了CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法可能无法使用 综上所述，很难找到一种方法，可以在所有情况下都渠道顶层对象。 下面是两种勉强可以使用的方法 12345678910111213141516// 方法一(typeof window !== 'undefined' ? window : (typeof process === 'object' &amp;&amp; typeof require === 'function' &amp;&amp; typeof global === 'object') ? global : this);// 方法二var getGlobal = function () &#123; if (typeof self !== 'undefined') &#123; return self; &#125; if (typeof window !== 'undefined') &#123; return window; &#125; if (typeof global !== 'undefined') &#123; return global; &#125; throw new Error('unable to locate global object');&#125;; 现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。 垫片库system.global模拟了这个天，可以在所有环境拿到global 12345// CommonJS 的写法require('system.global/shim')();// ES6 模块的写法import shim from 'system.global/shim'; shim(); 上面代码可以保证各种环境里面，global对象都是存在的。 123456// CommonJS 的写法var global = require('system.global')();// ES6 模块的写法import getGlobal from 'system.global';const global = getGlobal(); 上面代码将顶层对象放入变量global]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>实录</tag>
        <tag>let</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java整型封装类Integer的比较]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F29%2Fjava%E6%95%B4%E5%9E%8B%E5%B0%81%E8%A3%85%E7%B1%BBInteger%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！ 一、浅说（这里说的是废话）数字类型​ 我们日常中经常会使用的数字来进行各种计算，比如1，2，3等这些自然数，当然这些自然数都是整的，不会像小数1.1，2.5，3.21等等这样有小数点的零散的小数，这些大于0的数字都被称为正数。 ​ 当然，有大于必然会有小于，所以那些小于0的数字被称为负数，如-1，-2，-3，-5.33，-7.4等 ​ 而在这些负数中也是跟正数一样，除了代表小于0的负号（-）之外，其他都一样，有的像1，2，3一样没有小数点，有的却有小数点，这样我们可以把所有数字分为整数和小数 java中代表数字的类型​ 这些最基本的知识点，就不在这过多介绍，简单提一下 整型：java中的整型就是上面我们说的整数，java中整型的数据类型有这么几个byte、short、int、long 浮点型：浮点型，说的就是带有小数点的小数了，java中浮点型的数据类型有flot、double 这里就简单过一下，今天我们要说的并不是这几个数据类型，而是另一种 引子上面所说的数据类型，都是java中的基本数据类型，也就是这门语言出生就定义好的类型。占用的内存空间比较小，用起来也比较方便。 但是，尽管如此，依然会有它自己的缺陷。我们应该都知道，其实在项目中用的比较多的并不是这些基本数据类型，而是它们的封装类 为什么要用开销更大的封装类，而不是这些基本类型? 最简单的一个问题，在一个类中的属性，定义一个整型变量，那么这个变量会有一个默认值0，这个时候，这个0到底是传递过来的值就是0呢？还是因为没有给这个它赋值的默认值呢？ 如果你说自己赋值自己不知道吗？那么项目中一般拿值都会从前端传递过来，这个时候在程序运行的过程中，我们又怎么知道这个值是前端传过来就是0呢？还是因为前端没有传所以默认值为0了呢？ 好了，简单讨论，所以我们能看出来，基本数据类型有时候并不能满足一些需求，所以这些基本数据类型的封装类（升级版）就来了。 今天我们要说的是整型int的封装类（Integer） 二、由该话题引发的补充疑问我想应该有人在初学的时候，有人会告诉你，Integer类型进行值比较的时候，要用equalse()方法进行比较，但是有时候我们却还是用==进行比较，你会发现，有的时候==比较两个相同数字的Integer对象，返回的是true，有的时候却是false，接下来会详细说明 == 和 equals()这里在简单提一下二者的区别 首先，==比较的是两个值，而equals()比较的是两个内容 我想我提出的这个概念会有很多人不解甚至会喷，因为大部分人都有这样根深蒂固的概念： ==比较的是地址，equals比较的是值 这么说也不能算错吧，毕竟大多数人都是这么说的。 而我有一点疑问提出来，就是这种说法的不严谨： 我们都知道，地址一般是对象才有，也就是说我们存在堆中的对象才会有指向这个对象在堆中实际位置的地址，而我们把这个地址会存在一个变量中，而这个变量中的值，就是这个地址，这个值也是存在栈中的 对此，所以人都说==比较的是地址，而equals比较的是值 那么我想问一下，这样的说法置基本数据类型byte、short、int、long、double、float于何地？他们有指向堆中对象的地址吗？ 所以说，我觉得存在栈中的不管是指向对象的地址，还是基本数据类型本身的值，都是这个变量存储的值，而存在于堆中的真正对象，保存的就是这个对象的内容（包括其拥有的属性、行为方法等，都是这个对象的内容） 如果你有更有助于自己理解的概念，那更好 好了，上面的说法可能跳的有点快，不过没办法，这里是要说封装类Integer，关于虚拟机的内存模型，这里就不细说了 三、实验实录好了，扯了那么多，还没真正进入话题，想喷就喷吧 问题现象现在来说一下这个问题的现象： 1. 先看int123int a = 1;int b = 1;System.out.println("int a == int b 结果："+(a == b)); 这个结果不用多考虑，为true是吧？ 2. 再看Integer123Integer c = 1;Integer d = 1;System.out.println("Integer c == Integer d 结果："+(c == d)); 好，按照我们之前说的，==比较的是c和d的值（栈中的值）， 那么这里分析下：我们创建一个Integer对象c，给这个对象赋值为1，然后我们又创建一个对象d，这个对象也赋值为1，然后用==比较c和d，我们比较的是两个对象存在栈中的地址，也就是c和d真正的值（指向对象的地址） 结果如何？ 吼，是true，好了，暂且到这，先不讨论，接下来看另一个实验： 3.再看一次Integer 瞧，我们看到了什么？ false唉，刚刚还是true的，为什么变成false了呢？ 问题依旧保留，我们来看看equals() 4.看看equals() 之前说了，equals()是比较两个对象内容是否完全一致 我们看看用equals比较这两种情况的结果 true，两个都是true，说明两个对象内容完全一致。 查找原因断点调试 我们一般遇到问题首先想到的是断点调试，这没问题，那么我们来走一波看看 打上断点，进入调试，然后分步来看，慢慢解析 注意看这张图的几个点，我们走到c、d两个Integer对象创建结束， 能够在Variables中看到，已经创建好了c、d两个对象，值都是1 注意看一下括号中，这里标明了c、d两个对象都是Integer对象，而这两个对象的记录编号都是525 ok，继续往下走 这里我们看到，有创建了e、f两个值为1111的Integer对象，记录编号分别是528，529 到此，我们应该能够看出来了吧 没错，在给Integer的两个对象都赋值为1的时候，c、d两个变量的值保存的地址是指向同一个对象的(525) 而赋值为1111的时候，两个变量的值保存的地址分别指向不同的（528和529） 这就是为什么c==d为true，而e==f为false 一步一步可以当是废话 到此，并没有结束，并不是找到为什么c==d为true，e==f为false是因为前者是同一个对象，而后者是不同对象就结束了。这也仅仅是看到了表象原因 由此，我们应该引发另一个问题：为什么同样是给Integer的对象赋值，都赋值为1的时候是同一个对象，而赋值为1111的时候确实两个不同的对象？ 这点是对于无从下手的人来说，思考到这里，我们应该怎么办？有经验的人肯定二话不说就去看源码去了，没错，答案肯定是在Integer的源码中。 刚进源码中又看了一眼，Integer类中有1600行左右的代码，我们怎么找？很头疼，是那些代码引起的上面的这个问题的？我们不知道。 这样我们该怎么办？有种无头苍蝇般的慌乱感吧？ 不用着急！我们可以利用ide断点调试中的一个小小的便利功能，有人注意到调试的时候，Variables视图中，我们每有一个行为调用，就会标识出这个行为以及其实体对象，下面看一组图，慢慢理解 我们能够看到，第一张图，也就是我给对象c赋值的时候所调用的行为方法就是编号为525的Integer对象的方法valueOf(int)—-对象d也是 第三张图为了更全面，我就展示了一下输出字符串的时候，其实这行代码的行为就是StringBuffer的toString方法，因为println()入参是String类型（拼接字符串的时候默认使用了StringBuffer来进行拼接，是为了效率，字符串的问题这里不讨论） 为了更全面，我们就举例三种，所以就又加了一个别的类型Date。能够在最后一张图看到，也有一个行为，是类加载行为。 可能大家都看到不同的对象的行为，ide给我们展示的信息也不同，甚至有些乱，不过那也是没有办法的，它只会给我们展示最近有影响的行为，如我们代码中Integer c = 1，其实这一行代码有这么几个行为：声明Integer对象c，实例化对象c，然后给c赋值，而我们上面展示的是最后一个给c赋值的valueOf(int)。 所以，如果有不知道该怎么去看源码的，可以借助这一点来去源码里面看一看，毕竟可以利用这一点找到跟我们程序有最直接关系的方法，然后以此为起点，慢慢往里看 查看源码在调试中我们能看到，调用Integer的时候调用了valueOf(int)这个方法，那就来看一下这个方法究竟有什么神奇的地方： 打开Integer类的源码，找到valueOf(int) 在Integer类的源码中，重载了多个valueOf方法，不过都是调用了valueOf(int i)的方法来处理的。所以我们只要看这个方法就可以了 在源码中能够看到：当赋值i在IntegerCache.low和IntegerCache.high之间（二者都包括）的时候，是直接返回已存在的IntegerCache.cache[index]中的值（某一个对象），否则才会新建！ 到了这一步，我想差不多应该已经明白是怎么回事了。 这里是Integer做的一个缓存，预先缓存一部分值，如果程序要使用的值在其中，那么直接就拿来用，否则的话才会新建一个对象赋值返回。 所以我们能够判断出来，当给Integer a赋值1的时候，是没有超出IntegerCache.cache的范围的，而1111则超出了，所以导致一种是相同对象，一种是不同对象的结果。 Integer中整数缓存不过这个范围到底是多少呢？ 那么既然提到这个问题了，我们就深究一下这个IntegerCache.cache到底怎么回事： 那么就来看看IntegerCache的源码： 在Integer类中有一个内部类，就是IntegerCache 这个类的作用就是为Integer类提供一部分int类型的缓存，避免了重复创建对象的麻烦。 下面请看源码： 在源码中我们能够看到，首先IntegerCache设定了缓存最小值为-128(对于这个值，我想大家应该已经猜到了什么) 没错，这是byte的最小临界点（最小值） 那么high不用想了，很大可能就是127了 当然，看了源码也能看到了，在静态块中经过处理，最大值high也是127 所以在valueOf中，入参i如果满足-128&lt;=i&lt;=127，那么返回的对象都是同一个，数组cache中的某一个，否则就是new 一个对象 所以就会出现如果Integer的值是在-128~127之间的时候用==判断为true，而其他的值==为false的现象 关于Integer缓存而对于Integer缓存大小的设置，也是可以自己设定的 因为java不是直接运行在本地操作系统上的，而是运行在jvm上的，我们可以通过配置更改jvm的运行参数来改变。 这个网上看看就好了，毕竟将缓存范围变大，那么意味着内存开销加剧，并且这部分缓存不会被gc回收的]]></content>
      <categories>
        <category>java</category>
        <category>数据类型</category>
        <category>整型</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jpa自动映射java实体类与数据库表]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F28%2Fjpa%E8%87%AA%E5%8A%A8%E6%98%A0%E5%B0%84java%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[​ 之前有说过jpa不实用实体类，那是某种特殊情况的时候的需要 ​ 而大多数的时候，我们后端代码还是需要有与数据库对应的实体类的 ​ 这样方便后端进行管理数据，而且更易于使用jpa框架 这次废话不多说，毕竟时间不多，简单做一些记录，反正对于这个框架还不太熟悉！有机会再来好好研究一番 下面直接说出如何去写，原理，实验什么的就先免了 实体类123456789101112131415@Data@NoArgsConstructor@AllArgsConstructor@Builder@Entity@Table(name = "ssprt_config",uniqueConstraints = &#123;@UniqueConstraint(name = "UK_SSPRTCONFIG_TYPE",columnNames = "type")&#125;)public class SsprtConfig &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = "type",length = 50) private String type; @Column(name = "value",length = 1) private Integer value;&#125; 简单解释： @Data：不用说了，就是getter、setter方法 @NoArgsConstructor：无参构造 @AllArgsConstructor：所有参数的构造 注意2和3两个注解，最好加上，因为我们利用jpa查询数据的时候，查完数据通过构造进行给实体类赋值，没有的话会报有关构造函数的错误 @Builder：builder创建对象，利用静态方法builder来创建对象，而不用new，提供链式setter赋值，方便快捷 @Entity：标注这是一个实体类，是一个与数据库映射的实体类 @Table：标注这个类所对应的数据库中的表名，同时，如果数据库中没有与之对应的表，会自动生成该表与之对应（这个要在配置文件中配置策略，不细说了，因为我也只是知道，并没有研究） name：不是必须的，如果没有，那么使用默认的该实体类的短类名。 uniqueConstraints：唯一键，指定某个列columnNames @Id：标注为主键 @GeneratedValue：主键生成策略， TABLE：使用表保存id值 IDENTITY：identitycolumn SEQUENCR ：sequence AUTO：根据数据库的不同使用上面三个 @Column：生命该字段与数据库表字段的映射关系， name指表字段名，length指数据长度，注意数据类型使用封装类]]></content>
      <categories>
        <category>java</category>
        <category>框架</category>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas-camera]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F21%2Fcanvas-camera%2F</url>
    <content type="text"><![CDATA[这里是运用canvas来实现电脑摄像头拍照的功能的js代码。 纯属个人兴趣 以下是个人封装的js，好坏皆是如此 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * * 调用摄像头 * 传入参数：必须 * canvas：画布，传入的参数为id,class,name或者tagName四选一，注意：只需要传入名称即可,不需要符号， * 例如:&lt;canvas id = "myCanvas"&gt;&lt;/canvas&gt;,那么入参就是myCanvas * video：影像，传入id，class，name，或者tagName四选一 * * 传入参数：非必须 * open ：打开摄像头功能的按钮id，class，Name * snap ： 拍摄功能的按钮id，class或者name * close： 关闭摄像头功能的按钮id，class或者name * * 注意：如果不传入按钮功能，会有open，snap，close三个function来提供相应的功能，可以直接使用canCamera.open()等来调用 * * 同时，提供链式调用 * * 调用示例： * var cc = canCamera(&#123; * canvas:"myCanvas", * video:"myVideo", * open:"start", * snap:"getPhotoBtn", * close:"closeBtn" * &#125;) * * 或者： * * var cc = canCamera(&#123; * canvas:"myCanvas", * video:"myVideo" * &#125;) * //绑定按钮点击事件 * document.getElementById("start").addEventListener('click',cc.open); * document.getElementById("getPhotoBtn").addEventListener('click',cc.snap); * document.getElementById("closeBtn").addEventListener('click',cc.close); * */(function (window, document) &#123; var canCamera = function (obj) &#123; var $this = canCamera $this.canvas = document.getElementById(obj.canvas) || document.getElementsByName(obj.canvas)[0] || document.getElementsByClassName(obj.canvas)[0] || document.getElementsByTagName(obj.canvas)[0] $this.video = document.getElementById(obj.video) || document.getElementsByName(obj.video)[0] || document.getElementsByClassName(obj.video)[0] || document.getElementsByTagName(obj.video)[0] $this.openBtn = document.getElementById(obj.open) || document.getElementsByName(obj.open)[0] || document.getElementsByClassName(obj.open)[0] $this.snapBtn = document.getElementById(obj.snap) || document.getElementsByName(obj.snap)[0] || document.getElementsByClassName(obj.snap)[0] $this.closeBtn = document.getElementById(obj.close) || document.getElementsByName(obj.close)[0] || document.getElementsByClassName(obj.close)[0] $this.context = $this.canvas.getContext('2d') $this.MediaStreamTrack = null $this.open = function () &#123; $this.video.style.display = "block"; $this.canvas.style.display = "none"; if (navigator.mediaDevices &amp;&amp; navigator.mediaDevices.getUserMedia) &#123; navigator.mediaDevices.getUserMedia(&#123; "video": true &#125;).then(function (stream) &#123; $this.MediaStreamTrack = typeof stream.stop === 'function' ? stream : stream.getTracks()[1]; $this.video.srcObject = stream; $this.video.play(); &#125;).catch(function (err) &#123; console.log(err); &#125;); &#125; else if (navigator.getMedia) &#123; navigator.getMedia(&#123; "video": true &#125;).then(function (stream) &#123; console.log(stream); $this.MediaStreamTrack = stream.getTracks()[1]; $this.video.srcObject = (window.webkitURL).createObjectURL(stream); $this.video.play(); &#125;).catch(function (err) &#123; console.log(err); &#125;); &#125; else &#123; alert("浏览器不支持！"); &#125; return $this &#125;; $this.snap = function () &#123; var w = $this.video.offsetWidth, h = $this.video.offsetHeight; $this.video.style.display = "none"; $this.canvas.style.display = "block"; $this.context.drawImage($this.video, 0, 0, w, h); return $this &#125;; $this.close = function () &#123; $this.MediaStreamTrack &amp;&amp; $this.MediaStreamTrack.stop(); return $this &#125;; if ($this.openBtn) $this.openBtn.addEventListener('click', $this.open); if ($this.snapBtn) $this.snapBtn.addEventListener('click', $this.snap); if ($this.closeBtn) $this.closeBtn.addEventListener('click', $this.close); window.canCamera = canCamera || new canCamera() return $this &#125; window.canCamera = canCamera || new canCamera()&#125;)(window, document)]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
        <category>HFJs</category>
      </categories>
      <tags>
        <tag>兴趣</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端画图Canvas简单运用]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F19%2F%E5%89%8D%E7%AB%AF%E7%94%BB%E5%9B%BECanvas%E7%AE%80%E5%8D%95%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、前言 朋友遇到的情况，属于前端的问题，是需要打开摄像头来拍照，关于这个问题，他找到了我让我来帮他解决，不过由于我的前端也是属于那种半吊子水平，所以在过程中也是参考了网上的不少资料和案例，不过还好的是因此也了解了不少知识，所以准备整理一下，做个记录 这篇主要是前端canvas画布功能，可能知识不够全面，但是要实现拍照应该是没问题了 除了参照图像资源进行利用canvas画图之外，canvas还有很多功能提供，方便我们直接在页面上进行手工绘画，这些功能这里就不展示了，因为我也忘记了，只是之前刚学前端的时候有捣弄过，不过现在主要做后台开发，所以前端水平就一般般 二、画图 在实现拍照之前，先来详细了解一下canvas画图功能，这样对于后面拍照会更简单一点 页面准备 实现canvas画图功能，我们需要准备一张图片，为了试验效果，我就随便截了一张桌面的图片 在页面中我们要放置一张图片(当然，也可以不用展示在页面上，这个js代码中会扩展)，所以需要img标签元素 想要进行在页面画图，我们还要通过canvas标签元素获得context(简称，后面展示全部)来帮我们实现这个功能 然后，为了进行测试，我们加一个按钮，当点击按钮的时候，我们将展示的图片画出来 html代码 我们需要的html代码很简单，只有三个元素：img、canvas、button 1234&lt;img src="../imgs/0.png" id="img"&gt;&lt;canvas height="400" width="200" id="canvas1" style="border: 1px solid gray"&gt;&lt;/canvas&gt;&lt;br/&gt;&lt;button id="draw"&gt;画图&lt;/button&gt; js代码及详解简单分析 在上代码之前， 先来说一下流程 我们想要参照img元素中的图片资源，利用canvas来将其画出来 那么首先我们就需要找到img元素中的图片， 其次还要有canvas画图的对象， 然后获得canvas的Context 最后配置Context的环境将img图片画出来 总体简单来说就这四步，下面直接上代码，然后再解释： js代码12345678window.onload = function () &#123; document.getElementById("ckbtn").addEventListener('click', function () &#123; var img = document.getElementById("img"); var cv = document.getElementById('canvas1'); var ct = cv.getContext("2d"); ct.drawImage(img, 0, 0, 200, 400); &#125;);&#125; js代码详细解释（以及踩过的坑和未踩过的坑） 注意点1、window.onload 这个window.onload不用多解释，就是在页面加载完成之后再执行funciton中的这段代码 为什么一定要这么做呢？ 那是因为我们现在使用的页面元素，如果没有这个onload保证页面先加载完成，有可能会出现这种情况： canvas元素找不到，所以我们获取其dom对象的时候有可能会出现undefined 如果canvas出现undefined的话，那么我们必然无法获得该画布下的Context，也就无法实现画图功能 除此之外，运气好，我们canvas画布放的比较靠前，能够找得到，不过我们知道，图片属于外部静态资源，加载可能没有html原生代码快，这个时候，如果我们图片没有加载完成，也可能会出现画图失败 举个例子，假如有一个画家，他要为一个人画一幅像，但是不巧的是，这个人突然临时有事，不能准时到，那么在这个人还没有到达之前，这个画家怎么去画这幅画？他拿什么做参考呢？ 再者呢，我们又要绑定按钮，所以onload最好是加上 这里说了那么多，我们能够知道，如果我们看着代码没有错误，并且没有报错，那么很可能是图片没有加载完成，导致没法画出图片（之后还有一个可能的原因，在注意点2） 注意点2、canvas元素 这里要注意的是，我们所说的canvas画图，其实canvas只是一个画布,隐约记得曾经学的时候，好像还有画笔什么来着，记不清了，不纠结了、 真正实现画图功能的，是画笔而不是画布，而之前说的Context，是一种环境， 这里打个比方，canvas是画布，就是画家使用的画板，就是我们要画出的画的容器 那个画笔是什么来着，就是用来进行绘画的，之前说的能够手工绘画也是控制画笔在页面上进行绘画 而context，是环境，就好比我们画家用画笔在画布上绘画所需要的因素，在这里我个人将它理解为了画家，因为context提供了画图很多方法来满足画图的需要。就像一个画家一样具备的能力 这里简单展示一下context，关于context这个对象具体的代码有点多，有兴趣的可以自己研究 123getContext(contextId: "2d", contextAttributes?: Canvas2DContextAttributes): CanvasRenderingContext2D | null;getContext(contextId: "webgl" | "experimental-webgl", contextAttributes?: WebGLContextAttributes): WebGLRenderingContext | null;getContext(contextId: string, contextAttributes?: &#123;&#125;): CanvasRenderingContext2D | WebGLRenderingContext | null; 这里并不是很详细地解释了canvas，所以我们知道，canvas是容器，这里也会有一个小问题，不知道有没有人遇到过。（在做摄像头拍照的时候遇到了小问题，所以回头研究了canvas） 如果我们为了美观，不展示canvas来占空间，而设置为了display:none，那么会发生什么情况？ 另外，如果我们设置了canvas的长宽都为0，会是什么情况？ 对于以上两点，在下面会案例展示结果，先猜一下吧 注意点3、2维和3维画图 通过上面的getContext()方法，能够看得出来，我们假如传入的是“2d”这个字符串，那么就会获得CanvasRenderingContext2D这个对象 在没有看过这些代码之前，我也曾一度认为，有2d就有3d，果断丢个”3d”参数进去，哈哈，获得null，那么我们肯定觉得不合理，有2d画图就应该能画3d的啊，其实webgl就是用来画3d的，不过我不会，也不了解 不过有一点需要注意了，接下来图文解释更清晰 首先我获得canvas之后，通过传入参数3d 1234var cv = document.getElementById('canvas1'); console.log(cv) var ct = cv.getContext("3d"); console.log(ct) 获得的结果为null 然而我们如果传入的是”2d”或者”webgl”的话，确实能够获得context的 注意了：如果我们先入参2d获得返回对象保存在一个变量中，然后再入参webgl保存在另一个变量中，会是什么结果？ 123456var cv = document.getElementById('canvas1'); console.log(cv) var ct2d = cv.getContext("2d"); var ctwebgl = cv.getContext("webgl") console.log("ct2d:"+ct2d) console.log("ctwebgl:"+ctwebgl) 12345678910111213141516- 结果就是先获得的context占据这个画布，再设置另一个则没用了，直接为null。而官方原注释并没有解释为何，我们可以从官方注释中得到的信息，就是：- 返回一个对象，该对象提供绘制和操作文档中画布元素上的图像和图形的方法和属性。上下文对象包括关于颜色、线宽、字体和其他可以在画布上绘制的图形参数的信息。 @param上下文要创建的画布类型的标识符(ID)。Internet Explorer 9和Internet Explorer 10仅支持使用canvas.getContext(“2d”)的2d环境;IE11预览还支持3d或WebGL上下文使用canvas.getContext(“实验- WebGL”);- 好像并没有什么文字能解释为什么只能获得一次？那么我们就只能从代码中分析了，请移至注意点2查看代码，这里不贴了- w3school中也没有过多解释，不过这里依然不妨碍理解，这个方法大致为以下情况：- 根据入参来匹配2d或者webgl，如果是，那么会先去看contextAttributes，如果已经有值了（上次一调用之后会将2d或者webgl相应对象存下来，猜测），那么直接返回null，这就导致如果第一次已经拿到2d的对象了，那么下面再入参webgl调用，获得的就是null，而为什么不是返回上一次的，就是函数返回值的问题吧，看前两个getContext，返回值要么是对应的2d或webgl对象，要么是null。这就是说参数匹配到之后，就会执行相应的函数，而"2d"只会返回2d对象或者null，webgl也是一样。最后一个方法，是在参数不匹配2d或者webgl的时候，会先去返回2d，如果没有，再考虑webgl，最后二者都没有，就返回null- 其实，之上一点的看法，最后理解根本无法实践，因为按照最后的说法，我们必须要传一个参数过去，而如果我们先传过去2d，那么获得2d对象，这时候再去调用getContext实践，不好意思，之前已经设置过2d了，其他的我不会给你了。就好比一个画板，其中A画家先去使用了，那么不好意思，不管你后来再来的其他任何人，都不会得到使用权。不过如果再次传入2d，还是能够获得2d对象，这个只能解释为A画家中途休息，休息完之后依旧拥有该画板的使用权。以至于最后的猜想也没法实现验证。因为我除了传入2d参数，其他任何参数都会直接获得null- 而且这看到的只是interface中的代码，没有具体实现的逻辑代码，一切靠猜测，所以可能会很大的冲突，不过结果肯定是一样的，因为就是通过结果来进行推测的逻辑。如果有人比较了解这方面的东西，希望能够告知以便相互学习 注意点4：这里不叫注意点，应该是知识点 drawImage（r,x,y,w,h）参数： r：代表的是图像源头 x：表示在画布中x坐标轴的偏移量 y：y坐标轴偏移量 w：画出的图片的宽度 h：高度 、结果实例 参照页面img元素画图 这里就丢两张图， 反正该解释的上面已经解释了 不参照页面img元素画图 在前面说过，我们不将图片展示在页面上来将图片画出来，不过我们要遵循的步骤依旧是一样的 只不过第一步找参考图片不是在页面中寻找了，而是在js代码中，也就是我们要手动创建一个img元素dom对象，然后指定其图片 代码： 12345678window.onload = function () &#123; var img = document.createElement("img") img.src="../imgs/0.png" document.getElementById("draw").addEventListener('click', function () &#123; var cv = document.getElementById('canvas1'); var ct = cv.getContext("2d"); ct.drawImage(img, 0, 0, 200, 200); &#125;); 结果图： 以上展示了如何利用canvas画图，其中有理解错误的地方，也就这样了。下面来看一下怎么将这张canvas中的图片保存下来，这个后面会用到 四、canvas补充 上面说到的两个问题，在这里进行补充示例说明结果 问题1：canvas设置为display:none的情况会如何 首先看一下代码： html：直接设置canvas样式为display:none 1234&lt;canvas height="400" width="200" id="canvas1" style="border: 1px solid gray;display:none;"&gt;&lt;/canvas&gt;&lt;br/&gt;&lt;button id="draw"&gt;画图&lt;/button&gt;&lt;button id="show"&gt;展示&lt;/button&gt; 结果可想而知，页面上什么都没有只有两个个按钮 js代码：思路是，点击画图将图片画到canvas中，在点击展示改变canvas的样式为block，看看有没有图片 123456789101112//画图按钮var img = document.createElement("img")img.src="../imgs/0.png"document.getElementById("draw").addEventListener('click', function () &#123; var cv = document.getElementById('canvas1'); var ct = cv.getContext("2d"); ct.drawImage(img, 0, 0, 200, 200);&#125;);//展示按钮document.getElementById("show").addEventListener('click',function () &#123; document.getElementById("canvas1").style.display= 'block';&#125;) 结果： 啊哈，有图片耶！那么我们来看看第二种情况 问题2：canvas设置为长宽都为0的情况会如何 思路同上一个，直接贴代码和效果 1234&lt;canvas height="0" width="0" id="canvas1" style="border: 1px solid gray;"&gt;&lt;/canvas&gt;&lt;br/&gt;&lt;button id="draw"&gt;画图&lt;/button&gt;&lt;button id="show"&gt;展示&lt;/button&gt; 12345678910111213//画图按钮 var img = document.createElement("img") img.src = "../imgs/0.png" document.getElementById("draw").addEventListener('click', function () &#123; var cv = document.getElementById('canvas1'); var ct = cv.getContext("2d"); ct.drawImage(img, 0, 0, 200, 200); &#125;); //展示按钮 document.getElementById("show").addEventListener('click', function () &#123; document.getElementById("canvas1").style.width = '200px'; document.getElementById("canvas1").style.height = '400px'; &#125;) 没有图片唉！ 总结： 我们将canvas设置为display:none，但是该元素还是存在页面中的，并且占有一定的面积，只是因为设置为不显示，所以视觉上并没有占用页面的空间。 之前说过，canvas是画布，画图是将图片画在canvas元素上，那么既然存在，不管别人看不看得到，我们画图的时候没有影响 而将canvas宽高设置为0，那么该元素虽然依旧存在页面中，但是一个没有任何大小的元素，真正的意义是依旧存在页面中吗？谁能将一幅画画在面积为0的画板上呢？ 所以，对于canvas的理解，就是这样，它就是一个容器，就是用来存放画出来的图像的一个容器。 五、canvas图片下载 针对与摄像头拍照，我们需要将”拍”的照片保存下来，其实就是将canvas中画出来的图像保存下来， 然后目前的情况也就是我们只是拥有一个存在于页面有展示效果的视觉图像而已，以及一个保存这个图像的元素 那么我们如何将这个元素中的画面以图片文件形式保存下来呢？ 其实很简单，有以下几步 ## １、获得图片文件形式 文件，其实也是一组数据，我们只要拿到这组数据就能实现文件下载 123var ctx = document.getElementById('canvas1'); //获得图片的base64加密字符串 var imgdata = ctx.toDataURL("image/png", 1.0); 通过ctx.toDataURL方法能够将canvas元素中的图像元素转成文件数据路径 接下来，有了文件数据路径。我们可以通过a标签来进行下载该文件 12345678910111213//设置文件名字，并生成a标签链接文件直接执行鼠标点击事件进行下载var type = 'jpg'var filename = 'canvas画图.' + type;var a = document.createElement('a');//设置a链接元素为文件数据路径，点击时候就能直接下载a.href = imgdata;a.download = filename;//然后生成鼠标点击事件// a.click()var event = document.createEvent('MouseEvents');event.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);//执行a标签元素的鼠标点击事件，就相当于是在页面中用鼠标点击了a链接，实现下载a.dispatchEvent(event); 说明一下：其实从10行开始到结束的代码，效果等同于第九行的a.click()，就是为了能够不实用鼠标点击页面元素而实现a的点击事件 到此，我们就把canvas中的图像保存下来了，有人应该注意到，png格式，对于没有被填充的canvas范围，在图片中是透明背景。 除了png格式，还支持jpg、bmp、gif等格式，视自己的需求来吧 六、摄像头拍照 其实摄像头拍照功能，我们也能够利用canvas画图来实现 按照我们之前说的，利用canvas只要能够将画面元素拿到，就能够将该元素区域中的图像画到canvas中，然后下载 上面已经说了后面的步骤，所以我们要利用摄像头中拍照，那么到目前我们要解决的事情就只有两个了： 1、拿到摄像头中拍摄到的画面展示在页面中 2、将页面中展示摄像头页面的元素获取到，给canvas画下来 打开摄像头先贴代码，然后再解释 12345678910navigator.mediaDevices.getUserMedia(&#123; "video": true &#125;).then(function (stream) &#123; console.log(stream); $this.MediaStreamTrack = typeof stream.stop === 'function' ? stream : stream.getTracks()[1]; $this.video.srcObject = stream; $this.video.play(); &#125;).catch(function (err) &#123; console.log(err); &#125;); 详解navigator Navigator 对象包含有关浏览器的信息 ， 注释：没有应用于 navigator 对象的公开标准，不过所有浏览器都支持该对象 描述：Navigator 对象包含的属性描述了正在使用的浏览器。可以使用这些属性进行平台专用的配置。 虽然这个对象的名称显而易见的是 Netscape 的 Navigator 浏览器，但其他实现了 JavaScript 的浏览器也支持这个对象。 Navigator 对象的实例是唯一的，可以用 Window 对象的 navigator 属性来引用它。 对于这个对象，可以去网上查查，今天我们关注的并不是它 mediaDevices 上面说的Navigator对象很牛逼，牛逼到我们能够获得当前所使用环境的很多信息，包括浏览器，当前系统等等 而mediaDevices，则是一个API接口，该接口提供了访问链接媒体输入的设备，如我们使用的摄像头、照相机和麦克风，以及屏幕共享等。 这些媒体输入设备,都能通过该接口来访问链接以便调用 链接可以去网站上看看详细的文档资料 ​ https://developer.mozilla.org/zh-CN/ 进去后点击左上角技术&gt;&gt;&gt;API/dom 能够查看所有的API文档，然后找到mediaDevices和Navigator自行学习 有了mediaDevices，只是给我们提供了媒体输入设备链接，而我们要使用设备，还需要一个方法，没错，就是代码中的getUserMedia() mediaDevices.getUserMedia() 该方法会使用户给予使用媒体输入的许可 ，媒体输入会产生一个MediaStream，里面包含了请求的媒体类型的轨道 。 MediaStream是一个流，这个流可以包括视频轨道（来自硬件或者虚拟视频源，比如相机、视频采集设备和屏幕共享服务等等 ）、音频轨道（同样来自硬件或虚拟音频源，比如麦克风、A/D转换器等等 ），也可能是其他轨道 这个函数的参数也比较简单，就是一个对象，这个对象就是表示我们要请求使用的媒体 1&#123; audio: true, video: true &#125; 上面这个代码表示没有任何要求，只要使用音频和视频的媒体 1234&#123; audio: true, video: &#123; width: 1280, height: 720 &#125;&#125; 而这上面代码是说，我要使用音频和视频媒体输入设备，但是视频设配我要1280x720的分辨率 等等，这些参数我们可以灵活使用，而这些东西在上面分享的url里面都有，可以自行去看文档学习 说完参数，那么来看一下返回值：Promise 其实这个对象没多大深度，就是表示异步操作最终完成或者失败的对象 也就是说，我们请求使用设备，成功了，这个对象就表示成功了，失败了，就表示失败了 它的本质就是一个绑定了回调函数的对象，而不是将回调函数传入函数内部 所以我们用.then(function(){})来执行请求设备许可后的处理方法 而如果请求失败或者设备不可用。会回调PermissionDeniedError 或者NotFoundError ，我们用链式调用.catch(function(){})来处理异常 注意：有可能这个对象既不返回允许，也不返回拒绝，因为用户不是百分百会选择允许使用或者拒绝使用，也可能用户什么都不选 好了，闲话不多说，简单聊一聊，具体的去看文档资料学习吧 接下来说一下获得使用设备的许可之后，我们怎么做 Promise.then(function(){})回调 刚刚说过，在then绑定一个回调函数，可以用来处理获得许可后的方法，那么我们就来看一下这里的代码 这里，表示我们取得使用权，那么我们就只需要处理反馈给我们的stream(流)就可以了 然后，我们获得视频轨道（后面我们需要关闭摄像头的），当然，在代码中我们为了严谨，还是做了一步判断，就简单来谈一下吧 $this.MediaStreamTrack = typeof stream.stop === ‘function’ ? stream : stream.getTracks()[1]; 这个我们先判断返回的流stream是不是一个函数，如果是的话，那么有可能这个流里面包含的不仅仅是一个视频轨道，所以在这进行了判断，更为严谨。三元表达式就不解释了吧。 处理完stream之后，就非常简单了，我们想要在页面上展示视频，就是使用video，那么通过document获得页面元素video的dom对象video（因为懒得想名字了，就直接var video了。别误会它是什么东西，就是通过id获取的页面元素） $this.video.srcObject = stream; 然后，就给video这个对象的srcObject赋值为当前的stream，完美搞定 这里需要注意一下，有的帖子中写的是video.src = stream，可坑死了 因为之前没写过，所以刚开始就直接赋值的别人的代码，结果没画面，但是摄像头打开了 就是因为属性不是src，而是srcObject 于是乎，就去了上边链接的网站上看了很久文档，才慢慢搞明白怎么回事，然后自己封装成了自己的组件，以备不时之需，嘿嘿嘿 虽说路径已经配好了，不过不觉得还差点什么吗？没错，video没有开始播放啊，不解释了，.play() 拍照 ok，摄像头画面我们有了，那么就该”拍照”了吧，为什么把拍照两个字用引号引起来？还不懂吗？因为压根就不是拍照，而是canvas画图 这一步就非常简单了，照旧，在页面上添加一个 拍照 按钮，然后点击事件里面代码如下： 1$this.context.drawImage($this.video, 0, 0, 200, 400); 一行代码搞定，就是直接将video像之前的img一样，直接放进去就OK了 关闭摄像头 记得关闭摄像头 1$this.MediaStreamTrack.stop(); 问题点画面出不来 别急别急，有可能是浏览器不兼容的问题 那么我们通过Navigator.mediaDevices来请求摄像头，可能因为浏览器问题而出现错误，别急，我们还有另一种办法 12345678910navigator.getMedia(&#123; "video": true &#125;).then(function (stream) &#123; console.log(stream); $this.MediaStreamTrack = stream.getTracks()[1]; $this.video.srcObject = (window.webkitURL).createObjectURL(stream); $this.video.play(); &#125;).catch(function (err) &#123; console.log(err); &#125;); 不过这种就是会返回一个函数 拍照无效果？ 这个不解释了，有这个问题很大部分应该就是画图中出现的那两个问题吧，如果当时你不知道为什么会出现那两种情况，那么当你做到摄像头拍照的时候就有可能会遇到了 好了，这个不解释，但是下面我们来完善一下页面，并且看看为什么会出现之前提出的两个问题 七、完善页面效果完善 嘿嘿，说到这，我要提要求了，我们一般摄像头拍摄，是不是有需要弹出层的？有需要将影像固定在某个区域的，反正肯定不会是在页面最左上角吧？那样丑死了。 ok，那么我们就来看一下吧。最简单的思路就是，将video元素和canvas元素共同放在同一个容器中，这样不管需求想要将影像在哪呈现，只要把这个容器拿过去就OK了，里面什么都不需要动。 123456789&lt;div id="camera"&gt; &lt;div id="contentHolder"&gt; &lt;video id="video" width="640" height="480" autoplay&gt;&lt;/video&gt; &lt;canvas id="canvas" width="640" height="480"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;div id="buttons"&gt; &lt;button id="btn_snap" class="btn btn_blue"&gt;拍照&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; ok，我的页面（老脸很红，这明明是朋友发来的页面）时这个样子滴，一个大的容器id = “camera”，而里面分两块div，一个是contentHolder用来呈现影响video以及拍照后保存画面的vanvas，另一个是存放按钮 我草，为什么会这样 为什么？ 现在能够看到，原来是canvas，当初我们实验的时候没考虑过页面美化的问题吧？那么这个canvas怎么办？ 很简单啦，将canvas设置为none不就行了？ 但是，千万别傻傻地将canvas设置宽高为0，然后再改回来，这样没法画图的，上面的实验也说过了 js完善 ok，如果按照之前设置为none之后，那么后面可能会没有画面，这个没关系，还记的之前的canvas补充里面的实验吗？就那么解决 但是还是有点担心，在将canvas设置为display:block之前，千万别忘记吧video设置为display:none，因为我们的容器只能同时容纳其中一个的大小，是为了美观，同时也是为了造成一种假象，那就是视频和拍照都在同一个容器里面，其实是两个元素（video和canvas）进行切换的 代码如下： 123$this.video.style.display = "none";$this.canvas.style.display = "block";$this.context.drawImage($this.video, 0, 0, 200, 400); 组件 最后就是个人封装的组件，代码就不贴在这了，单独贴到一个文章中吧]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>实录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java详解jvm工作原理和流程]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F15%2Fjava%E8%AF%A6%E8%A7%A3jvm%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！ [TOC] 一、浅说java说起java,人们首先想到的是java编程语言,然而事实上,Java是一种技术,它由四方面组成: java编程语言 java类文件格式 java虚拟机 java应用程序接口(Java API) 其关系如: java平台由Java虚拟机和Java应用程序接口搭建,java语言则是进入这个平台的通道,用Java语言编写并编译的程序可以运行在这个平台上. 这个平台结构: 运行期环境代表着Java平台,开发人员编写Java代码(.java文件),然后将之编译成字节码(.class)文件,在然后字节码被装入内存,一旦字节码进入虚拟机,它就会被解释器解释执行,或者是被即时代码发生器有选择的转换成机器码执行. java程序经过一次编译之后，将java代码编译为字节码也就是class文件，然后在不同的操作系统上依靠不同的java虚拟机进行解释，最后再转换为不同平台的机器码，最终得到执行。这样我们是不是可以推演，如果要在mac系统上运行，是不是只需要安装mac java虚拟机就行了。 JVM在它的生命周期中有一个明确的任务,那就是运行java程序,因此当Java程序员启动的时候,就产生JVM的一个实例;当程序运行结束的时候,该实例也就跟着消失了 在Java平台的结构中,可以看出,Java虚拟机(JVM)处在核心的位置,是程序与底层操作系统和硬件无关的一个关键.下方是移植接口. 移植接口由两部分组成：适配器 和 Java操作系统 其中依赖于平台的部分被称为适配器 JVM通过移植接口在具体的平台和操作系统上实现;在JVM的上方是Java的基本类库和扩展类库以及他们的API,利用Java API编写的应用程序(application)和小程序(java applet)可以在任何Java平台上运行而无需考虑底层平台,就是因为有Java虚拟机(JVM实现了程序与操作系统的分离,从而实现了Java的平台无关性) 二、JVM基本概念和运行过程1.基本概念:1JVM是可运行Java代码的假象计算机（虚拟计算机） JVM包括： 一套字节码指令集 一组寄存器 一个栈 一个垃圾回收 堆 一个存储方法域 JVM是运行在操作系统之上的,它与硬件没有直接的交互 2.运行过程Java源文件 通过 编译器 能够产生相应的 字节码文件(.Class文件) ,而字节码文件又通过 Java虚拟机中的解释器 编译成 特定机器上的机器码 12java源文件 ----&gt; 编译器 ----&gt; 字节码文件字节码文件 ----&gt; JVM ----&gt; 机器码 每一种平台 的 解释器是不同的, 但是实现的 虚拟机 是 相同 的,这也就是Java为什么能够 跨平台 的原因了 当一个 程序从开始运行 这时 虚拟机 就开始 实例化 了, 多个程序 启动就会存在 多个虚拟机实例. 程序 退出或关闭, 则虚拟机 实例消亡 , 12注意:多个虚拟机实例之间数据不能共享 3.三种JVM:1234567- Sun 公司的 HotSpot- BEA 公司的 JRockit- IBM 公司的 J9 JVM在 JDK1.7 及其以前我们所使用的都是 Sun 公司的 HotSpot, 但是由于 Sun公司 和 BEA公司都被 oracle 收购jdk1.8 将采用 Sun 公司的 HotSpot 和 BEA 公司的 JRockit 两个JVM中 精华 形成 jdk1.8的JVM 三、JVM的体系结构 1.Class Loader类加载器负责加载.class文件,class文件在文件开头有特定的文件标示,并且ClassLoader负责class文件的加载等.但是至于它是否可以运行,则由Execution Engine(执行引擎)决定 定位和导入 二进制.class文件 验证 导入类的正确性 为类 分配 初始化 内存 帮助 解析 符号引用 2.Native Interface 本地接口本地接口的作用是 融合不同的编程语言为Java所用, 它的 初衷 是融合 C/C++ , Java诞生的时候C/C++横行的时候,想要立足,必须调用C/C++程序, 于是就在内存中专门开辟了一块区域处理标记为 native的代码. 具体做法: Native Method Stack中登记native 方法,在Execution Engine执行的时候加载native libraies(本地方法库) 不过目前该方法使用的越来越少了,除非是与硬件有关的应用, 如: 通过Java程序驱动打印机,或者Java系统管理生产设备,在企业级应用中已经比较少见 因为现在的 异构领域空间 的通信很发达 ,比如:可以使用 Socket通信, 也可以使用 Web Service等 3.Excution Engine 执行引擎:执行 包在 装载类 的方法中的 指令,也就是 方法 4.Runtime data area 运行数据区:虚拟机内存或者 JVM内存, 从整个 计算机内存中开辟 一块内存 存储 JVM用到的 对象,变量等 运行区数据又分很多小区,分别为：方法区 堆 虚拟机栈 本地方法栈 程序计数器 5.JVM数据运行区详解(栈管运行,堆管存储):1说明: jvm调优主要就是 优化Heap堆和Method Area方法区 方法区 Method Area 方法区是各个线程共享的区域， 所有 字段 和 方法字节码 ,以及一些特殊方法如 构造函数, 接口代码 也在此定义. 简单说,所有 定义的方法的信息 都保存在该区域,属于 共享区间 静态变量 + 常量 + 类信息 + 运行时常量池 存在方法区中 堆 java堆也是线程共享的区域，我们的类的实例就放在这个区域(而指向该实例变量的引用存在栈)， 可以想象你的一个系统会产生很多实例，因此java堆的空间也是最大的。 如果java堆空间不足了，程序会抛出OutOfMemoryError异常。 也是 GC（垃圾回收机制） 主要的 回收区, 一个JVM 实例只存在 一个堆 类内存,堆内存的 大小 是可以 调节 的 虚拟机栈 VM Stack 栈是什么 ：栈也叫 栈内存, 主管Java 程序的运行, 是在 线程创建时 创建, 他的生命期是跟随 线程的生命期, 线程结束 栈内存也就 释放, 对于栈来说 不存在垃圾回收问题, 只要线程已结束该栈就over,生命周期和线程一致, 是 线程私有的 基本类型 的变量和 对象的引用 变量都是在函数的 栈内存中分配 栈存储什么：栈帧中主要保存 3类数据: 本地变量(Local Variables): 输入参数和输出参数以及方法内的变量 栈操作( Operand Stack ): 记录出栈,入栈的操作 栈帧数据( Frame Data ): 包括类文件,方法等等 栈运行原理 栈中的 数据 都是以 栈帧的格式 存在, 栈帧是一个 内存区块, 是一个 数据集, 是一个有关 方法 和运行期 数据 的 数据集 当一个方法A被调用时就产生了一个栈帧F1,并被压入到栈中,A方法有调用了B方法,于是产生栈帧F2也被压入栈,B方法有调用了C方法,于是产生的栈帧F3也被压入栈……依次执行完毕后,先弹出后进……F3,再弹出F2,F1 遵循 先进后出/后进先出 原则 就是说，java栈是每个线程私有的区域，它的生命周期与线程相同，一个线程对应一个java栈，每执行一个方法就会往栈中压入一个元素，这个元素叫“栈帧”，而栈帧中包括了方法中的局部变量、用于存放中间状态值的操作栈，这里面有很多细节。如果java栈空间不足了，程序会抛出StackOverflowError异常，想一想什么情况下会容易产生这个错误，对，递归，递归如果深度很深，就会执行大量的方法，方法越多java栈的占用空间越大。 本地方法栈 Native Method Stack 本地方法栈角色和java栈类似，只不过它是用来表示执行本地方法的，它的具体做法是Native Method Stack中登记native方法，本地方法栈存放的方法调用本地方法接口，在Execution Engine执行时候加载native libraies ，最终调用本地方法库，实现与操作系统、硬件交互的目的。 程序计数器 PC寄存器（有的这么叫，这里提一下），说到这里我们的类已经加载了，实例对象、方法、静态变量都去了自己该去的地方，那么问题来了，程序该怎么执行，哪个方法先执行，哪个方法后执行，这些指令执行的顺序就是PC寄存器在管，它的作用就是控制程序指令的执行顺序 （Register，也是记录，登记，寄存的意思，就是用来管理的） 每个线程都一个 程序计算器, 就是一个 指针, 指向 方法区中的 方法字节码 (下一个将要执行的指令代码),由 执行引擎读取 下一条指令,是一个 非常小 的内存空间,几乎可以 忽略不计 6.堆内存 堆内存分为3部分: 1.新生区 新生区是 类 的 诞生,成长,消亡 的区域. 一个 类 在这里 产生,应用, 最后被 垃圾回收器收集,结束生命 新生区又分为两部分: 伊甸区(Eden space) :所有的类都是在伊甸区被new出来的 幸存者区(Survivor Space) :有两个,0区和1区 当伊甸区的空间用完时,程序有需要创建对象,JVM的垃圾回收器将对伊甸区进行垃圾回收(Minor GC),将伊甸区中的剩余对象移动到幸存0区, 若0取也满了,对该区域进行垃圾回收,然后移动到1区 1区满了移动到养老区(Tenure Generation Space) 养老区满了,这时候将产生Major GC(FullGC),进行养老区的内存清理. 若养老区执行Full GC之后发现依然无法进行对象的保存,会产生OOM异常(OutOfMemoryError,内存溢出) 所以，如果出现java.lang.OutOfMemoryError:Java heap space异常,说明Java虚拟机的堆内存不够 ，原因有二： Java虚拟机的堆内存 设置 不够,可以通过参数 -Xms, -Xmx 调整 (jvm调优方面会说) 代码中创建了 大量大对象,并且长时间 不能被 垃圾收集器 收集(存在被引用) 2.养老区 用于保存从新生区筛选出来的Java对象,一般 池对象 都在这个区域活跃 年老代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在） 内存大小相对会比较大，垃圾回收也相对没有那么频繁（譬如可能几个小时一次） 年老代主要采用压缩的方式来避免内存碎片（将存活对象移动到内存片的一边，也就是内存整理）。 当然，有些垃圾回收器（譬如CMS垃圾回收器）出于效率的原因，可能会不进行压缩。 （这些调优篇细讲） 3.永久区（Permanent Space ） 是一个 常驻内存区域 , 用于存放 JDK自身 所携带的 class,interface的元数据 也就是说它存储的是 运行环境必须 的类信息,被装载进此区域的数据是 不会被 垃圾回收器 回收 掉的 关闭JVM 才会释放 此区域所占用的内存 如果出现java.lang.OutOfMemoryError:PermGen space,说明是Java虚拟机对永久代Perm内存设置不够 ，原因也有两点： 程序启动需要加载大量的第三方jar包. 如:在一个tomcat下部署了太多的应用 大量动态反射生成的类不断被加载,最终导致Perm区被占满 关于永久区的个版本： jdk1.6之前:常量池分配在永久带 jdk1.7:有,但已经逐步”去永久带” jdk1.8之后:无(java.lang.OutOfMemoryError:PermGen space这种错误将不会出现在JDK1.8中) 下面两张图片解释一下 四、 方法区和堆内存的异议:实际而言,方法区和堆一样,是各个线程共享的内存区域,它用于存储虚拟机加载的: 类信息+普通常量+静态常量+编译器变异后的代码 虽然JVM规范将方法区描述为堆的一个逻辑部分,但它却还有一个别名叫做Non-Heap(非堆),目的就是要和堆分开. 对于HotSpot虚拟机,很多开发者习惯将方法区称之为”永久代(Parmanent Gen)”,但严格本质上说两者不同,或者说使用永久代来实现方法区而已,永久代是方法区的一个实现,jdk1.7的版本中,已经将原本放在永久代的字符串常量池移走 常量池(Constant Pool)是方法区的一部分,class文件除了有类的版本,字段,方法,接口等描述信息外,还有一项信息就是常量池,这部分内容将在类加载后进入方法区的运行时常量池中存放. 五、简单补充堆内存调优简介]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的关键字native]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F15%2FJava%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97native%2F</url>
    <content type="text"><![CDATA[【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！ [TOC] 一、简单介绍native关键字 众所周知，java是跨平台的语言，既然跨平台，就要牺牲对底层的控制，所以java对于底层的控制就依赖于其他语言的帮助，而这就是native的作用 native是用作java和其他语言进行协作时用的，也就是native后的方法的实现不是用java写的。既然不是java写的，那肯定看不到它的源码了 native修饰的方法时一个原生态方法,方法对应的实现不是在当前文件,而是在用其他语言(如C或者C++)实现的文件中.并且被编译成了dll文件。 这些方法的实现体在dll文件中，jdk的源码中并不包含，所以是看不到的。对于不同的平台，他们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的 Java语言本身不能对操作系统底层进行访问和操作,但是可通过JNI接口调用其他语言来实现对底层的访问. JNI是Java本机接口(Java Native Interface),是一个本机编程接口,是Java软件开发发工具箱(java Software Development Kit, SDK)的一部分.JNI允许Java代码使用以其他语言编写的代码和代码库. Invocation API(JNI的一部分)可以用来将Java虚拟机(JVM)嵌入到本机应用程序中,从而允许程序员代码内部调用java代码 所以，native的意思就是通知操作系统，我需要这个方法，而你操作系统需要给我实现，我需要使用。而java只需要调用操作系统的方法就行了 java不是完美的，java的运行速度上比传统的C语言慢许多，java无法直接访问到底层操作系统等缺点。当然，解决方法就是上面说的利用native方法来扩展java程序的功能。以下有实践步骤：是之前做笔记的时候尝试的： 二、实践理解1使用java调用C的"sayHello" 1.创建一个java类 123456789101112public class HelloNative &#123; static&#123; System.loadLibrary("HelloNative"); &#125; public static native void sayHello(); @SuppressWarnings("static-access") public static void main(String[] args) &#123; new HelloNative().sayHello(); &#125;&#125; 这里有一个sayHello()方法，native标识该方法的实现在非当前文件，在static静态快中加载的library(HelloNative)中 运行main()之后出现以下情况 12 报错信息时说找不到library(“HelloNative”)的路径，因为我们本地就没有这个文件 2.创建本地方法文件 我们将Java类HelloNative复制出来，（我给放在了D盘根目录，方便） 然后在控制台用javac命令将其编译成字节码文件， 1javac HelloNative.jave 注意：如果命令输入目录与.java文件不在同一目录下，javac命令后的文件名要加路径，如图中d:\HelloNative.java： 然后在用havah编译，获得包含C声明头文件 1javah HelloNative 注意：在这里，我命令目录与文件目录不在同一路径，报错了，这个命令不会区别路径，而是在当前目录下找d:\HelloNative这个名字的文件，把d:\也当成文件名字的一部分 到此，我们一共有三个文件了： 看一下.h文件的内容吧： 123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class HelloNative */#ifndef _Included_HelloNative#define _Included_HelloNative#ifdef __cplusplusextern "C" &#123;#endif/* * Class: HelloNative * Method: sayHello * Signature: ()V */JNIEXPORT void JNICALL Java_HelloNative_sayHello (JNIEnv *, jclass);#ifdef __cplusplus&#125;#endif#endif 创建.c文件： 12 然后运行gcc命令来生成dll共享库 12 命令中的路径是电脑中jdk的安装路径\include 完成后这样就有5个文件了： 然后在用java命令运行一下java代码，就能成功在cmd通过java代码调用c的sayHello方法了 1java HelloNative 说明： 从gcc命令开始，没有图和真相了，那是因为我所有的笔记标签的文章都是回头看以前做的笔记的时候，重新整理记录一下，也有的是之前没有记录到的，整理的时候又重新学一遍；也有之前试验过但是现在环境不允许了。 不过又去了网上看了看帖子，别人的文章有的用的命令不一样，所以具体如何生成dll，尝试一下就行了，只要生成了dll就OK了 三、步骤总结：1总结一下步骤吧： 1 先创建java类，在类中加载需要的library，声明要调用的本地方法 2 使用javac命令编译.java文件，生成字节码文件.class 3 使用javah命令编译成.h文件，生成包含C声明头的文件 4 编写c文件（.c），然后通过gcc命令(或者vs C++环境下cl命令)生成dll 5 然后利用java命令运行Java代码检测是否成功 其实，上面的这个步骤是反着来的，是因为我们从java介入，往底层找的，真正的顺序应该是先写好的c方法生成dll共享库，然后jvm启动之后留在本地方法区中，随着我们写好java代码之后，如果需要用到本地方法，我们就去找相应的方法直接调用就行了(这部分可以简单看一下jvm方面的知识应该比较容易理解，好了，我再看看jvm的笔记)。]]></content>
      <categories>
        <category>java</category>
        <category>关键字</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用JPA创建原生sql(不使用实体类)]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F13%2F%E4%BD%BF%E7%94%A8JPA%E5%88%9B%E5%BB%BA%E5%8E%9F%E7%94%9Fsql-%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BD%93%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[[TOC] 一、描述 JPA很强大，嗯，没错，是很强大！ 它是通过JDK5.0注解或者XML描述对象-关系表的映射关系，并能够将在运行中的实体对象持久化到数据库中。 并且它也是面向对象查询，也就是将实体类与数据库的表映射，即使不会数据库的开发者，只要能看懂java的类，只要能熟练使用jpa，也能很便捷地操作数据库 当然，映射类有其好处，也有弊端。假如说，某个场景下，我需要查询多个表中的数据，并且每个表中只有一到两个字段有用，而整张表的字段又很多，所以有时候就不需要将每个表都完整映射成实体类（不然的话，每次查询就要多查询很多无用的垃圾信息） 今天遇到了这种场景，由于是多表联查，但是只需要其中各一个字段，其余的每个表十几个字段都没用。所以就不需要把每张表的数据都查询出来。而个人对于jpa也不熟练，所以踩了很多坑。下面就此记录： 二、实录（踩坑全过程，实力坑自己！Pain and happiness!想直接看结果，直接拉下去别看这段了） 想法1、返回map，不用实体类 1.dao层（Repository） 就是控制sql语句对数据库进行增删改查。 这里的接口很容易写，只需要继承JpaRepository&lt;entity,object&gt;接口就可以了# 这里需要注意： 1.entity，必须是被管理的类，也就是与数据库进行映射的实体类 所以，就坑在这了，一直报错说Repository什么什么类型必须是被映射管理的，而map却不是。奶奶的，继续想办法 想法2、 创建实体类（不过由于不懂，所以这里没有进行关系映射，就是一个单纯的javaBean，不用仔细说了失败！） ​ 注意： 1.实体类必须与数据库映射才算被映射管理（@Entity注解） 继续尝试 想法3、映射实体类(但是这次也只写了部分字段，自己需要的) ​ 注意： 加上注解标明映射之后，又特么脑残踩了个雷（鄙视自己一秒钟） 对于这个，说一下吧，由于最初没打算映射，并且需要的数据是多个表的，所以类名就自己起的名字。好家伙，提示table_name没有被映射过！我嘞个擦。所以在@Entity注解加上name属性： @Entity(name=”table_name”)最初的时候加错了，写成实体类的名字了，尴尬！这里其实要写表的名字，表明该实体类与那张表映射 与数据库映射的类必须有@Id标明主键(失败一次！吼，不想解释了) 这一点忍无可忍！错误信息说，表中为not null的字段，必须在实体类中映射！也就是实体类中必须有非空字段的属性！！！ 吼吼吼！！我连吼三次可以了吧！那我跟映射全部字段有什么区别呢？还是初衷吗？ 以上一环扣一环之后，想要按照之前想法，实体类，拜拜！ 经过以上绕的弯路，所以就又绕回来了。哼哼！于是乎：老子不用实体类了，也不继承JpaRepository。 想法4、注解托管Repository！ 奈斯！启动刚开始没报错，之前报错貌似跳过去了！突然之间，XXXXXX that could not be found，我真xxxx了，然后去网上找解决方法，要吐血！各种各样的方法，没用！直到我看到一个帖子： 一口老血啊！果断不找了！ （别学我，因为刚刚在找这个帖子的时候，无意间瞥见另一个帖子， 解决方案是：在Application启动类中加上注解：@EnableJpaRepositories(&quot;com.example.repository&quot;)来说明要扫描的类， 虽然之前也在启动类中加过注释，但我也记不清这个到底有没有尝试过了， 感觉很靠谱，这里说一下！失败了也别来找我,也有可能环境不同） 所以！这是一个死循环啊，想要用dao层Repository，OK的，继承JPARepository吧， 等等，我jpa有条件的，entity呢？ 好，给你！ 慢着，我entity不干，先给cp一个数据库表吧，我可不打酱油的！唉，给你cp个表吧， 停！cp随便你，但是我有孩子，得带过去，你去问问entity同不同意！ 尼玛，可怕！！！ 于是，果断放弃了从dao层入手。 三、解决方案 JPA很强大，嗯，没错，是很强大！ 又是这句话，没错，我们如果映射实体类的话，那么目前的情况就感觉无用数据太多，而且累赘，要映射好几张表 但是别怕，jpa不但能面向对象查询，还支持原生sql，能够让我们根据自己的想法来实现 第一种：使用注解@Query(value=”sqlString”) 第二种：entityManager.createNativeQuery(sqlString) 第一种，注解在dao层的方法上，由于我自动装配出问题了，并且及早地放弃了，所以没用， 第二种，上代码 123456Query query = entityManager.createNativeQuery("select * from user where id = ?");query.setParameter(1,"g10001");List list = query.getResultList();Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put("name1",objs.get(0)[0].toString()); map.put("name2",objs.get(0)[1].toString());...... 搞定！list是List&lt;Object[]&gt;类型，里面放的就是一条条数据，而Object[]数组里面是一条数据中的所有字段。 不过又见几个坑，是网上的帖子，代码如下： 123for(Object os : list)&#123; Map map = (Map)os;&#125; 我只求数组（实际上是Object类型的数组）强转Map这波操作！！！！没别的要求 四、诙谐的话语，搞笑而又逗逼！就跟老朋友聊骚，听老朋友牢骚。轻松吗？]]></content>
      <categories>
        <category>java</category>
        <category>框架</category>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>实录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql建表时设置日期默认值及默认修改时间]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F12%2Fmysql%E5%BB%BA%E8%A1%A8%E6%97%B6%E8%AE%BE%E7%BD%AE%E6%97%A5%E6%9C%9F%E9%BB%98%E8%AE%A4%E5%80%BC%E5%8F%8A%E9%BB%98%E8%AE%A4%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[[TOC] 一、简单说明在做项目的时候，在数据库中基本上都会有关于日期的问题。其中不乏包括日期格式、运算、比较等等。不过这些都很常见了，今天要记录的点，非常简单，不过可能也是很多情况下忽略的东西。 关于这次记录的东西，就是mysql中时间格式的默认值。 很多时候，我们都会对一条数据的相关时间进行记录，比如创建日期，修改日期等等最常见的。而处理这些日期的大部分方法，一般是在后台中获取当前的时间，然后随着数据插入到表中进行保存。 下面，要说的是用mysql自带的方法来实现。（如果觉得没多大意义的话，请止步到此吧，如果想了解一下，请继续） 二、图文示例这里使用的版本是MySQL 5.6 1.mysql的日期和时间类型（这里会展示一下各种时间格式，不想看的跳过）先来看一下mysql中的日期和时间类型，以及其值的样子 - 在图中我们能够看到，我给所有的日期和时间类型赋值都是年/月/日 时:分:秒.毫秒 - 而最终查询出来的日期格式如列表展示，不同的类型，格式也不同 - 其中year类型只能赋值并保存年份，不过这个字段的赋值有点有意思的地方 1.1 year类型我们先来看看不同的赋值的结果 1.首先赋值0 2.然后1 应该有人应该猜出来了吧,不过我很好奇的是，这个赋值到底范围是多少，于是在这个过程中又遇到了有趣的事情 3.然后： 1到这里就能看出来，mysql日期虽然年份能够不用写完整的4位，但是对于只写两位数，mysql中还是有点范围的70表示1970，而0表示的是2000，很显然，最多就是99表示1999了，然后从1-69表示的是2001-2069，所以mysql非完整的年份默认值范围0-99 4.完整年份最大值 1不要问我怎么来的，我无聊 2.正题：设置默认时间1这个设置是创建该数据的当前时间 1.使用函数now() 1mysql中有函数可以在sql语句中直接使用（废话不解释了），now()都不陌生 1不过支持now()函数的只有datetime和timestamp两种类型，其他三种都不支持 2.current_（cur系列） 123我们可以利用default current_timestamp为timestamp类型的设置默认值不过很无奈的是，mysql中有current_date和current_time等，但是我这个版本却不能用， 3.自动记录修改时间 1在这里能够看到，id为1的这条数据时间变成了执行update时候的时间 1由于前两天接了新项目，所以写了一半就停下来了，今天有点时间，想着就写完它。勉强看，也算给自己做个记录]]></content>
      <categories>
        <category>DB</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>日期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
