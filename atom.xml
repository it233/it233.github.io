<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浮梦之殇</title>
  
  
  <link href="/it233.github.io/atom.xml" rel="self"/>
  
  <link href="https://it233.github.io/"/>
  <updated>2018-12-10T03:52:05.941Z</updated>
  <id>https://it233.github.io/</id>
  
  <author>
    <name>漠</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>字符串的扩展</title>
    <link href="https://it233.github.io/2018/12/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>https://it233.github.io/2018/12/07/字符串的扩展/</id>
    <published>2018-12-07T02:43:12.000Z</published>
    <updated>2018-12-10T03:52:05.941Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 加强了对Unicode的支持，并且扩展了字符串对象</p><h2 id="字符串的Unicode表示法"><a href="#字符串的Unicode表示法" class="headerlink" title="字符串的Unicode表示法"></a>字符串的Unicode表示法</h2><p>javaScript允许采用 \uxxxx 形式表示一个字符，其中xxxx表示字符的Unicode码点</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u0061"</span></span><br><span class="line"><span class="comment">// "a"</span></span><br></pre></td></tr></table></figure><p>但是，这种表示法只限于码点在 \u0000 ~ \uFFFF之间的字符，超出这个范围的字符串必须用两个双字节的形式表示</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\uD842\uDFB7"</span></span><br><span class="line"><span class="regexp">//</span> <span class="string">"𠮷"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u20BB7"</span></span><br><span class="line"><span class="regexp">//</span> <span class="string">" 7"</span></span><br></pre></td></tr></table></figure><p>如上，如果\u后面跟上超过0xFFFF的数值（如：\20BB7），JavaScript会理解成\u20BB+7</p><p>由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟一个7</p><p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。 </p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"<span class="tag">\<span class="name">u</span><span class="string">&#123;20BB7&#125;</span></span>"</span><br><span class="line">// "𠮷"</span><br><span class="line"></span><br><span class="line">"<span class="tag">\<span class="name">u</span><span class="string">&#123;41&#125;</span></span><span class="tag">\<span class="name">u</span><span class="string">&#123;42&#125;</span></span><span class="tag">\<span class="name">u</span><span class="string">&#123;43&#125;</span></span>"</span><br><span class="line">// "ABC"</span><br><span class="line"></span><br><span class="line">let hello = 123;</span><br><span class="line">hell<span class="tag">\<span class="name">u</span><span class="string">&#123;6F&#125;</span></span> // 123</span><br><span class="line"></span><br><span class="line">'<span class="tag">\<span class="name">u</span><span class="string">&#123;1F680&#125;</span></span>' === '<span class="tag">\<span class="name">uD</span></span>83D<span class="tag">\<span class="name">uDE</span></span>80'</span><br><span class="line">// true</span><br></pre></td></tr></table></figure><p>上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。</p><p>有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"<span class="tag">\<span class="name">u</span><span class="string">&#123;20BB7&#125;</span></span>"</span><br><span class="line">// "𠮷"</span><br><span class="line"></span><br><span class="line">"<span class="tag">\<span class="name">u</span><span class="string">&#123;41&#125;</span></span><span class="tag">\<span class="name">u</span><span class="string">&#123;42&#125;</span></span><span class="tag">\<span class="name">u</span><span class="string">&#123;43&#125;</span></span>"</span><br><span class="line">// "ABC"</span><br><span class="line"></span><br><span class="line">let hello = 123;</span><br><span class="line">hell<span class="tag">\<span class="name">u</span><span class="string">&#123;6F&#125;</span></span> // 123</span><br><span class="line"></span><br><span class="line">'<span class="tag">\<span class="name">u</span><span class="string">&#123;1F680&#125;</span></span>' === '<span class="tag">\<span class="name">uD</span></span>83D<span class="tag">\<span class="name">uDE</span></span>80'</span><br><span class="line">// true</span><br></pre></td></tr></table></figure><p>上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。</p><p>有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">'\z' === 'z'  <span class="comment">// true</span></span><br><span class="line">'\172' === 'z' <span class="comment">// true</span></span><br><span class="line">'\x7A' === 'z' <span class="comment">// true</span></span><br><span class="line">'\u007A' === 'z' <span class="comment">// true</span></span><br><span class="line">'\u&#123;7A&#125;' === 'z' <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h2><p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为<code>2</code>个字节。对于那些需要<code>4</code>个字节储存的字符（Unicode 码点大于<code>0xFFFF</code>的字符），JavaScript 会认为它们是两个字符。 </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">"𠮷"</span>;</span><br><span class="line"></span><br><span class="line">s.length <span class="comment">// 2</span></span><br><span class="line">s.charAt(<span class="number">0</span>) <span class="comment">// ''</span></span><br><span class="line">s.charAt(<span class="number">1</span>) <span class="comment">// ''</span></span><br><span class="line">s.charCodeAt(<span class="number">0</span>) <span class="comment">// 55362</span></span><br><span class="line">s.charCodeAt(<span class="number">1</span>) <span class="comment">// 57271</span></span><br></pre></td></tr></table></figure><p>上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是<code>0x20BB7</code>，UTF-16 编码为<code>0xD842 0xDFB7</code>（十进制为<code>55362 57271</code>），需要<code>4</code>个字节储存。对于这种<code>4</code>个字节的字符，JavaScript 不能正确处理，字符串长度会误判为<code>2</code>，而且<code>charAt</code>方法无法读取整个字符，<code>charCodeAt</code>方法只能分别返回前两个字节和后两个字节的值。 </p><p>ES6 提供了<code>codePointAt</code>方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。 </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let s = '𠮷a';</span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">0</span>) <span class="comment">// 134071</span></span><br><span class="line">s.codePointAt(<span class="number">1</span>) <span class="comment">// 57271</span></span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">2</span>) <span class="comment">// 97</span></span><br></pre></td></tr></table></figure><p><code>codePointAt</code>方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的<code>20BB7</code>）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，<code>codePointAt</code>方法的结果与<code>charCodeAt</code>方法相同。</p><p>总之，<code>codePointAt</code>方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与<code>charCodeAt</code>方法相同。</p><p><code>codePointAt</code>方法返回的是码点的十进制值，如果想要十六进制的值，可以使用<code>toString</code>方法转换一下。</p><p>疑问：既然用索引0表示第一个字，并且能够渠道完整的”𠮷”的码点，为什么索引为1还是取到”𠮷”的后两个码点？而索引为2才是取到第二个字符？没搞懂，实验出来确实是如上的结果！那么这样就会出现这样一种情况：一个字符串，里面的字符不确定到底是两个字节还是四个字节，也就是说不确定一个字符包含的码点到底是一个还是两个，这样取值的时候怎么办？就会出现位置无法确定！</p><p>先来看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 20bb7</span></span><br><span class="line"><span class="comment">// 61</span></span><br></pre></td></tr></table></figure><p>这里说明一下：在ES6环境下（ES5不知道，因为没有在ES5环境下测试过”𠮷a”这个字符串），使用split()将s拆成数组，数组长度为3，就是跟上面的结果一样，使用charAt()，根据索引取值，0和1都是只能取“𠮷”字的前两个字节和后两个字节，所以，这里就用for循环，注意是of，不能用in，使用in取得的是split()之后的索引（0，1，2），除了使用循环之外，还可以使用变量的解构赋值：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let s = '𠮷a';</span><br><span class="line">let [<span class="keyword">one</span>,<span class="keyword">two</span>] = <span class="built_in">s</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">one</span>,<span class="keyword">two</span>)</span><br><span class="line"><span class="comment">//20bb7 </span></span><br><span class="line"><span class="comment">//61</span></span><br></pre></td></tr></table></figure><p>以上两种方式,目前只想到了这两种能够完全获取字符串中完整的单个字符的码点方法</p><p>注意：对象的解构赋值也是长度为3，不可行，substr()、sbustring()、split()等等这些方法，都不行。就连indexOf(“a”)获得的索引都是2，很尴尬的结果</p><p>接下来，我们可以判断一个字符到底是两个字节还是四个字节组成的：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">is32Bit</span>(c) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">c.codePointAt(0)</span> &gt; <span class="number">0</span>xFFFF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is32Bit(<span class="string">"𠮷"</span>) // <span class="literal">true</span></span><br><span class="line">is32Bit(<span class="string">"a"</span>) // <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h2><p>ES5 提供<code>String.fromCharCode</code>方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于<code>0xFFFF</code>）。 </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span>.fromCharCode(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// "ஷ"</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>String.fromCharCode</code>不能识别大于<code>0xFFFF</code>的码点，所以<code>0x20BB7</code>就发生了溢出，最高位<code>2</code>被舍弃了，最后返回码点<code>U+0BB7</code>对应的字符，而不是码点<code>U+20BB7</code>对应的字符。</p><p>ES6 提供了<code>String.fromCodePoint</code>方法，可以识别大于<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode</code>方法的不足。在作用上，正好与<code>codePointAt</code>方法相反</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String.fromCodePoint(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line">String.fromCodePoint(<span class="number">0x78</span>, <span class="number">0x1f680</span>, <span class="number">0x79</span>) === 'x\uD83D\uDE80y'</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>String.fromCodePoint</code>方法有多个参数，则它们会被合并成一个字符串返回。 </p><p>如上第三行String.fromCodePoint(0x78, 0x1f680, 0x79)返回的字符串是：x🚀y </p><p>注意，<code>fromCodePoint</code>方法定义在<code>String</code>对象上，而<code>codePointAt</code>方法定义在字符串的实例对象上。 </p><h2 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h2><p>之前有说过（<a href="变量的解构赋值.md">变量的解构赋值</a>），实验表明，字符串是具备Iterator接口的，也就是能够循环，即遍历接口，这是ES6位字符串添加的，这样字符串就可以使用for…of循环便利，上面代码有例子，就不列举了</p><p>当然，除了便于遍历字符串，这个遍历器最大的有点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点</p><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">text</span>.length; i++) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="built_in">text</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// " "</span></span><br><span class="line"><span class="comment">// " "</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i of <span class="built_in">text</span>) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串<code>text</code>只有一个字符，但是<code>for</code>循环会认为它包含两个字符（都不可打印），而<code>for...of</code>循环会正确识别出这一个字符。 </p><h2 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h2><p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如<code>Ǒ</code>（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如<code>O</code>（\u004F）和<code>ˇ</code>（\u030C）合成<code>Ǒ</code>（\u004F\u030C）。</p><p>这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span>===<span class="string">'\u004F\u030C'</span> <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u01D1'</span><span class="selector-class">.length</span> <span class="comment">// 1</span></span><br><span class="line"><span class="string">'\u004F\u030C'</span><span class="selector-class">.length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。</p><p>ES6 提供字符串实例的<code>normalize()</code>方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span>.<span class="keyword">normalize</span>() === <span class="string">'\u004F\u030C'</span>.<span class="keyword">normalize</span>()</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>normalize</code>方法可以接受一个参数来指定<code>normalize</code>的方式，参数的四个可选值如下。</p><ul><li><code>NFC</code>，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</li><li><code>NFD</code>，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。</li><li><code>NFKC</code>，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，<code>normalize</code>方法不能识别中文。）</li><li><code>NFKD</code>，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</li></ul><figure class="highlight rsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u004F\u030C'</span>.<span class="built_in">normalize</span>(<span class="string">'NFC'</span>).<span class="built_in">length</span> <span class="comment">// 1</span></span><br><span class="line"><span class="string">'\u004F\u030C'</span>.<span class="built_in">normalize</span>(<span class="string">'NFD'</span>).<span class="built_in">length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码表示，<code>NFC</code>参数返回字符的合成形式，<code>NFD</code>参数返回字符的分解形式。</p><p>不过，<code>normalize</code>方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。</p><h2 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h2><p>传统上，JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p><ul><li><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</li><li><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let s = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="keyword">startsWith</span>(<span class="string">'Hello'</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="keyword">endsWith</span>(<span class="string">'!'</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'o'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这三个方法都支持第二个参数，表示开始搜索的位置。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let s = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="keyword">startsWith</span>(<span class="string">'world'</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="keyword">endsWith</span>(<span class="string">'Hello'</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p><h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h2><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.<span class="keyword">repeat</span><span class="comment">(3)</span> <span class="comment">// "xxx"</span></span><br><span class="line"><span class="string">'hello'</span>.<span class="keyword">repeat</span><span class="comment">(2)</span> <span class="comment">// "hellohello"</span></span><br><span class="line"><span class="string">'na'</span>.<span class="keyword">repeat</span><span class="comment">(0)</span> <span class="comment">// ""</span></span><br></pre></td></tr></table></figure><p>参数如果是小数，会被舍弃小数部分取整。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.<span class="keyword">repeat</span><span class="comment">(2.9)</span> <span class="comment">// "nana"</span></span><br></pre></td></tr></table></figure><p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.<span class="keyword">repeat</span><span class="comment">(Infinity)</span></span><br><span class="line"><span class="comment">// RangeError</span></span><br><span class="line"><span class="string">'na'</span>.<span class="keyword">repeat</span><span class="comment">(-1)</span></span><br><span class="line"><span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure><p>但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于<code>-0</code>，<code>repeat</code>视同为 0。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.<span class="keyword">repeat</span><span class="comment">(-0.9)</span> <span class="comment">// ""</span></span><br></pre></td></tr></table></figure><p>参数<code>NaN</code>等同于 0。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.<span class="keyword">repeat</span><span class="comment">(NaN)</span> <span class="comment">// ""</span></span><br></pre></td></tr></table></figure><p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'na'</span>) <span class="regexp">//</span> <span class="string">""</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'3'</span>) <span class="regexp">//</span> <span class="string">"nanana"</span></span><br></pre></td></tr></table></figure><h2 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h2><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="regexp">//</span> <span class="string">'ababx'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="regexp">//</span> <span class="string">'abax'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="regexp">//</span> <span class="string">'xabab'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="regexp">//</span> <span class="string">'xaba'</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>padStart()</code>和<code>padEnd()</code>一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。</p><p>如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'xxx'</span>.padStart(<span class="number">2</span>, <span class="string">'ab'</span>) <span class="regexp">//</span> <span class="string">'xxx'</span></span><br><span class="line"><span class="string">'xxx'</span>.padEnd(<span class="number">2</span>, <span class="string">'ab'</span>) <span class="regexp">//</span> <span class="string">'xxx'</span></span><br></pre></td></tr></table></figure><p>如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">'abc'.padStart(<span class="number">10</span>, '<span class="number">0123456789</span>')</span><br><span class="line"><span class="comment">// '0123456abc'</span></span><br></pre></td></tr></table></figure><p>如果省略第二个参数，默认使用空格补全长度。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>) <span class="regexp">//</span> <span class="string">'   x'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>) <span class="regexp">//</span> <span class="string">'x   '</span></span><br></pre></td></tr></table></figure><p><code>padStart()</code>的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="regexp">//</span> <span class="string">"0000000001"</span></span><br><span class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="regexp">//</span> <span class="string">"0000000012"</span></span><br><span class="line"><span class="string">'123456'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="regexp">//</span> <span class="string">"0000123456"</span></span><br></pre></td></tr></table></figure><p>另一个用途是提示字符串格式。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="regexp">//</span> <span class="string">"YYYY-MM-12"</span></span><br><span class="line"><span class="string">'09-12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="regexp">//</span> <span class="string">"YYYY-09-12"</span></span><br></pre></td></tr></table></figure><h2 id="matchAll"><a href="#matchAll" class="headerlink" title="matchAll()"></a>matchAll()</h2><p><code>matchAll</code>方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。</p><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="comment">'#result').append(</span></span><br><span class="line">  <span class="comment">'There are <span class="doctag">&lt;b&gt;</span>' + basket.count + '<span class="doctag">&lt;/b&gt;</span> ' +</span></span><br><span class="line">  <span class="comment">'items in your basket, ' +</span></span><br><span class="line">  <span class="comment">'<span class="doctag">&lt;em&gt;</span>' + basket.onSale +</span></span><br><span class="line">  <span class="comment">'<span class="doctag">&lt;/em&gt;</span> are on sale!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">$('#result').append(`</span></span><br><span class="line"><span class="xml">  There are <span class="tag">&lt;<span class="name">b</span>&gt;</span>$</span><span class="template-variable">&#123;basket.count&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span> items</span></span><br><span class="line"><span class="xml">   in your basket, <span class="tag">&lt;<span class="name">em</span>&gt;</span>$</span><span class="template-variable">&#123;basket.onSale&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span></span><br><span class="line"><span class="xml">  are on sale!</span></span><br><span class="line"><span class="xml">`);</span></span><br></pre></td></tr></table></figure><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line">`<span class="built_in">In</span> JavaScript <span class="string">'\n'</span> is a line-feed.`</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line">`<span class="built_in">In</span> JavaScript this is</span><br><span class="line"> <span class="built_in">not</span> legal.`</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(`string <span class="built_in">text</span> line <span class="number">1</span></span><br><span class="line">string <span class="built_in">text</span> line <span class="number">2</span>`);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line">let <span class="built_in">name</span> = <span class="string">"Bob"</span>, <span class="built_in">time</span> = <span class="string">"today"</span>;</span><br><span class="line">`Hello $&#123;<span class="built_in">name</span>&#125;, how are you $&#123;<span class="built_in">time</span>&#125;?`</span><br></pre></td></tr></table></figure><p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = `\`Yo\` World!`;</span><br></pre></td></tr></table></figure><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$('<span class="comment">#list').html(`</span></span><br><span class="line"><span class="variable">&lt;ul&gt;</span></span><br><span class="line">  <span class="variable">&lt;li&gt;</span>first<span class="variable">&lt;/li&gt;</span></span><br><span class="line">  <span class="variable">&lt;li&gt;</span>second<span class="variable">&lt;/li&gt;</span></span><br><span class="line"><span class="variable">&lt;/ul&gt;</span></span><br><span class="line">`);</span><br></pre></td></tr></table></figure><p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<code>&lt;ul&gt;</code>标签前面会有一个换行。如果你不想要这个换行，可以使用<code>trim</code>方法消除它。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$('<span class="comment">#list').html(`</span></span><br><span class="line"><span class="variable">&lt;ul&gt;</span></span><br><span class="line">  <span class="variable">&lt;li&gt;</span>first<span class="variable">&lt;/li&gt;</span></span><br><span class="line">  <span class="variable">&lt;li&gt;</span>second<span class="variable">&lt;/li&gt;</span></span><br><span class="line"><span class="variable">&lt;/ul&gt;</span></span><br><span class="line">`.trim());</span><br></pre></td></tr></table></figure><p>模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">authorize</span>(<span class="params">user, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!user.hasPrivilege(action)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="comment">// 传统写法为</span></span><br><span class="line">      <span class="comment">// 'User '</span></span><br><span class="line">      <span class="comment">// + user.name</span></span><br><span class="line">      <span class="comment">// + ' is not authorized to do '</span></span><br><span class="line">      <span class="comment">// + action</span></span><br><span class="line">      <span class="comment">// + '.'</span></span><br><span class="line">      <span class="string">`User <span class="subst">$&#123;user.name&#125;</span> is not authorized to do <span class="subst">$&#123;action&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span></span><br><span class="line"><span class="comment">// "1 + 2 = 3"</span></span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y * <span class="number">2</span>&#125;</span> = <span class="subst">$&#123;x + y * <span class="number">2</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">// "1 + 4 = 5"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="string">`<span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span></span><br><span class="line"><span class="comment">// "3"</span></span><br></pre></td></tr></table></figure><p>模板字符串之中还能调用函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br><span class="line"><span class="comment">// foo Hello World bar</span></span><br></pre></td></tr></table></figure><p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的<code>toString</code>方法。</p><p>如果模板字符串中的变量没有声明，将报错。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量place没有声明</span></span><br><span class="line"><span class="keyword">let</span> msg = `Hello, $&#123;place&#125;`;</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`Hello $&#123;<span class="string">'World'</span>&#125;`</span><br><span class="line"><span class="comment">// "Hello World"</span></span><br></pre></td></tr></table></figure><p>模板字符串甚至还能嵌套。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const tmpl = addrs =&gt; `</span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  $&#123;addrs.map(addr =&gt; `</span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;addr.first&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;addr.last&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  `).join('')&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const data = [</span><br><span class="line">    &#123; first: '<span class="tag">&lt;<span class="name">Jane</span>&gt;</span>', last: 'Bond' &#125;,</span><br><span class="line">    &#123; first: 'Lars', last: '<span class="tag">&lt;<span class="name">Croft</span>&gt;</span>' &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">console.log(tmpl(data));</span><br><span class="line">// <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">//</span><br><span class="line">//   <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">Jane</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">//   <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Bond<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">//</span><br><span class="line">//   <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Lars<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">//   <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">Croft</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">//</span><br><span class="line">// <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'return '</span> + <span class="string">'`Hello $&#123;name&#125;!`'</span>;</span><br><span class="line"><span class="keyword">let</span> func = <span class="keyword">new</span> <span class="function"><span class="keyword">Function</span><span class="params">(<span class="string">'name'</span>, str)</span></span>;</span><br><span class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'(name) =&gt; `Hello $&#123;name&#125;!`'</span>;</span><br><span class="line"><span class="keyword">let</span> func = <span class="keyword">eval</span>.call(<span class="keyword">null</span>, str);</span><br><span class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></span><br></pre></td></tr></table></figure><h2 id="实例：模板编译"><a href="#实例：模板编译" class="headerlink" title="实例：模板编译"></a>实例：模板编译</h2><p>下面，我们来看一个通过模板字符串，生成正式模板的实例。</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">let template = `</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">%</span> <span class="attr">for</span>(<span class="attr">let</span> <span class="attr">i</span>=<span class="string">0;</span> <span class="attr">i</span> &lt; <span class="attr">data.supplies.length</span>; <span class="attr">i</span>++) &#123; %&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">data.supplies</span>[<span class="attr">i</span>] %&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">`;</span></span><br></pre></td></tr></table></figure><p>上面代码在模板字符串之中，放置了一个常规模板。该模板使用<code>&lt;%...%&gt;</code>放置 JavaScript 代码，使用<code>&lt;%= ... %&gt;</code>输出 JavaScript 表达式。</p><p>怎么编译这个模板字符串呢？</p><p>一种思路是将其转换为 JavaScript 表达式字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span>(<span class="string">'&lt;ul&gt;'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i=0; i &lt; data.supplies.length; i++) &#123;</span><br><span class="line">  <span class="built_in">echo</span>(<span class="string">'&lt;li&gt;'</span>);</span><br><span class="line">  <span class="built_in">echo</span>(data.supplies[i]);</span><br><span class="line">  <span class="built_in">echo</span>(<span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">echo</span>(<span class="string">'&lt;/ul&gt;'</span>);</span><br></pre></td></tr></table></figure><p>这个转换使用正则表达式就行了。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">let evalExpr</span> = /&lt;%=(.+?)%&gt;/g;</span><br><span class="line"><span class="attribute">let expr</span> = /&lt;%([\s\S]+?)%&gt;/g;</span><br><span class="line"></span><br><span class="line"><span class="attribute">template</span> = template</span><br><span class="line">  .replace(evalExpr, <span class="string">'`); \n  echo( $1 ); \n  echo(`'</span>)</span><br><span class="line">  .replace(expr, <span class="string">'`); \n $1 \n  echo(`'</span>);</span><br><span class="line"></span><br><span class="line"><span class="attribute">template</span> = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;</span><br></pre></td></tr></table></figure><p>然后，将<code>template</code>封装在一个函数里面返回，就可以了。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let script =</span><br><span class="line">`(<span class="function"><span class="keyword">function</span> <span class="title">parse</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">  let <span class="built_in">output</span> = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">echo</span><span class="params">(html)</span></span>&#123;</span><br><span class="line">    <span class="built_in">output</span> += html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  $&#123; template &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">output</span>;</span><br><span class="line">&#125;)`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> script;</span><br></pre></td></tr></table></figure><p>将上面的内容拼装成一个模板编译函数<code>compile</code>。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compile</span><span class="params">(template)</span></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> evalExpr = /&lt;%=(.+?)%&gt;/g;</span><br><span class="line">  <span class="keyword">const</span> expr = /&lt;%([\s\S]+?)%&gt;/g;</span><br><span class="line"></span><br><span class="line">  template = template</span><br><span class="line">    .replace(evalExpr, <span class="string">'`); \n  echo( $1 ); \n  echo(`'</span>)</span><br><span class="line">    .replace(expr, <span class="string">'`); \n $1 \n  echo(`'</span>);</span><br><span class="line"></span><br><span class="line">  template = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> script =</span><br><span class="line">  `(<span class="function"><span class="keyword">function</span> <span class="title">parse</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> output = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">echo</span><span class="params">(html)</span></span>&#123;</span><br><span class="line">      output += html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $&#123; template &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;)`;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> script;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>compile</code>函数的用法如下。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">parse</span> = eval(<span class="keyword">compile</span>(template));</span><br><span class="line">div.innerHTML = <span class="built_in">parse</span>(&#123; supplies: [ <span class="string">"broom"</span>, <span class="string">"mop"</span>, <span class="string">"cleaner"</span> ] &#125;);</span><br><span class="line"><span class="comment">//   &lt;ul&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;broom&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;mop&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;cleaner&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//   &lt;/ul&gt;</span></span><br></pre></td></tr></table></figure><h2 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h2><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert`<span class="number">123</span>`</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="title">alert</span><span class="params">(<span class="number">123</span>)</span></span></span><br></pre></td></tr></table></figure><p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p><p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，模板字符串前面有一个标识名<code>tag</code>，它是一个函数。整个表达式的返回值，就是<code>tag</code>函数处理模板字符串后的返回值。</p><p>函数<code>tag</code>依次会接收到多个参数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span><span class="params">(stringArr, value1, value2)</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span><span class="params">(stringArr, <span class="rest_arg">...values</span>)</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tag</code>函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p><p><code>tag</code>函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此<code>tag</code>会接受到<code>value1</code>和<code>value2</code>两个参数。</p><p><code>tag</code>函数所有参数的实际值如下。</p><ul><li>第一个参数：<code>[&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;]</code></li><li>第二个参数: 15</li><li>第三个参数：50</li></ul><p>也就是说，<code>tag</code>函数实际上以下面的形式调用。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">tag</span><span class="params">([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>)</span></span></span><br></pre></td></tr></table></figure><p>我们可以按照需要编写<code>tag</code>函数的代码。下面是<code>tag</code>函数的一种写法，以及运行结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">s, v1, v2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(s[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(s[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(v1);</span><br><span class="line">  <span class="built_in">console</span>.log(v2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// "Hello "</span></span><br><span class="line"><span class="comment">// " world "</span></span><br><span class="line"><span class="comment">// ""</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 50</span></span><br><span class="line"><span class="comment">// "OK"</span></span><br></pre></td></tr></table></figure><p>下面是一个更复杂的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> total = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> msg = passthru<span class="string">`The total is <span class="subst">$&#123;total&#125;</span> (<span class="subst">$&#123;total*<span class="number">1.05</span>&#125;</span> with tax)`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; literals.length) &#123;</span><br><span class="line">    result += literals[i++];</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">      result += <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg <span class="comment">// "The total is 30 (31.5 with tax)"</span></span><br></pre></td></tr></table></figure><p>上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。</p><p><code>passthru</code>函数采用 rest 参数的写法如下。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span><span class="params">(literals, <span class="rest_arg">...values</span>)</span> </span>&#123;</span><br><span class="line">  let output = <span class="string">""</span>;</span><br><span class="line">  let index;</span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += literals[index] + values[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output += literals[index]</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message =</span><br><span class="line">  SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Escape special characters in the substitution.</span></span><br><span class="line">    s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't escape special characters in the template.</span></span><br><span class="line">    s += templateData[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>sender</code>变量往往是用户提供的，经过<code>SaferHTML</code>函数处理，里面的特殊字符都会被转义。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sender = <span class="string">'&lt;script&gt;alert("abc")&lt;/script&gt;'</span>; <span class="comment">// 恶意代码</span></span><br><span class="line"><span class="keyword">let</span> message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;</span><br><span class="line"></span><br><span class="line">message</span><br><span class="line"><span class="comment">// &lt;p&gt;&amp;lt;script&amp;gt;alert("abc")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;</span></span><br></pre></td></tr></table></figure><p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i18n`Welcome to <span class="variable">$&#123;siteName&#125;</span>, you are visitor number <span class="variable">$&#123;visitorNumber&#125;</span>!`</span><br><span class="line"><span class="regexp">//</span> <span class="string">"欢迎访问xxx，您是第xxxx位访问者！"</span></span><br></pre></td></tr></table></figure><p>模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的hashTemplate函数</span></span><br><span class="line"><span class="comment">// 是一个自定义的模板处理函数</span></span><br><span class="line"><span class="keyword">let</span> libraryHtml = hashTemplate`</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    #for book <span class="keyword">in</span> $&#123;myBooks&#125;</span><br><span class="line">      &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</span><br><span class="line">    #end</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">jsx`</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="xml">      ref='input'</span></span><br><span class="line"><span class="xml">      onChange='$</span><span class="template-variable">&#123;this.handleChange&#125;</span><span class="xml">'</span></span><br><span class="line"><span class="xml">      defaultValue='$</span><span class="template-variable">&#123;this.state.value&#125;</span><span class="xml">' /&gt;</span></span><br><span class="line"><span class="xml">      $</span><span class="template-variable">&#123;this.state.value&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">`</span></span><br></pre></td></tr></table></figure><p>上面的代码通过<code>jsx</code>函数，将一个 DOM 字符串转为 React 对象。你可以在 Github 找到<code>jsx</code>函数的<a href="https://gist.github.com/lygaret/a68220defa69174bdec5" target="_blank" rel="noopener">具体实现</a>。</p><p>下面则是一个假想的例子，通过<code>java</code>函数，在 JavaScript 代码之中运行 Java 代码。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java`</span><br><span class="line"><span class="keyword">class</span> <span class="title">HelloWorldApp</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(“Hello World!”); <span class="comment">// Display the string.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br><span class="line">HelloWorldApp.main();</span><br></pre></td></tr></table></figure><p>模板处理函数的第一个参数（模板字符串数组），还有一个<code>raw</code>属性。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log<span class="string">`123`</span></span><br><span class="line">// [<span class="string">"123"</span>, raw: <span class="symbol">Array</span>[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>上面代码中，<code>console.log</code>接受的参数，实际上是一个数组。该数组有一个<code>raw</code>属性，保存的是转义后的原字符串。</p><p>请看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tag<span class="string">`First line\nSecond line`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings.raw[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// strings.raw[0] 为 "First line\\nSecond line"</span></span><br><span class="line">  <span class="comment">// 打印输出 "First line\nSecond line"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>tag</code>函数的第一个参数<code>strings</code>，有一个<code>raw</code>属性，也指向一个数组。该数组的成员与<code>strings</code>数组完全一致。比如，<code>strings</code>数组是<code>[&quot;First line\nSecond line&quot;]</code>，那么<code>strings.raw</code>数组就是<code>[&quot;First line\\nSecond line&quot;]</code>。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将<code>\n</code>视为<code>\\</code>和<code>n</code>两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p><h2 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h2><p>ES6 还为原生的 String 对象，提供了一个<code>raw</code>方法。</p><p><code>String.raw</code>方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span>;</span><br><span class="line"><span class="comment">// 返回 "Hi\\n5!"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</span><br><span class="line"><span class="comment">// 返回 "Hi\\u000A!"</span></span><br></pre></td></tr></table></figure><p>如果原字符串的斜杠已经转义，那么<code>String.raw</code>会进行再次转义。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String.raw`Hi\\n`</span><br><span class="line">// 返回 <span class="string">"Hi\\\\n"</span></span><br></pre></td></tr></table></figure><p><code>String.raw</code>方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p><p><code>String.raw</code>方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应该是一个数组。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span>.raw(&#123; raw: <span class="string">'test'</span> &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 't0e1s2t'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">String</span>.raw(&#123; raw: [<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>] &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>作为函数，<code>String.raw</code>的代码实现基本如下。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String.raw = function (strings, ...values) &#123;</span><br><span class="line">  let output = '';</span><br><span class="line">  let <span class="keyword">index</span>;</span><br><span class="line">  for (<span class="keyword">index</span> = <span class="number">0</span>; <span class="keyword">index</span> &lt; <span class="keyword">values</span>.<span class="built_in">length</span>; <span class="keyword">index</span>++) &#123;</span><br><span class="line">    output += strings.<span class="keyword">raw</span>[<span class="keyword">index</span>] + <span class="keyword">values</span>[<span class="keyword">index</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output += strings.raw[<span class="keyword">index</span>]</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板字符串的限制"><a href="#模板字符串的限制" class="headerlink" title="模板字符串的限制"></a>模板字符串的限制</h2><p>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。</p><p>举例来说，标签模板里面可以嵌入 LaTEX 语言。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">latex</span></span>(strings) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let document = latex`</span><br><span class="line">\<span class="keyword">new</span><span class="type">command</span>&#123;\fun&#125;&#123;\textbf&#123;Fun!&#125;&#125;  <span class="comment">// 正常工作</span></span><br><span class="line">\<span class="keyword">new</span><span class="type">command</span>&#123;\unicode&#125;&#123;\textbf&#123;Unicode!&#125;&#125; <span class="comment">// 报错</span></span><br><span class="line">\<span class="keyword">new</span><span class="type">command</span>&#123;\xerxes&#125;&#123;\textbf&#123;King!&#125;&#125; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">Breve over the h goes \u&#123;h&#125;ere <span class="comment">// 报错</span></span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>document</code>内嵌的模板字符串，对于 LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。</p><p>模板字符串会将<code>\u00FF</code>和<code>\u{42}</code>当作 Unicode 字符进行转义，所以<code>\unicode</code>解析时报错；而<code>\x56</code>会被当作十六进制字符串转义，所以<code>\xerxes</code>会报错。也就是说，<code>\u</code>和<code>\x</code>在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。</p><p>为了解决这个问题，ES2018 <a href="https://tc39.github.io/proposal-template-literal-revision/" target="_blank" rel="noopener">放松</a>了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回<code>undefined</code>，而不是报错，并且从<code>raw</code>属性上面可以得到原始字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  strs[<span class="number">0</span>] === <span class="literal">undefined</span></span><br><span class="line">  strs.raw[<span class="number">0</span>] === <span class="string">"\\unicode and \\u&#123;55&#125;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">tag<span class="string">`\unicode and \u&#123;55&#125;`</span></span><br></pre></td></tr></table></figure><p>上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为<code>undefined</code>，但是<code>raw</code>属性依然可以得到原始字符串，因此<code>tag</code>函数还是可以对原字符串进行处理。</p><p>注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bad = `bad escape sequence: \unicode`; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ES6 加强了对Unicode的支持，并且扩展了字符串对象&lt;/p&gt;
&lt;h2 id=&quot;字符串的Unicode表示法&quot;&gt;&lt;a href=&quot;#字符串的Unicode表示法&quot; class=&quot;headerlink&quot; title=&quot;字符串的Unicode表示法&quot;&gt;&lt;/a&gt;字符串的Uni
      
    
    </summary>
    
      <category term="前端" scheme="https://it233.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ES6" scheme="https://it233.github.io/categories/%E5%89%8D%E7%AB%AF/ES6/"/>
    
    
      <category term="实录" scheme="https://it233.github.io/tags/%E5%AE%9E%E5%BD%95/"/>
    
      <category term="字符串扩展" scheme="https://it233.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>变量的解构赋值</title>
    <link href="https://it233.github.io/2018/12/05/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>https://it233.github.io/2018/12/05/变量的解构赋值/</id>
    <published>2018-12-05T08:15:56.000Z</published>
    <updated>2018-12-07T02:51:32.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6 允许按照一定模式，从数据和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）</p><p>之前，为变量赋值，只能为变量一个个地直接指定值，如：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">let a</span> = 1;</span><br><span class="line"><span class="attribute">let b</span> = 2;</span><br><span class="line"><span class="attribute">let c</span> = 3;</span><br></pre></td></tr></table></figure><p>ES6 之后允许写成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>上面代码表示，从数组[1,2,3]中取值，按照对应位置,分别给变量a，b，c进行赋值</p><p>本质上，这种写法属于“匹配模式”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p><h2 id="嵌套赋值"><a href="#嵌套赋值" class="headerlink" title="嵌套赋值"></a>嵌套赋值</h2><p>如下代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let [<span class="selector-tag">a</span>,[<span class="selector-tag">b</span>,c]] = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">a<span class="comment">//1</span></span><br><span class="line">b<span class="comment">//2</span></span><br><span class="line">c<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>这里代码结构互相嵌套，数组里面嵌套数组，不过只要能够在右边结构中找到相对应的位置，依然能够赋值成功</p><h2 id="不完全解构"><a href="#不完全解构" class="headerlink" title="不完全解构"></a>不完全解构</h2><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">let [,,d] = [1,2,3,4]</span><br><span class="line"><span class="attribute">d//3</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line">let [e] = [1,2,3,4]</span><br><span class="line"><span class="attribute">e//1</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line">let [a] = [[1,2]]</span><br><span class="line"><span class="attribute">a//[1,2]</span></span><br></pre></td></tr></table></figure><p>如上代码所展示，等号两边结构模式相同（都为数组），那么就会根据左边的结构，在右边的结构中寻找对应位置的值进行赋值</p><p>但是，如果分析右边结构之后，找不到与之对应的值，那么该位置的变量则为undefined:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let [a,b] = <span class="string">[[1,2]]</span></span><br><span class="line">a//[<span class="number">1</span>]</span><br><span class="line">b//undefined</span><br></pre></td></tr></table></figure><p>以上两种情况都属于不完全解构，指的是虽然等号两边的模式都一样，但是数据结构却有不同，导致等号两边的结构并不能完全对应起来，但是这样并不影响解构赋值的使用。</p><p>这样一来的结果，就是如果能够在等号右边对应位置找到对应的值，那么左边的变量就会赋予该值，否则为undefined</p><h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>在结构赋值的时候，还支持rest参数，这样的参数能够在不完全结构的情况下，将所有值保存起来。</p><p>需要说明注意的是：</p><ol><li>rest参数必须放在所有参数的最后面，因为这是一个用来扫尾的参数，简单来说就是当左边参数不够接收右边元素的时候，右边还有剩余的元素，那么解构将会直接将剩余的元素原封不动全部丢给rest参数</li><li>根据第一条，rest参数必须是最后一个，所以也就是说，rest参数也只能有一个</li></ol><p>rest参数写法如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let [a,...b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a<span class="comment">//1</span></span><br><span class="line">b<span class="comment">//[2,3]</span></span><br></pre></td></tr></table></figure><p>上面代码，等号左边采用了rest参数…b，表示匹配完之前的参数之后，等号右边剩余的所有元素直接给b（不论结构）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let [,<span class="selector-tag">a</span>,...b] = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">a<span class="comment">//2</span></span><br><span class="line">b<span class="comment">//[3,4]</span></span><br><span class="line"></span><br><span class="line">let [<span class="selector-tag">a</span>,...b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;name:<span class="string">"小明"</span>&#125;]</span><br><span class="line">a<span class="comment">//1</span></span><br><span class="line">b<span class="comment">//[2,3,Object],这个Object就是&#123;name:"1"&#125;</span></span><br><span class="line"><span class="comment">//如下打印name值是"小明"</span></span><br><span class="line">console.log(<span class="selector-tag">b</span>[<span class="number">2</span>].name)</span><br></pre></td></tr></table></figure><p>以上情况是在右边有多余元素的情况，那么假如右边元素少于左边参数：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [,a,...b] = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">a<span class="comment">//2</span></span><br><span class="line">b<span class="comment">//[]</span></span><br></pre></td></tr></table></figure><p>回想一下之前说的解构赋值，如果没有匹配的元素，其值就是undefined，但是这里的b在没有匹配到元素赋值的时候，确实一个空数组[]</p><p>简单解释一下：</p><p>既然我们的b是rest参数，也就是接收解构赋值的时候，需要考虑到，我们剩余的元素还有可能有多个，那么我们接受多个数组中的元素，自然是用数组来接收。</p><p>所以这个rest参数就是一个空数组，当解构完之后，右边元素还有剩余，就将元素按顺序一个一个地原封塞到rest参数中，而如果没有剩余元素了，那么就不用塞了，rest参数就保持一个空数组了</p><h2 id="解构原理"><a href="#解构原理" class="headerlink" title="解构原理"></a>解构原理</h2><p>如果等号右边的解构不是一个可以遍历的解构(详情参考Iterator)，那么解构操作会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [b] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [c] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [d] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [e] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [f] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上这些均会报错： is not iterable</span></span><br></pre></td></tr></table></figure><p>以上的代码语句，等号右边的值，要么是转为对象以后不具备Iterator接口（前5个表单时），要么本身就不具备Iterator接口（第六个表达式）</p><p>也就是说右边的数据要能够进行循环</p><p>说道这里，就要说一下字符串类型了，先看下面代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let [<span class="selector-tag">a</span>,<span class="selector-tag">b</span>,c,d,...e] = <span class="string">"这是一个字符串"</span></span><br><span class="line">a<span class="comment">//这</span></span><br><span class="line">b<span class="comment">//是</span></span><br><span class="line">c<span class="comment">//一</span></span><br><span class="line">d<span class="comment">//个</span></span><br><span class="line">e<span class="comment">//['字','符','串']</span></span><br></pre></td></tr></table></figure><p>其实说白了，字符串也就是一串字符，即多个字符的数组(集合)，按照一定顺序组成的一串文字。因此，在字符串解构赋值的时候，字符串被转换成了一个类似数组的对象</p><p>同时，对于set结构，也可以使用数组的结构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line">x <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure><p>事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">hhh</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a,b,c,d,e,f] = hhh();</span><br><span class="line"><span class="built_in">console</span>.log(a,b,c,d,e,f)<span class="comment">//0 1 1 2 3 5</span></span><br></pre></td></tr></table></figure><p>以上代码，hhh()是一个Generator函数，原生具有Iterator接口，解构赋值会依次从这个接口获取值</p><h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>解构赋值能够制定默认值，也就是当没有找到对应的元素给其赋值的时候，会采取制定的值为其赋值</p><p>如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let [<span class="selector-tag">a</span> = <span class="string">'1'</span>] = []</span><br><span class="line">a<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">let [<span class="selector-tag">b</span>,c=<span class="string">'3'</span>] = [<span class="number">5</span>]</span><br><span class="line">b<span class="comment">//5</span></span><br><span class="line">c<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">let [d = <span class="string">'1'</span>] = [<span class="string">'aaa'</span>]</span><br><span class="line">d<span class="comment">//aaa</span></span><br></pre></td></tr></table></figure><p>需要注意的是，ES6 内部使用雅阁想等运算符 (===)来判断一个位置是否有值。所以只有当一个数组成员严格等于undefined，默认值才会生效</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>如上面代码，一个值为null，默认值却没有生效，是因为null === undefined为false</p><p>另外，如果一个默认值是一个表达式（函数也属于一个表达式），那么这个表达式是惰性求值的，也就是只有在使用到这个表达式的时候，才会去运行求值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>上面代码不会执行f()函数，因为x能够在右边取到值，不会触发默认值</p><p>默认值也可以引用解构赋值的其他变量，但是该变量必须是在引用之前已经声明的</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [<span class="attr">x</span> = <span class="number">1</span>, <span class="attr">y</span> = x] = [];     // <span class="attr">x=1;</span> <span class="attr">y=1</span></span><br><span class="line"><span class="keyword">let</span> [<span class="attr">x</span> = <span class="number">1</span>, <span class="attr">y</span> = x] = [<span class="number">2</span>];    // <span class="attr">x=2;</span> <span class="attr">y=2</span></span><br><span class="line"><span class="keyword">let</span> [<span class="attr">x</span> = <span class="number">1</span>, <span class="attr">y</span> = x] = [<span class="number">1</span>, <span class="number">2</span>]; // <span class="attr">x=1;</span> <span class="attr">y=2</span></span><br><span class="line"><span class="keyword">let</span> [<span class="attr">x</span> = y, <span class="attr">y</span> = <span class="number">1</span>] = [];     // ReferenceError: y is not defined</span><br></pre></td></tr></table></figure><p>这个在之前的let &amp; const说过，就不赘述了</p><h1 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h1><p>解构赋值不仅可以用于数组，还可以用于对象</p><h2 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a&#125; = &#123;a:<span class="string">"这是a"</span>&#125;</span><br></pre></td></tr></table></figure><p>对象的解构赋值其数组的解构赋值模式一样，不过要注意的是，对象的解构赋值，是匹配等号右边对象中的属性名来赋值</p><p>如上面代码，let{a} ，会在右边的对象中{}找a这个名字的属性，然后取值赋值给左边的a，如果右边对象中没有这个属性，那么就为undefined,</p><p>如下代码</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a&#125; = &#123;b:<span class="string">"这是b,不是a"</span>&#125;</span><br></pre></td></tr></table></figure><p>同时，因为是按照对象的属性名进行匹配，所以并不是想数组一样要按照严格的顺序</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &#123;<span class="selector-tag">a</span>,b&#125; = &#123;<span class="selector-tag">b</span>:<span class="string">"这是b,不是a"</span>,<span class="selector-tag">a</span>:<span class="string">"这才是a"</span>&#125;</span><br></pre></td></tr></table></figure><p>而如果我们变量名与属性名不一致，但是还想要取到某个属性的值，我们可以这么写：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &#123;<span class="selector-tag">a</span>:b&#125; = &#123;c:<span class="string">"这是c"</span>,<span class="selector-tag">a</span>:<span class="string">"这才是a"</span>&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中，b才是变量，左边的a只是为了对应右边属性a，是说b要取属性a的值，这样变量b就会赋予属性a的值：”这才是a”</p><p>这样来说，对象的解构赋值可以看成以下代码的简写：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let&#123;<span class="selector-tag">a</span>:<span class="selector-tag">a</span>,<span class="selector-tag">b</span>:b&#125; = &#123;<span class="selector-tag">a</span>:<span class="string">"这是a"</span>,<span class="selector-tag">b</span>:<span class="string">"这是b"</span>&#125;</span><br><span class="line"><span class="comment">//简写为：</span></span><br><span class="line">let&#123;<span class="selector-tag">a</span>,b&#125; = &#123;<span class="selector-tag">a</span>:<span class="string">"这是a"</span>,<span class="selector-tag">b</span>:<span class="string">"这是b"</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套赋值-1"><a href="#嵌套赋值-1" class="headerlink" title="嵌套赋值"></a>嵌套赋值</h2><p>与数组一样，对象解构也能用于嵌套结构</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; y: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; p: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x // <span class="string">"Hello"</span></span><br><span class="line">y // <span class="string">"World"</span></span><br></pre></td></tr></table></figure><p>不过要注意并且要明白的是：这里的p是模式，不是变量，因此不会被赋值，</p><p>如果p也要作为变量赋值，可以这么写：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; y: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; p, p: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x // <span class="string">"Hello"</span></span><br><span class="line">y // <span class="string">"World"</span></span><br><span class="line">p // [<span class="string">"Hello"</span>, &#123;y: <span class="string">"World"</span>&#125;]</span><br></pre></td></tr></table></figure><p>更复杂一点的嵌套如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const <span class="keyword">node</span> <span class="title">= &#123;</span></span><br><span class="line"><span class="title">  loc</span>: &#123;</span><br><span class="line">    <span class="literal">start</span>: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; loc, loc: &#123; <span class="literal">start</span> &#125;, loc: &#123; <span class="literal">start</span>: &#123; line &#125;&#125; &#125; = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">line</span> // <span class="number">1</span></span><br><span class="line">loc  // Object &#123;<span class="literal">start</span>: Object&#125;</span><br><span class="line"><span class="literal">start</span> // Object &#123;line: <span class="number">1</span>, column: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>上面代码有三次解构赋值，分别是对<code>loc</code>、<code>start</code>、<code>line</code>三个属性的解构赋值。注意，最后一次对<code>line</code>属性的解构赋值之中，只有<code>line</code>是变量，<code>loc</code>和<code>start</code>都是模式，不是变量 </p><p>这种嵌套赋值几乎很少用，一般基本的赋值就能满足大部分应用需求</p><h2 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h2><p>对象的解构赋值也可以指定默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">'Something went wrong'</span> &#125; = &#123;&#125;;</span><br><span class="line">msg <span class="comment">// "Something went wrong"</span></span><br></pre></td></tr></table></figure><p>与数组默认值一样的是，想要默认值生效的条件也是对象的属性值严格等于undefined，属性值为null的时候并不会导致默认值生效</p><p>同时，如果解构失败，变量的值也会等于undefined，也能致使默认值生效</p><p>我们都知道，数组本质就是一个特殊的对象，因此可以对数组进行对象属性的解构：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">let</span> &#123;<span class="number">0</span> : <span class="built_in">first</span>, [arr.<span class="built_in">length</span> - <span class="number">1</span>] : <span class="built_in">last</span>&#125; = arr;</span><br><span class="line"><span class="built_in">first</span> // <span class="number">1</span></span><br><span class="line"><span class="built_in">last</span> // <span class="number">3</span></span><br></pre></td></tr></table></figure><p>上面代码对数组进行对象解构。数组<code>arr</code>的<code>0</code>键对应的值是<code>1</code>，<code>[arr.length - 1]</code>就是<code>2</code>键，对应的值是<code>3</code> </p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>如果解构模式是签到的对象，而且子对象所在的父属性不存在，那么将会报错</li></ol><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="keyword">let</span> &#123;foo: &#123;bar&#125;&#125; = &#123;baz: <span class="string">'baz'</span>&#125;;</span><br></pre></td></tr></table></figure><p>这里简答说明一下：</p><p>按照解构流程，我们会根据解构模式去对象中匹配foo属性（此属性根据解构模式来看也是一个模式（即对象）），而此时对象中没有foo属性，那么这个对象就是undefined，而我们再看解构模式中，要取的是该模式（foo）的属性bar，所以就应该是foo.bar，但是此时foo对象为undefined，故报错</p><ol start="2"><li>还要注意的一点是，如果想要将一个已经声明的let变量用于对象解构赋值，必须要非常小心，先看如下代码：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure><p>这个写法错误的原因是，我们用let声明了一个变量x，然后在{x}中使用这个变量，但是实际上JavaScript引擎会将{x}理解成一个代码块，这样就会发生语法上的错误。</p><p>如何解决这样的问题，我们可以不将大括号写在首行，这样可以避免将其解释为代码块</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">x</span><span class="comment">;</span></span><br><span class="line"><span class="comment">(&#123;x&#125; = &#123;x: 1&#125;);</span></span><br></pre></td></tr></table></figure><p>对于这一点，接下来进行解释：</p><h2 id="圆括号的问题"><a href="#圆括号的问题" class="headerlink" title="圆括号的问题"></a>圆括号的问题</h2><p>解构赋值虽然很方便，但是解析起来并不容日，对于编译器来说，一个式子到底是模式，还是表达式，从一开始是不知道的，只有等到解析的时候（解析到或者解析不到等号）才能知道</p><p>由此带来的问题是，如果模式中出现圆括号怎么处理</p><p>ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号</p><p>但是这条规则实际上不那么容易辨别，处理起来也相当麻烦。因此，如果可能，尽量不要在模式中放置圆括号</p><h3 id="不能使用圆括号"><a href="#不能使用圆括号" class="headerlink" title="不能使用圆括号"></a>不能使用圆括号</h3><p>以下解构赋值不能使用圆括号</p><p>####　变量赋值语句</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;x: (c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> (&#123;x: c&#125;) = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><p>以上6个语句都会报错，因为他们都是变量声明语句，模式不能使用圆括号</p><p>####　函数参数</p><p>要知道函数参数也是属于变量声明，因此不能带有圆括号</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">([<span class="params">(z)</span>])</span> </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">([z,<span class="params">(x)</span>])</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure><h4 id="赋值语句的模式"><a href="#赋值语句的模式" class="headerlink" title="赋值语句的模式"></a>赋值语句的模式</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line"><span class="comment">(&#123; p: a &#125;)</span> = &#123; p: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="comment">([a])</span> = [<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>上面代码将整个模式放在圆括号之中，导致报错。 </p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">// 报错</span></span><br><span class="line"><span class="xml">[(</span><span class="template-variable">&#123; p: a &#125;</span><span class="xml">), </span><span class="template-variable">&#123; x: c &#125;</span><span class="xml">] = [</span><span class="template-variable">&#123;&#125;</span><span class="xml">, </span><span class="template-variable">&#123;&#125;</span><span class="xml">];</span></span><br></pre></td></tr></table></figure><p>上面代码将一部分模式放在圆括号之中，导致报错。 </p><h3 id="可以使用圆括号"><a href="#可以使用圆括号" class="headerlink" title="可以使用圆括号"></a>可以使用圆括号</h3><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号 </p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="comment">(b)</span>] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line"><span class="comment">(&#123; p: (d)</span> &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[<span class="comment">(parseInt.prop)</span>] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>上面三行语句可以正确执行，</p><p>其一、因为首先他们都是赋值语句，而不是生命语句</p><p>其二、他们的圆括号部分都不属于模式的一部分</p><p>第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是<code>p</code>，而不是<code>d</code>；第三行语句与第一行语句的性质一致。 </p><h1 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h1><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象，然后在进行对象解构赋值</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a,toString:b&#125; = <span class="number">123</span></span><br><span class="line">a//undefined</span><br><span class="line">b//b是function toString()<span class="meta">&#123;.....&#125;</span>,</span><br></pre></td></tr></table></figure><p>这里的b是一个函数，是Number.prototype.toString指向的函数toString(){}</p><p>相应地，数字可以转为Number对象，那么布尔值也有对象Boolean</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="built_in">toString</span>: s&#125; = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>这里的s跟b一样，不过s是Boolean.prototype.toString</p><p>解构赋值的规则是，只要等号右边的值不是对象或者数组，就先将其转为对象，然后在进行对象解构赋值</p><p>不过要注意的是undefined和null都无法转为对象，所以对他们进行解构赋值，都会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h1 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h1><p>函数的参数也可以使用解构赋值 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code>。对于函数内部的代码来说，它们能感受到的参数就是<code>x</code>和<code>y</code>。 </p><p>下面是另一个例子。 </p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">[<span class="comment">[1, 2]</span>, <span class="comment">[3, 4]</span>]</span>.map((<span class="comment">[a, b]</span>) =&gt; a + b);</span><br><span class="line">// <span class="comment">[ 3, 7 ]</span></span><br></pre></td></tr></table></figure><h2 id="默认值-2"><a href="#默认值-2" class="headerlink" title="默认值"></a>默认值</h2><p>函数参数的解构也可以使用默认值 </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">move</span>(&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">move</span>(&#123;x: <span class="number">3</span>, y: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line"><span class="built_in">move</span>(&#123;x: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line"><span class="built_in">move</span>(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="built_in">move</span>(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>move</code>的参数是一个对象，通过对这个对象进行解构，得到变量<code>x</code>和<code>y</code>的值。如果解构失败，<code>x</code>和<code>y</code>等于默认值。 </p><p>从另一个角度来讲，如下的代码也是一种设置默认值的方式，但是却与上面的代码有很大差别：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">move</span>(&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">move</span>(&#123;x: <span class="number">3</span>, y: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line"><span class="built_in">move</span>(&#123;x: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line"><span class="built_in">move</span>(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line"><span class="built_in">move</span>(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码是为函数<code>move</code>的参数指定默认值，而不是为变量<code>x</code>和<code>y</code>指定默认值，所以当在整个参数为undefined的时候，才会致使默认值生效，所以会得到与前一种写法不同的结果。 </p><h1 id="解构赋值的用途"><a href="#解构赋值的用途" class="headerlink" title="解构赋值的用途"></a>解构赋值的用途</h1><p>变量的结构赋值用途很多，以下几个场景就能体验其优点：</p><h2 id="变量值互换"><a href="#变量值互换" class="headerlink" title="变量值互换"></a>变量值互换</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><p>如果按照以前的方式，我们还需要通过第三方中间量来帮助进行互换，而使用解构赋值的方式，可以直接进行变量值的交换，这样的写法不仅简介，而且易读，语义非常清晰</p><h2 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h2><p>我们都知道，想要一个函数返回多个值的话，我们需要利用数组或者对象，将着多个值借助数组或者对象带出来。不过比较麻烦的是，取值的问题。而有了解构赋值，那么取值的时候就会非常方便</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure><h2 id="函数参数的定义"><a href="#函数参数的定义" class="headerlink" title="函数参数的定义"></a>函数参数的定义</h2><p>解构赋值可以方便地将一组参数与变量名对应起来</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">([x, y, z])</span> <span class="comment">&#123; ... &#125;</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">([1, 2, 3])</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(<span class="comment">&#123;x, y, z&#125;</span>)</span> <span class="comment">&#123; ... &#125;</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="comment">&#123;z: 3, y: 2, x: 1&#125;</span>)</span>;</span></span><br></pre></td></tr></table></figure><h2 id="提取JSON数据"><a href="#提取JSON数据" class="headerlink" title="提取JSON数据"></a>提取JSON数据</h2><p>在解析JSON对象的数据时，解构赋值就显得尤为便利了</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  <span class="keyword">status</span>: <span class="string">"OK"</span>,</span><br><span class="line">  <span class="keyword">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; id, <span class="keyword">status</span>, <span class="keyword">data</span>: <span class="keyword">number</span> &#125; = jsonData;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(id, <span class="keyword">status</span>, <span class="keyword">number</span>);</span><br><span class="line">// <span class="number">42</span>, <span class="string">"OK"</span>, [<span class="number">867</span>, <span class="number">5309</span>]</span><br></pre></td></tr></table></figure><h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><p>我们应该这么做过，为了保证代码容错性，经常需要对函数的入参进行验证，防止出现空指针的异常</p><p>而我们通过解构赋值来给函数参数指定默认值，就不需要再在函数中判断参数，然后再给默认值的代码了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">async</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = <span class="keyword">function</span> () &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  cache = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  complete = <span class="keyword">function</span> () &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  crossDomain = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  global = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="comment">// ... more config</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="map结构的循环遍历"><a href="#map结构的循环遍历" class="headerlink" title="map结构的循环遍历"></a>map结构的循环遍历</h2><p>我们都知道，想要获取map的值要通过key来获取，而map的key一般可以是没有任何规律，所以想要循环就不会像数组那样简单。</p><p>不过我们可以通过解构赋值来方便低解决这个问题</p><p>Map结构原生支持Iterator接口，配合变量的解构赋值，获取key和value就如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">map</span> = <span class="keyword">new</span> Map();</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (let [<span class="built_in">key</span>, value] of <span class="built_in">map</span>) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="built_in">key</span> + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入模块的指定方法"><a href="#输入模块的指定方法" class="headerlink" title="输入模块的指定方法"></a><strong>输入模块的指定方法</strong></h2><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure><p>这些场景下，能够使用变量的解构赋值，都会是一种很便捷的方法，足以体现出解构赋值的强大</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组的解构赋值&quot;&gt;&lt;a href=&quot;#数组的解构赋值&quot; class=&quot;headerlink&quot; title=&quot;数组的解构赋值&quot;&gt;&lt;/a&gt;数组的解构赋值&lt;/h1&gt;&lt;h2 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="前端" scheme="https://it233.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ES6" scheme="https://it233.github.io/categories/%E5%89%8D%E7%AB%AF/ES6/"/>
    
    
      <category term="实录" scheme="https://it233.github.io/tags/%E5%AE%9E%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>let&amp;const</title>
    <link href="https://it233.github.io/2018/12/04/let&amp;const/"/>
    <id>https://it233.github.io/2018/12/04/let&amp;const/</id>
    <published>2018-12-04T07:47:18.000Z</published>
    <updated>2018-12-06T02:54:32.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p> ES6新增了let命令用来生命变量，而在之前写js的时候，我们都习惯了使用var，而let的用法也与之相似。</p><p>而存在了var命令来声明变量，为什么还要有let命令。</p><p>众所周知，使用var的话会出现很多的问题，如变量提升导致的各种赋值、取值的错误问题等等，想必前端的这类问题遇到不少。</p><p>为了有效的规避此类的问题，特推出了let命令。使用let声明的变量，只会在let命令所在的代码块内有效，也就是除了包含let命令的作用域，其他地方是访问不到这个变量的</p><h3 id="代码实验"><a href="#代码实验" class="headerlink" title="代码实验"></a>代码实验</h3><p>下面实录实验代码</p><ul><li>先来看一下var命令声明的变量</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">console.log(a) <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>这个代码运行之后，能够打印出a的值为10，然而我们的变量a是在{}区域中定义的，而console.log(a)是在该区域外面访问a，也就是在上一级调用低级区域中的变量，但是依然能够进行访问</p><ul><li>再来看一下let</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span>  a = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(a)<span class="comment">//10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)<span class="comment">//ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure><p>这个代码运行第三行会打印10，而第5行会报错：ReferenceError: a is not defined </p><p>这就是let的作用，在{}区域中定义的a，在该区域外（上级区域）是无法访问到该变量的，这样就不存在变量提升的问题了,而a变量也就只能作用在｛｝区域中</p><h3 id="问题研究"><a href="#问题研究" class="headerlink" title="问题研究"></a>问题研究</h3><ul><li>然后给大家展示一个很有趣的问题</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">b </span>= <span class="number">0</span><span class="comment">;</span></span><br><span class="line">for(var a = <span class="number">0</span><span class="comment">;a &lt;10;a++)&#123;</span></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">b </span>+= a<span class="comment">;</span></span><br><span class="line">        console.log(<span class="string">"for-"</span>+a+<span class="string">":"</span>+<span class="keyword">b)</span></span><br><span class="line"><span class="keyword"> </span>   &#125;, <span class="number">1000</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">var a = <span class="number">5</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">b+=a;</span></span><br><span class="line"><span class="keyword">console.log("0-9累加总和+5为："+b)</span></span><br></pre></td></tr></table></figure><p>按照正常逻辑，我们这块代码是要进行统计0-9累加的和，我们分析这段代码：</p><ol><li>先声明变量b为0，方便最后保存总和</li><li>写for循环，进行0-9的累加</li><li>然后定义变量a=5，b计算完之后再累加5，然后输出结果</li><li>正常逻辑算下来应该是45+5 = 50</li><li>结果呢？</li></ol><p><img src="/2018/12/04/let&const/let&amp;const/1.png" alt=""></p><p>我想，和我一样先学java后来学js的人，起初很痛苦吧。为什么呢？为什么呢？</p><p>这个具体如何解释我也不太能理解，到底for循环的a与后面定义的a是否同一个？还是后面定义的把之前的给覆盖掉了？分不太清，只知道在等1s之后，执行b+=a的时候，拿到的a是5，最后赋值为5的那个a</p><p>除此之外，还有一个比较好玩的是：把后面var a = 5去掉，又会出现另一个问题</p><h3 id="分析解释"><a href="#分析解释" class="headerlink" title="分析解释"></a>分析解释</h3><ul><li>实验之前的那个循环把var改成let，会出现什么情况</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">b </span>= <span class="number">0</span></span><br><span class="line">for(let a = <span class="number">0</span><span class="comment">;a &lt;10;a++)&#123;</span></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">b </span>+= a </span><br><span class="line">        console.log(<span class="string">"for-"</span>+a+<span class="string">":"</span>+<span class="keyword">b)</span></span><br><span class="line"><span class="keyword"> </span>   &#125;, <span class="number">1000</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">var a = <span class="number">5</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">b+=a;</span></span><br><span class="line"><span class="keyword">console.log("0-9累加总和+5为："+b)</span></span><br></pre></td></tr></table></figure><p><img src="/2018/12/04/let&const/let&amp;const/2.png" alt=""></p><p>虽然顺序有问题（setTimeout()函数异步延时），但是最终结果是正确的</p><ul><li>好了，我们来看一下之前说的去掉后面定义的var会出现什么问题</li></ul><p>var：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(<span class="name">var</span> a = <span class="number">0</span><span class="comment">;a &lt;10;a++)&#123;</span></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">"for-"</span>+a)</span><br><span class="line">    &#125;, <span class="number">1000</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">console.log()</span><br></pre></td></tr></table></figure><p>为了方便，我们只保留了循环，结果如下</p><p><img src="/2018/12/04/let&const/let&amp;const/3.png" alt=""></p><p>let：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(<span class="name">let</span> a = <span class="number">0</span><span class="comment">;a &lt;10;a++)&#123;</span></span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(<span class="string">"for-"</span>+a)</span><br><span class="line">    &#125;, <span class="number">1000</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">console.log()</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2018/12/04/let&const/let&amp;const/4.png" alt=""></p><p>为什么会出现这样的情况，别急，我们来调试一下看看会不会发现什么：</p><p>我们先来看看var：</p><ul><li>断点就打在第一行，for，然后启动调试，注意看变量这块</li></ul><p><img src="/2018/12/04/let&const/let&amp;const/5.png" alt=""></p><p>在这里要说一下刚刚大家能够看到，我们这张图是启动调试之后未做任何操作的第一张图，但是这时候Local中就已经存在了a，这是为什么？是node.js在遇到变量声明的时候，会将声明放在第一行，先声明变量，然后在继续执行</p><ul><li>当我们走到第二行，那么a就创建成功了，我们来观察变量看看有什么值得注意的？</li></ul><p><img src="/2018/12/04/let&const/let&amp;const/6.png" alt=""></p><p>看到Local下面a。这是本地变量。而之前为undefined，通过第一行的赋值之后(声明被提升到了上面，所以第一行只完成了一个赋值)，它的值是0 </p><ul><li>接下来我们一直调试到第六行，然后能发现这个情况：</li></ul><p><img src="/2018/12/04/let&const/let&amp;const/7.png" alt=""></p><ul><li>然后我们放开调试，直接执行到底</li></ul><p><img src="/2018/12/04/let&const/let&amp;const/8.png" alt=""></p><p>然后我们来看看let</p><p><img src="/2018/12/04/let&const/let&amp;const/9.png" alt=""></p><ul><li>调试走一步</li></ul><p><img src="/2018/12/04/let&const/let&amp;const/10.png" alt=""></p><p>这里出现了Block：这是块级作用域，ES6新加的，后面会说到。这就是不同，这样就说明这个for中声明的a就是只能作用在这个块中，其他地方用不了，也拿不到，所以结果是，不说了。都知道了</p><h3 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h3><ul><li>大家应该知道，使用var命令声明的变量，任何时候都可以重复声明，而所有变量都是指向同一个全局变量</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">0</span></span><br><span class="line">console.log(a) <span class="comment">//0</span></span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure><ul><li>而使用let命令声明的变量却不同，也就是说let声明的变量只能有一个，不能与已存在的变量重名</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">0</span></span><br><span class="line">console.log(a)</span><br><span class="line">let <span class="selector-tag">a</span> = <span class="number">10</span>  <span class="comment">//SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure><ul><li>不只是在之后声明，在之前声明也是报错（为什么?已经解释过了）：</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let <span class="selector-tag">a</span> = <span class="number">0</span></span><br><span class="line">console.log(a)</span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">10</span>  <span class="comment">//SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>var指令</li></ul><ol><li>var声明的变量a，在全局范围内都有效，所以全局只有一个变量a</li><li>在循环中，每一次循环，变量a的值都会发生改变，如果a的声明执行为var，循环内的a指向的就是全局的a</li><li>使用var指令如果先声明了一个变量a，之后又使用var指令声明一个变量a，这个时候不会报错，两个变量a都是指向同一个变量，也只有一个变量a</li><li>var声明的变量a，在任何时候调用的，都是当前a的值，也就是我们使用setTimeOut（）延时调用a的时候，所有a都是最后一个值</li><li>var命令会发生变量提升现象，即在变量声明之前可以使用，不过值为undefined。也就是之前说的，node.js执行代码之前，先把var声明的变量都提升到最前面，先声明所有变量，值为undefined，在继续执行后面的代码，遇到赋值的时候就赋值，调用的时候就调用</li></ol><ul><li>let指令</li></ul><ol><li>let指令声明的a，只在当前当前的作用域内有效</li><li>在循环中，let声明的a，只在本轮循环中有效，所以每次循环的a其实都是一个新的变量</li><li>每次循环的a都是新的变量，却能够知道上一轮循环a的值，是因为JavaScript引擎内部会记住上一轮循环的值，初始化本轮的变量a时，就在上一轮循环的基础上进行计算</li><li>for循环的特别之处：设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域</li><li>使用let声明的变量，不会发生变量提升，所以在声明它之前，该变量相当于(为什么是相当于，看完后面希望理解)是不存在的，如果在声明之前调用该变量，会报错</li><li>使用let声明的变量，在同一个区域之中是唯一的，即无论以哪种形式声明了变量a，在该区域中之后的代码里都无法再使用let声明变量a</li></ol><h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><h3 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h3><ul><li>所说的暂时性死区，就是在let命令声明变量之前，该变量都是不可用的，这一部分代码区间就称为暂时性死区</li><li>例如有一段代码，有一块区域占据总代码的第10~30行，其中有let命令声明的变量在该区域的第20行，那么这块区域的第10~20行就是该变量的“暂时性死区”（temporal dead zone，TDZ）</li></ul><h3 id="变量绑定区域与TDZ"><a href="#变量绑定区域与TDZ" class="headerlink" title="变量绑定区域与TDZ"></a>变量绑定区域与TDZ</h3><p>所谓的变量绑定区域，就是指如果一个块级作用域内存在let命令声明的变量a，那么这个变量就会绑定这个区域，并且不会再受到外部的影响，及时在外部又声明了与该变量相同名称的变量a，也不会影响到这个区域中的变量a</p><p>如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">0</span></span><br><span class="line">&#123;</span><br><span class="line">    console.log(a)<span class="comment">//0</span></span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，存在一个var命令的变量a，但是在块级区域的代码中又进行了一次变量a的声明(var)，这样的代码是可以通过的</p><p>但是有这种情况：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">0</span></span><br><span class="line">&#123;</span><br><span class="line">    console.log(a)</span><br><span class="line">    let <span class="selector-tag">a</span> = <span class="number">10</span><span class="comment">//ReferenceError: a is not defined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里有两点：变量绑定区域以及暂时性死区</li></ul><p>ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就是用这些变量的，就会报错</p><p>所以在代码行2~5这个区块之间，存在let声明的变量a，那么1声明的变量a对于2~5这个区块就是无效的，因为let a已经绑定了这个区块，同时因为let变量的唯一性，不允许var变量再来插足。而2~4行，就是let a的死区，是无法调用变量a的</p><p>“暂时性死区”也就意味着typeof不再是一个百分之百安全的操作</p><p>下面为对比代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a)<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> b)<span class="comment">//undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> a)  <span class="comment">//报错：ReferenceError: a is not defined</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码能够看得出来</p><ol><li>var变量因为变量提升，所以在声明代码之前就能调用，只不过是undefined</li><li>如果没有声明的变量，他就是undefined</li><li>但是let变量在声明之前，虽然也是undefined，但是规定在死区中是无法调用的，会报错</li></ol><p>配图如下：</p><p><img src="/2018/12/04/let&const/let&amp;const/11.png" alt=""></p><p><img src="/2018/12/04/let&const/let&amp;const/12.png" alt=""></p><h3 id="关于隐蔽死区的示例"><a href="#关于隐蔽死区的示例" class="headerlink" title="关于隐蔽死区的示例"></a>关于隐蔽死区的示例</h3><h4 id="示例一、函数入参"><a href="#示例一、函数入参" class="headerlink" title="示例一、函数入参"></a>示例一、函数入参</h4><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function <span class="function"><span class="keyword">fun</span>(<span class="title">x</span></span> = y, y = <span class="number">2</span>)&#123;<span class="regexp">//</span><span class="symbol">ReferenceError:</span> y is not defined</span><br><span class="line">    <span class="keyword">return</span> [x,y]</span><br><span class="line">&#125;</span><br><span class="line">a = <span class="function"><span class="keyword">fun</span>()</span></span><br><span class="line"><span class="function"><span class="title">console</span></span>.log(a)</span><br></pre></td></tr></table></figure><p>以上代码的意思就是定义一个函数，这个函数有两个参数，x和y</p><p>并且给两个参数默认值，x的默认值是y的值，y的默认值是2</p><p>这里会报错:ReferenceError: y is not defined(可能某些情况下不会报错)</p><p>为什么会报错，简单说一下：</p><p>首先，这里报错y，是第一个参数的x = y这里报错，这里的y未找到</p><p>为什么？因为在这个fun()的区块中，有声明y，不过是第二个参数声明的，所以在第一个参数调用就是y的死区，</p><p>如果将两个参数互换一下位置，那么这段代码就能正确执行了</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="title">y</span> = <span class="title">2</span> , <span class="title">x</span> = <span class="title">y</span>)&#123;</span></span><br><span class="line">    <span class="literal">return</span> [x,y]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">a</span> = bar()</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">a</span>)<span class="comment">//Array(2) [2, 2]</span></span><br></pre></td></tr></table></figure><p>####　实例二、声明赋值</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = a</span><br><span class="line">console.log(a)　<span class="comment">//undefined</span></span><br><span class="line">let <span class="selector-tag">b</span> = <span class="selector-tag">b</span><span class="comment">//ReferenceError: b is not defined</span></span><br><span class="line">console.log(b)</span><br></pre></td></tr></table></figure><p>这里依旧是死区的问题，上面的对比代码，var a= a赋值的时候运行正常，是因为var变量没有死区的</p><p>而let b = b报错，是因为=后的b属于调用变量b，而这个区块中有声明b的let命令，所以在b没有完全声明之前调用了b，这就是一个死区</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>在ES5中只有全局作用域和函数作用域，没有块级作用域，这样会带来很多问题：</p><h3 id="问题一、内层变量可能会覆盖外层变量"><a href="#问题一、内层变量可能会覆盖外层变量" class="headerlink" title="问题一、内层变量可能会覆盖外层变量"></a>问题一、内层变量可能会覆盖外层变量</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = new Date();</span><br><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    console.log(a)  <span class="comment">//Wed Dec 05 2018 14:21:35 GMT+0800 (中国标准时间) &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>而如果是这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = new Date();</span><br><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    console.log(a)<span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>为什么会这样呢？是因为变量提升，由于在fun()中也有声明a变量，所以a变量的声明就提升到了函数最顶端进行声明，这时候a就是undefined，这个时候是因为fun()的a覆盖了上层的a</p><h3 id="问题二、区块变量泄露为全局变量"><a href="#问题二、区块变量泄露为全局变量" class="headerlink" title="问题二、区块变量泄露为全局变量"></a>问题二、区块变量泄露为全局变量</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'abcdefg'</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)   <span class="comment">//7</span></span><br></pre></td></tr></table></figure><p>这里在循环结束之后，i的值依然存在，还是能够获取到</p><h3 id="ES6的块级作用域"><a href="#ES6的块级作用域" class="headerlink" title="ES6的块级作用域"></a>ES6的块级作用域</h3><p>let实际上是为JavaScript新增了块级作用域</p><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a:"</span>,a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">5</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line">fun()<span class="comment">//10</span></span><br><span class="line">fun2()<span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>从这段代码的执行结果能够看得出来，var变量内层变量会影响到上层变量，但是let变量却不会</p><p>之前说过，let变量是绑定区域的，所以在一个区域中，同样的变量（名字相同）只会存在一个</p><p>而如果下层let变量与上层let变量同名的话，不会互相影响，采用就近原则</p><p>同时块级作用域的出现，也使得立即执行函数表达式不再必要了</p><h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h3><p>函数能不能在块级作用域之中声明？</p><p>ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域中声明</p><p>如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"fun"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"fun2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实以上两种函数声明，根据ES5的规定都是非法的</p><p>但是浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上米昂两种情况实际上都能运行，不会报错。</p><p>而ES6引入了块级作用域，明确允许在块级作用域之中声明函数</p><p>同时，ES6规定，块级作用域之中。函数声明语句的行为类似于let，在块级作用域之外不能被引用</p><p>除此之外：需要注意的是，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响，为了减轻因此产生的不兼容问题，ES6在附录B里规定，浏览器的实现可不遵守上面的规定，有自己的行为方式。</p><ul><li>允许在块级作用域内声明函数<ul><li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部</li><li>同时，函数声明还会提升到所在的块级作用域的头部</li></ul></li></ul><p>注意：上面三条规则只对ES6的的浏览器有效，其他环境的而实现不用遵守，还是将块级作用域的函数声明当作let处理</p><p>所以，考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数，</p><p>如果确实需要，也应该写成函数表达式，而不是函数声明语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//函数声明语句</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">'abcdefg'</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//函数表达式</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="string">'abcdefg'</span></span><br><span class="line">    <span class="keyword">let</span> fu = <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>我们都知道，写块级（如if，循环），如果区域中只有一行代码，可以省略大括号</p><p>但是在块级作用域声明函数，即使如这样形式的函数：</p><p>function fun(){}</p><p>这也不是代表只有一行代码，所以如果在块级作用域声明函数，如果没有块级作用域的大括号，会报错</p><h2 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>const是声明一个常量，这个常量是只读的，就是能够读取其值，但是不能改变它的值</p><h3 id="const常量注意点"><a href="#const常量注意点" class="headerlink" title="const常量注意点"></a>const常量注意点</h3><h4 id="1-常量一旦声明之后，就不能改变"><a href="#1-常量一旦声明之后，就不能改变" class="headerlink" title="1. 常量一旦声明之后，就不能改变"></a>1. 常量一旦声明之后，就不能改变</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const a = <span class="number">0</span>;</span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><h4 id="2-常量的值必须在声明的时候就立即初始化，不能留到以后赋值"><a href="#2-常量的值必须在声明的时候就立即初始化，不能留到以后赋值" class="headerlink" title="2.常量的值必须在声明的时候就立即初始化，不能留到以后赋值"></a>2.常量的值必须在声明的时候就立即初始化，不能留到以后赋值</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a<span class="comment">;</span></span><br><span class="line">// SyntaxError: Missing initializer <span class="keyword">in</span> <span class="keyword">const</span> declaration</span><br></pre></td></tr></table></figure><h3 id="const命令-1"><a href="#const命令-1" class="headerlink" title="const命令"></a>const命令</h3><p>####１.作用域</p><p>const的作用域与let命令相同：只在声明所在的块级作用域有效</p><h4 id="2-暂时性死区"><a href="#2-暂时性死区" class="headerlink" title="2.暂时性死区"></a>2.暂时性死区</h4><p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明之后使用</p><h4 id="3-唯一性"><a href="#3-唯一性" class="headerlink" title="3.唯一性"></a>3.唯一性</h4><p>const声明的常量,也与let一样,在同一块级区域中不可重复声明，具有唯一性</p><h2 id="const本质"><a href="#const本质" class="headerlink" title="const本质"></a>const本质</h2><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>做过后台，有研究过常量的人，应该知道，所说的常量，指的就是这个变量在栈中保存的值不会改变。而如果是指向某个对象的话，那么就是执行某个对象的地址不能改变，而对象中的属性可以随意改变。</p><h3 id="简述-2"><a href="#简述-2" class="headerlink" title="简述"></a>简述</h3><p>const实际上也是如此，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的书怒不得改动。</p><p>对于简单类型的数据（数值、字符创、布尔），值就保存在变量指向的那个内存地址，因此等同于常量。</p><p>但是对于符合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保持这个指针是固定不变的（总是指向某一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了</p><p>如下代码：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"><span class="comment">// 为 a 添加一个属性，可以成功</span></span><br><span class="line">a.<span class="keyword">prop</span> = 123;</span><br><span class="line">a.<span class="keyword">prop</span> <span class="comment">// 123</span></span><br><span class="line"><span class="comment">// 将 a 指向另一个对象，就会报错</span></span><br><span class="line">a = &#123;&#125;; <span class="comment">// TypeError: "a" is read-only</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>); <span class="comment">// 可执行</span></span><br><span class="line">a.length = <span class="number">0</span>;    <span class="comment">// 可执行</span></span><br><span class="line">a = [<span class="string">'Dave'</span>];    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>###　扩展</p><h4 id="冻结对象"><a href="#冻结对象" class="headerlink" title="冻结对象"></a>冻结对象</h4><p>如果真的想将对象冻结，即对象已经创建，其数据结构不能改变，要用Object.freeze方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>除此之外，如果还要将对象的属性冻结，下面代码是一个能够将对象彻底冻结的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原理就是如果对象的属性还是对象的话，就递归调用，将这个对象冻结，直到所有对象属性全部被冻结</p><h4 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h4><p>ES5只有两种声明变量的方法：var命令和function命令。</p><p>ES6除了添加let和const命令，还有另外两种声明变量的方法：import命令和class命令</p><h2 id="顶层对象"><a href="#顶层对象" class="headerlink" title="顶层对象"></a>顶层对象</h2><h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h3><p>顶层对象，在浏览器环境指的就是window对象，在Node指的就是global对象</p><p>ES5之中，顶层对象的属性与全局变量是等价的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>这个代码，顶层对象的属性赋值与全局变量的赋值，是同一件事，也就是说全局变量 就是 顶层对象的属性 </p><p>顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。</p><p>这样的设计带来几个很大的问题：</p><p>首先是没法在编译时就报出变量未声明的错误，只有运行时材能知道（因为全局变量很可能是顶层对象的属性创造的，而属性的创造是动态的）</p><p>其次，程序员很容易不知不倦就创建了全局变量</p><p>最后，顶层对象的属性是导出可以有读写的，这非常不利于模块化编程</p><p>另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的</p><p>ES6为了改变这一点，</p><p>一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性</p><p>另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性</p><p>也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这段代码中，全局变量a由var命令声明，所以它是顶层对象的属性；</p><p>全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined</p><h3 id="global对象"><a href="#global对象" class="headerlink" title="global对象"></a>global对象</h3><p>ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的</p><ul><li>浏览器里面，顶层对象是window，但是Node和Web Worker没有window</li><li>浏览器和Web Worker里面，self也指向顶层对象，但是Node没有self</li><li>Node里面，顶层对象是global，但其他环境都不支持</li></ul><p>同一段代码为了能够在各种环境都能取到顶层对象，现在一般是使用this变量，但是有局限性：</p><ul><li>全局环境中，this会返回顶层对象。但是Node模块和ES6模块中，this返回的是当前模块</li><li>函数里面的this，如果函数不是作为对象的方法运行，而是淡村作为函数运行，this会指向顶层对象。但是严格模式下，这时this会返回undefined</li><li>不管是严格模式还是普通模式，new Function(‘return this’)()总会返回全局对象。但是如果浏览器用了CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法可能无法使用</li></ul><p>综上所述，很难找到一种方法，可以在所有情况下都渠道顶层对象。</p><p>下面是两种勉强可以使用的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span></span><br><span class="line">   ? <span class="built_in">window</span></span><br><span class="line">   : (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> <span class="built_in">require</span> === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> global === <span class="string">'object'</span>)</span><br><span class="line">     ? global</span><br><span class="line">     : <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> global; &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。</p><p>垫片库system.global模拟了这个天，可以在所有环境拿到global</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS 的写法</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'system.global/shim'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 模块的写法</span></span><br><span class="line"><span class="keyword">import</span> shim <span class="keyword">from</span> <span class="string">'system.global/shim'</span>; shim();</span><br></pre></td></tr></table></figure><p>上面代码可以保证各种环境里面，<code>global</code>对象都是存在的。 </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS 的写法</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">global</span> = <span class="keyword">require</span>(<span class="string">'system.global'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 模块的写法</span></span><br><span class="line">import getGlobal <span class="keyword">from</span> <span class="string">'system.global'</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">global</span> = getGlobal();</span><br></pre></td></tr></table></figure><p>上面代码将顶层对象放入变量<code>global</code> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;let命令&quot;&gt;&lt;a href=&quot;#let命令&quot; class=&quot;headerlink&quot; title=&quot;let命令&quot;&gt;&lt;/a&gt;let命令&lt;/h2&gt;&lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简
      
    
    </summary>
    
      <category term="前端" scheme="https://it233.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ES6" scheme="https://it233.github.io/categories/%E5%89%8D%E7%AB%AF/ES6/"/>
    
    
      <category term="let" scheme="https://it233.github.io/tags/let/"/>
    
      <category term="const" scheme="https://it233.github.io/tags/const/"/>
    
      <category term="实录" scheme="https://it233.github.io/tags/%E5%AE%9E%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>java整型封装类Integer的比较</title>
    <link href="https://it233.github.io/2018/11/29/java%E6%95%B4%E5%9E%8B%E5%B0%81%E8%A3%85%E7%B1%BBInteger%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>https://it233.github.io/2018/11/29/java整型封装类Integer的比较/</id>
    <published>2018-11-29T02:31:30.000Z</published>
    <updated>2018-12-05T09:20:36.590Z</updated>
    
    <content type="html"><![CDATA[<p>【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！</p><hr><h1 id="一、浅说（这里说的是废话）"><a href="#一、浅说（这里说的是废话）" class="headerlink" title="一、浅说（这里说的是废话）"></a>一、浅说（这里说的是废话）</h1><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>​    我们日常中经常会使用的数字来进行各种计算，比如1，2，3等这些自然数，当然这些自然数都是整的，不会像小数1.1，2.5，3.21等等这样有小数点的零散的小数，这些大于0的数字都被称为正数。</p><p>​    当然，有大于必然会有小于，所以那些小于0的数字被称为负数，如-1，-2，-3，-5.33，-7.4等</p><p>​    而在这些负数中也是跟正数一样，除了代表小于0的负号（-）之外，其他都一样，有的像1，2，3一样没有小数点，有的却有小数点，这样我们可以把所有数字分为整数和小数</p><h2 id="java中代表数字的类型"><a href="#java中代表数字的类型" class="headerlink" title="java中代表数字的类型"></a>java中代表数字的类型</h2><p>​    这些最基本的知识点，就不在这过多介绍，简单提一下</p><ol><li>整型：java中的整型就是上面我们说的整数，java中整型的数据类型有这么几个byte、short、int、long</li><li>浮点型：浮点型，说的就是带有小数点的小数了，java中浮点型的数据类型有flot、double</li></ol><p>这里就简单过一下，今天我们要说的并不是这几个数据类型，而是另一种</p><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>上面所说的数据类型，都是java中的基本数据类型，也就是这门语言出生就定义好的类型。占用的内存空间比较小，用起来也比较方便。</p><p>但是，尽管如此，依然会有它自己的缺陷。我们应该都知道，其实在项目中用的比较多的并不是这些基本数据类型，而是它们的封装类</p><p>为什么要用开销更大的封装类，而不是这些基本类型?</p><p>最简单的一个问题，在一个类中的属性，定义一个整型变量，那么这个变量会有一个默认值0，这个时候，这个0到底是传递过来的值就是0呢？还是因为没有给这个它赋值的默认值呢？</p><p>如果你说自己赋值自己不知道吗？那么项目中一般拿值都会从前端传递过来，这个时候在程序运行的过程中，我们又怎么知道这个值是前端传过来就是0呢？还是因为前端没有传所以默认值为0了呢？</p><p>好了，简单讨论，所以我们能看出来，基本数据类型有时候并不能满足一些需求，所以这些基本数据类型的封装类（升级版）就来了。</p><p>今天我们要说的是整型int的封装类（Integer）</p><h1 id="二、由该话题引发的补充"><a href="#二、由该话题引发的补充" class="headerlink" title="二、由该话题引发的补充"></a>二、由该话题引发的补充</h1><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>我想应该有人在初学的时候，有人会告诉你，Integer类型进行值比较的时候，要用equalse()方法进行比较，但是有时候我们却还是用==进行比较，你会发现，有的时候==比较两个相同数字的Integer对象，返回的是true，有的时候却是false，接下来会详细说明</p><h2 id="和-equals"><a href="#和-equals" class="headerlink" title="== 和 equals()"></a>== 和 equals()</h2><p>这里在简单提一下二者的区别</p><p>首先，==比较的是两个值，而equals()比较的是两个内容</p><p>我想我提出的这个概念会有很多人不解甚至会喷，因为大部分人都有这样根深蒂固的概念：</p><ul><li>==比较的是地址，equals比较的是值</li></ul><p>这么说也不能算错吧，毕竟大多数人都是这么说的。</p><p>而我有一点疑问提出来，就是这种说法的不严谨：</p><ul><li>我们都知道，地址一般是对象才有，也就是说我们存在堆中的对象才会有指向这个对象在堆中实际位置的地址，而我们把这个地址会存在一个变量中，而这个变量中的值，就是这个地址，这个值也是存在栈中的</li><li>对此，所以人都说==比较的是地址，而equals比较的是值</li><li>那么我想问一下，这样的说法置基本数据类型byte、short、int、long、double、float于何地？他们有指向堆中对象的地址吗？</li><li>所以说，我觉得存在栈中的不管是指向对象的地址，还是基本数据类型本身的值，都是这个变量存储的值，而存在于堆中的真正对象，保存的就是这个对象的内容（包括其拥有的属性、行为方法等，都是这个对象的内容）</li><li>如果你有更有助于自己理解的概念，那更好</li></ul><p>好了，上面的说法可能跳的有点快，不过没办法，这里是要说封装类Integer，关于虚拟机的内存模型，这里就不细说了</p><h1 id="三、实验实录"><a href="#三、实验实录" class="headerlink" title="三、实验实录"></a>三、实验实录</h1><p>好了，扯了那么多，还没真正进入话题，想喷就喷吧</p><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>现在来说一下这个问题的现象：</p><h3 id="1-先看int"><a href="#1-先看int" class="headerlink" title="1. 先看int"></a>1. 先看int</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"int a == int b 结果："</span>+(a == b));</span><br></pre></td></tr></table></figure><ul><li>这个结果不用多考虑，为true是吧？</li></ul><p><img src="/2018/11/29/java整型封装类Integer的比较/1.png" alt=""></p><h3 id="2-再看Integer"><a href="#2-再看Integer" class="headerlink" title="2. 再看Integer"></a>2. 再看Integer</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Integer</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">Integer</span> d = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">System</span>.out.println(<span class="string">"Integer c == Integer d 结果："</span>+(c == d));</span><br></pre></td></tr></table></figure><ul><li>好，按照我们之前说的，==比较的是c和d的值（栈中的值），</li><li>那么这里分析下：我们创建一个Integer对象c，给这个对象赋值为1，然后我们又创建一个对象d，这个对象也赋值为1，然后用==比较c和d，我们比较的是两个对象存在栈中的地址，也就是c和d真正的值（指向对象的地址）</li><li>结果如何？</li></ul><p><img src="/2018/11/29/java整型封装类Integer的比较/2.png" alt=""></p><ul><li>吼，是true，好了，暂且到这，先不讨论，接下来看另一个实验：</li></ul><h3 id="3-再看一次Integer"><a href="#3-再看一次Integer" class="headerlink" title="3.再看一次Integer"></a>3.再看一次Integer</h3><p><img src="/2018/11/29/java整型封装类Integer的比较/3.png" alt=""></p><ul><li>瞧，我们看到了什么？</li><li>false唉，刚刚还是true的，为什么变成false了呢？</li><li>问题依旧保留，我们来看看equals()</li></ul><h3 id="4-看看equals"><a href="#4-看看equals" class="headerlink" title="4.看看equals()"></a>4.看看equals()</h3><ul><li>之前说了，equals()是比较两个对象内容是否完全一致</li><li>我们看看用equals比较这两种情况的结果</li></ul><p><img src="/2018/11/29/java整型封装类Integer的比较/4.png" alt=""></p><ul><li>true，两个都是true，说明两个对象内容完全一致。</li></ul><h2 id="查找原因"><a href="#查找原因" class="headerlink" title="查找原因"></a>查找原因</h2><h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><ul><li>我们一般遇到问题首先想到的是断点调试，这没问题，那么我们来走一波看看</li></ul><p><img src="/2018/11/29/java整型封装类Integer的比较/5.png" alt=""></p><ul><li>打上断点，进入调试，然后分步来看，慢慢解析</li></ul><p><img src="/2018/11/29/java整型封装类Integer的比较/6.png" alt=""></p><ul><li>注意看这张图的几个点，我们走到c、d两个Integer对象创建结束，</li><li>能够在Variables中看到，已经创建好了c、d两个对象，值都是1</li><li>注意看一下括号中，这里标明了c、d两个对象都是Integer对象，而这两个对象的记录编号都是525</li><li>ok，继续往下走</li></ul><p><img src="/2018/11/29/java整型封装类Integer的比较/7.png" alt=""></p><ul><li>这里我们看到，有创建了e、f两个值为1111的Integer对象，记录编号分别是528，529</li><li>到此，我们应该能够看出来了吧</li><li>没错，在给Integer的两个对象都赋值为1的时候，c、d两个变量的值保存的地址是指向同一个对象的(525)</li><li>而赋值为1111的时候，两个变量的值保存的地址分别指向不同的（528和529）</li><li>这就是为什么c==d为true，而e==f为false</li></ul><h2 id="一步一步"><a href="#一步一步" class="headerlink" title="一步一步"></a>一步一步</h2><h3 id="可以当是废话"><a href="#可以当是废话" class="headerlink" title="可以当是废话"></a>可以当是废话</h3><ol><li>到此，并没有结束，并不是找到为什么c==d为true，e==f为false是因为前者是同一个对象，而后者是不同对象就结束了。这也仅仅是看到了表象原因</li><li>由此，我们应该引发另一个问题：为什么同样是给Integer的对象赋值，都赋值为1的时候是同一个对象，而赋值为1111的时候确实两个不同的对象？</li><li>这点是对于无从下手的人来说，思考到这里，我们应该怎么办？有经验的人肯定二话不说就去看源码去了，没错，答案肯定是在Integer的源码中。</li><li>刚进源码中又看了一眼，Integer类中有1600行左右的代码，我们怎么找？很头疼，是那些代码引起的上面的这个问题的？我们不知道。</li><li>这样我们该怎么办？有种无头苍蝇般的慌乱感吧？</li><li>不用着急！我们可以利用ide断点调试中的一个小小的便利功能，有人注意到调试的时候，Variables视图中，我们每有一个行为调用，就会标识出这个行为以及其实体对象，下面看一组图，慢慢理解</li></ol><p><img src="/2018/11/29/java整型封装类Integer的比较/8.png" alt=""></p><p><img src="/2018/11/29/java整型封装类Integer的比较/9.png" alt=""></p><p><img src="/2018/11/29/java整型封装类Integer的比较/10.png" alt=""></p><p><img src="/2018/11/29/java整型封装类Integer的比较/11.png" alt=""></p><ul><li>我们能够看到，第一张图，也就是我给对象c赋值的时候所调用的行为方法就是编号为525的Integer对象的方法valueOf(int)—-对象d也是</li><li>第三张图为了更全面，我就展示了一下输出字符串的时候，其实这行代码的行为就是StringBuffer的toString方法，因为println()入参是String类型（拼接字符串的时候默认使用了StringBuffer来进行拼接，是为了效率，字符串的问题这里不讨论）</li><li>为了更全面，我们就举例三种，所以就又加了一个别的类型Date。能够在最后一张图看到，也有一个行为，是类加载行为。</li><li>可能大家都看到不同的对象的行为，ide给我们展示的信息也不同，甚至有些乱，不过那也是没有办法的，它只会给我们展示最近有影响的行为，如我们代码中Integer c = 1，其实这一行代码有这么几个行为：声明Integer对象c，实例化对象c，然后给c赋值，而我们上面展示的是最后一个给c赋值的valueOf(int)。</li><li>所以，如果有不知道该怎么去看源码的，可以借助这一点来去源码里面看一看，毕竟可以利用这一点找到跟我们程序有最直接关系的方法，然后以此为起点，慢慢往里看</li></ul><h3 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h3><p>在调试中我们能看到，调用Integer的时候调用了valueOf(int)这个方法，那就来看一下这个方法究竟有什么神奇的地方： </p><p>打开Integer类的源码，找到valueOf(int)</p><p><img src="/2018/11/29/java整型封装类Integer的比较/12.png" alt=""></p><p>在Integer类的源码中，重载了多个valueOf方法，不过都是调用了valueOf(int i)的方法来处理的。所以我们只要看这个方法就可以了 </p><p>在源码中能够看到：当赋值i在IntegerCache.low和IntegerCache.high之间（二者都包括）的时候，是直接返回已存在的IntegerCache.cache[index]中的值（某一个对象），否则才会新建！  </p><p>到了这一步，我想差不多应该已经明白是怎么回事了。 </p><p>这里是Integer做的一个缓存，预先缓存一部分值，如果程序要使用的值在其中，那么直接就拿来用，否则的话才会新建一个对象赋值返回。</p><p>所以我们能够判断出来，当给Integer a赋值1的时候，是没有超出IntegerCache.cache的范围的，而1111则超出了，所以导致一种是相同对象，一种是不同对象的结果。</p><h3 id="Integer中整数缓存"><a href="#Integer中整数缓存" class="headerlink" title="Integer中整数缓存"></a>Integer中整数缓存</h3><p>不过这个范围到底是多少呢？</p><p>那么既然提到这个问题了，我们就深究一下这个IntegerCache.cache到底怎么回事：</p><p>那么就来看看IntegerCache的源码：</p><p>在Integer类中有一个内部类，就是IntegerCache</p><p>这个类的作用就是为Integer类提供一部分int类型的缓存，避免了重复创建对象的麻烦。</p><p>下面请看源码：</p><p><img src="/2018/11/29/java整型封装类Integer的比较/13.png" alt=""></p><p>在源码中我们能够看到，首先IntegerCache设定了缓存最小值为-128(对于这个值，我想大家应该已经猜到了什么)</p><p>没错，这是byte的最小临界点（最小值）</p><p>那么high不用想了，很大可能就是127了</p><p>当然，看了源码也能看到了，在静态块中经过处理，最大值high也是127</p><p>所以在valueOf中，入参i如果满足-128&lt;=i&lt;=127，那么返回的对象都是同一个，数组cache中的某一个，否则就是new 一个对象</p><p>所以就会出现如果Integer的值是在-128~127之间的时候用==判断为true，而其他的值==为false的现象</p><h3 id="关于Integer缓存"><a href="#关于Integer缓存" class="headerlink" title="关于Integer缓存"></a>关于Integer缓存</h3><p>而对于Integer缓存大小的设置，也是可以自己设定的</p><p>因为java不是直接运行在本地操作系统上的，而是运行在jvm上的，我们可以通过配置更改jvm的运行参数来改变。</p><p>这个网上看看就好了，毕竟将缓存范围变大，那么意味着内存开销加剧，并且这部分缓存不会被gc回收的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;一、浅说（这里说的是废话）&quot;&gt;&lt;a href=&quot;#一、浅说（这里说的是废话）&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="java" scheme="https://it233.github.io/categories/java/"/>
    
      <category term="数据类型" scheme="https://it233.github.io/categories/java/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="整型" scheme="https://it233.github.io/categories/java/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B4%E5%9E%8B/"/>
    
    
      <category term="笔记" scheme="https://it233.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>jpa自动映射java实体类与数据库表</title>
    <link href="https://it233.github.io/2018/11/28/jpa%E8%87%AA%E5%8A%A8%E6%98%A0%E5%B0%84java%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8/"/>
    <id>https://it233.github.io/2018/11/28/jpa自动映射java实体类与数据库表/</id>
    <published>2018-11-28T06:29:10.000Z</published>
    <updated>2018-11-28T07:42:55.567Z</updated>
    
    <content type="html"><![CDATA[<p>​    之前有说过jpa不实用实体类，那是某种特殊情况的时候的需要</p><p>​    而大多数的时候，我们后端代码还是需要有与数据库对应的实体类的</p><p>​    这样方便后端进行管理数据，而且更易于使用jpa框架</p><p>这次废话不多说，毕竟时间不多，简单做一些记录，反正对于这个框架还不太熟悉！有机会再来好好研究一番</p><p>下面直接说出如何去写，原理，实验什么的就先免了</p><h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"ssprt_config"</span>,uniqueConstraints = &#123;<span class="meta">@UniqueConstraint</span>(name = <span class="string">"UK_SSPRTCONFIG_TYPE"</span>,columnNames = <span class="string">"type"</span>)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SsprtConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"type"</span>,length = <span class="number">50</span>)</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"value"</span>,length = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单解释："><a href="#简单解释：" class="headerlink" title="简单解释："></a>简单解释：</h3><ol><li><p>@Data：不用说了，就是getter、setter方法</p></li><li><p>@NoArgsConstructor：无参构造</p></li><li><p>@AllArgsConstructor：所有参数的构造</p><ol><li>注意2和3两个注解，最好加上，因为我们利用jpa查询数据的时候，查完数据通过构造进行给实体类赋值，没有的话会报有关构造函数的错误</li></ol></li><li><p>@Builder：builder创建对象，利用静态方法builder来创建对象，而不用new，提供链式setter赋值，方便快捷</p></li><li><p>@Entity：标注这是一个实体类，是一个与数据库映射的实体类</p></li><li><p>@Table：标注这个类所对应的数据库中的表名，同时，如果数据库中没有与之对应的表，会自动生成该表与之对应（这个要在配置文件中配置策略，不细说了，因为我也只是知道，并没有研究）</p><p>name：不是必须的，如果没有，那么使用默认的该实体类的短类名。</p><p>uniqueConstraints：唯一键，指定某个列columnNames</p></li><li><p>@Id：标注为主键</p></li><li><p>@GeneratedValue：主键生成策略，</p><ol><li>TABLE：使用表保存id值              </li><li>IDENTITY：identitycolumn               </li><li>SEQUENCR ：sequence               </li><li>AUTO：根据数据库的不同使用上面三个</li></ol></li><li><p>@Column：生命该字段与数据库表字段的映射关系，</p><ol><li>name指表字段名，length指数据长度，注意数据类型使用封装类</li></ol></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    之前有说过jpa不实用实体类，那是某种特殊情况的时候的需要&lt;/p&gt;
&lt;p&gt;​    而大多数的时候，我们后端代码还是需要有与数据库对应的实体类的&lt;/p&gt;
&lt;p&gt;​    这样方便后端进行管理数据，而且更易于使用jpa框架&lt;/p&gt;
&lt;p&gt;这次废话不多说，毕竟时间不多
      
    
    </summary>
    
      <category term="java" scheme="https://it233.github.io/categories/java/"/>
    
      <category term="框架" scheme="https://it233.github.io/categories/java/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="JPA" scheme="https://it233.github.io/categories/java/%E6%A1%86%E6%9E%B6/JPA/"/>
    
    
      <category term="学习" scheme="https://it233.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>canvas-camera</title>
    <link href="https://it233.github.io/2018/11/21/canvas-camera/"/>
    <id>https://it233.github.io/2018/11/21/canvas-camera/</id>
    <published>2018-11-21T09:19:16.000Z</published>
    <updated>2018-11-28T06:41:26.323Z</updated>
    
    <content type="html"><![CDATA[<p>这里是运用canvas来实现电脑摄像头拍照的功能的js代码。</p><p>纯属个人兴趣</p><p>以下是个人封装的js，好坏皆是如此</p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 调用摄像头</span></span><br><span class="line"><span class="comment"> * 传入参数：必须</span></span><br><span class="line"><span class="comment"> * canvas：画布，传入的参数为id,class,name或者tagName四选一，注意：只需要传入名称即可,不需要符号，</span></span><br><span class="line"><span class="comment"> *              例如:&lt;canvas id = "myCanvas"&gt;&lt;/canvas&gt;,那么入参就是myCanvas</span></span><br><span class="line"><span class="comment"> * video：影像，传入id，class，name，或者tagName四选一</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 传入参数：非必须</span></span><br><span class="line"><span class="comment"> * open ：打开摄像头功能的按钮id，class，Name</span></span><br><span class="line"><span class="comment"> * snap ： 拍摄功能的按钮id，class或者name</span></span><br><span class="line"><span class="comment"> * close： 关闭摄像头功能的按钮id，class或者name</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：如果不传入按钮功能，会有open，snap，close三个function来提供相应的功能，可以直接使用canCamera.open()等来调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 同时，提供链式调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 调用示例：</span></span><br><span class="line"><span class="comment"> *      var cc = canCamera(&#123;</span></span><br><span class="line"><span class="comment"> *          canvas:"myCanvas",</span></span><br><span class="line"><span class="comment"> *          video:"myVideo",</span></span><br><span class="line"><span class="comment"> *          open:"start",</span></span><br><span class="line"><span class="comment"> *          snap:"getPhotoBtn",</span></span><br><span class="line"><span class="comment"> *          close:"closeBtn"</span></span><br><span class="line"><span class="comment"> *      &#125;)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 或者：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  var cc = canCamera(&#123;</span></span><br><span class="line"><span class="comment"> *          canvas:"myCanvas",</span></span><br><span class="line"><span class="comment"> *          video:"myVideo"</span></span><br><span class="line"><span class="comment"> *      &#125;)</span></span><br><span class="line"><span class="comment"> *    //绑定按钮点击事件</span></span><br><span class="line"><span class="comment"> *    document.getElementById("start").addEventListener('click',cc.open);</span></span><br><span class="line"><span class="comment"> *    document.getElementById("getPhotoBtn").addEventListener('click',cc.snap);</span></span><br><span class="line"><span class="comment"> *    document.getElementById("closeBtn").addEventListener('click',cc.close);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window, document</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> canCamera = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> $<span class="keyword">this</span> = canCamera</span><br><span class="line">        $<span class="keyword">this</span>.canvas = <span class="built_in">document</span>.getElementById(obj.canvas)</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByName(obj.canvas)[<span class="number">0</span>]</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByClassName(obj.canvas)[<span class="number">0</span>]</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByTagName(obj.canvas)[<span class="number">0</span>]</span><br><span class="line">        $<span class="keyword">this</span>.video = <span class="built_in">document</span>.getElementById(obj.video)</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByName(obj.video)[<span class="number">0</span>]</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByClassName(obj.video)[<span class="number">0</span>]</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByTagName(obj.video)[<span class="number">0</span>]</span><br><span class="line">        $<span class="keyword">this</span>.openBtn = <span class="built_in">document</span>.getElementById(obj.open)</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByName(obj.open)[<span class="number">0</span>]</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByClassName(obj.open)[<span class="number">0</span>]</span><br><span class="line">        $<span class="keyword">this</span>.snapBtn = <span class="built_in">document</span>.getElementById(obj.snap)</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByName(obj.snap)[<span class="number">0</span>]</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByClassName(obj.snap)[<span class="number">0</span>]</span><br><span class="line">        $<span class="keyword">this</span>.closeBtn = <span class="built_in">document</span>.getElementById(obj.close)</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByName(obj.close)[<span class="number">0</span>]</span><br><span class="line">            || <span class="built_in">document</span>.getElementsByClassName(obj.close)[<span class="number">0</span>]</span><br><span class="line">        $<span class="keyword">this</span>.context = $<span class="keyword">this</span>.canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">        $<span class="keyword">this</span>.MediaStreamTrack = <span class="literal">null</span></span><br><span class="line">        $<span class="keyword">this</span>.open = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            $<span class="keyword">this</span>.video.style.display = <span class="string">"block"</span>;</span><br><span class="line">            $<span class="keyword">this</span>.canvas.style.display = <span class="string">"none"</span>;</span><br><span class="line">            <span class="keyword">if</span> (navigator.mediaDevices &amp;&amp; navigator.mediaDevices.getUserMedia) &#123;</span><br><span class="line">                navigator.mediaDevices.getUserMedia(&#123;</span><br><span class="line">                    <span class="string">"video"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</span><br><span class="line">                    $<span class="keyword">this</span>.MediaStreamTrack = <span class="keyword">typeof</span> stream.stop === <span class="string">'function'</span> ? stream : stream.getTracks()[<span class="number">1</span>];</span><br><span class="line">                    $<span class="keyword">this</span>.video.srcObject = stream;</span><br><span class="line">                    $<span class="keyword">this</span>.video.play();</span><br><span class="line">                &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(err);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.getMedia) &#123;</span><br><span class="line">                navigator.getMedia(&#123;</span><br><span class="line">                    <span class="string">"video"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(stream);</span><br><span class="line">                    $<span class="keyword">this</span>.MediaStreamTrack = stream.getTracks()[<span class="number">1</span>];</span><br><span class="line">                    $<span class="keyword">this</span>.video.srcObject = (<span class="built_in">window</span>.webkitURL).createObjectURL(stream);</span><br><span class="line">                    $<span class="keyword">this</span>.video.play();</span><br><span class="line">                &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(err);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alert(<span class="string">"浏览器不支持！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> $<span class="keyword">this</span></span><br><span class="line">        &#125;;</span><br><span class="line">        $<span class="keyword">this</span>.snap = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> w = $<span class="keyword">this</span>.video.offsetWidth,</span><br><span class="line">                h = $<span class="keyword">this</span>.video.offsetHeight;</span><br><span class="line">            $<span class="keyword">this</span>.video.style.display = <span class="string">"none"</span>;</span><br><span class="line">            $<span class="keyword">this</span>.canvas.style.display = <span class="string">"block"</span>;</span><br><span class="line">            $<span class="keyword">this</span>.context.drawImage($<span class="keyword">this</span>.video, <span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">            <span class="keyword">return</span> $<span class="keyword">this</span></span><br><span class="line">        &#125;;</span><br><span class="line">        $<span class="keyword">this</span>.close = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            $<span class="keyword">this</span>.MediaStreamTrack &amp;&amp; $<span class="keyword">this</span>.MediaStreamTrack.stop();</span><br><span class="line">            <span class="keyword">return</span> $<span class="keyword">this</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> ($<span class="keyword">this</span>.openBtn)</span><br><span class="line">            $<span class="keyword">this</span>.openBtn.addEventListener(<span class="string">'click'</span>, $<span class="keyword">this</span>.open);</span><br><span class="line">        <span class="keyword">if</span> ($<span class="keyword">this</span>.snapBtn)</span><br><span class="line">            $<span class="keyword">this</span>.snapBtn.addEventListener(<span class="string">'click'</span>, $<span class="keyword">this</span>.snap);</span><br><span class="line">        <span class="keyword">if</span> ($<span class="keyword">this</span>.closeBtn)</span><br><span class="line">            $<span class="keyword">this</span>.closeBtn.addEventListener(<span class="string">'click'</span>, $<span class="keyword">this</span>.close);</span><br><span class="line">        <span class="built_in">window</span>.canCamera = canCamera || <span class="keyword">new</span> canCamera()</span><br><span class="line">        <span class="keyword">return</span> $<span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.canCamera = canCamera || <span class="keyword">new</span> canCamera()</span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里是运用canvas来实现电脑摄像头拍照的功能的js代码。&lt;/p&gt;
&lt;p&gt;纯属个人兴趣&lt;/p&gt;
&lt;p&gt;以下是个人封装的js，好坏皆是如此&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="前端" scheme="https://it233.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://it233.github.io/categories/%E5%89%8D%E7%AB%AF/js/"/>
    
      <category term="HFJs" scheme="https://it233.github.io/categories/%E5%89%8D%E7%AB%AF/js/HFJs/"/>
    
    
      <category term="兴趣" scheme="https://it233.github.io/tags/%E5%85%B4%E8%B6%A3/"/>
    
  </entry>
  
  <entry>
    <title>前端画图Canvas简单运用</title>
    <link href="https://it233.github.io/2018/11/19/%E5%89%8D%E7%AB%AF%E7%94%BB%E5%9B%BECanvas%E7%AE%80%E5%8D%95%E8%BF%90%E7%94%A8/"/>
    <id>https://it233.github.io/2018/11/19/前端画图Canvas简单运用/</id>
    <published>2018-11-19T08:40:30.000Z</published>
    <updated>2018-11-30T01:12:08.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><ul><li>朋友遇到的情况，属于前端的问题，是需要打开摄像头来拍照，关于这个问题，他找到了我让我来帮他解决，不过由于我的前端也是属于那种半吊子水平，所以在过程中也是参考了网上的不少资料和案例，不过还好的是因此也了解了不少知识，所以准备整理一下，做个记录</li><li>这篇主要是前端canvas画布功能，可能知识不够全面，但是要实现拍照应该是没问题了</li><li>除了参照图像资源进行利用canvas画图之外，canvas还有很多功能提供，方便我们直接在页面上进行手工绘画，这些功能这里就不展示了，因为我也忘记了，只是之前刚学前端的时候有捣弄过，不过现在主要做后台开发，所以前端水平就一般般</li></ul><h1 id="二、画图"><a href="#二、画图" class="headerlink" title="二、画图"></a>二、画图</h1><ul><li>在实现拍照之前，先来详细了解一下canvas画图功能，这样对于后面拍照会更简单一点</li></ul><h2 id="页面准备"><a href="#页面准备" class="headerlink" title="页面准备"></a>页面准备</h2><ul><li>实现canvas画图功能，我们需要准备一张图片，为了试验效果，我就随便截了一张桌面的图片</li><li>在页面中我们要放置一张图片(当然，也可以不用展示在页面上，这个js代码中会扩展)，所以需要img标签元素</li><li>想要进行在页面画图，我们还要通过canvas标签元素获得context(简称，后面展示全部)来帮我们实现这个功能</li><li>然后，为了进行测试，我们加一个按钮，当点击按钮的时候，我们将展示的图片画出来</li></ul><h2 id="html代码"><a href="#html代码" class="headerlink" title="html代码"></a>html代码</h2><ul><li><p>我们需要的html代码很简单，只有三个元素：img、canvas、button</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../imgs/0.png"</span> <span class="attr">id</span>=<span class="string">"img"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">height</span>=<span class="string">"400"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">id</span>=<span class="string">"canvas1"</span> <span class="attr">style</span>=<span class="string">"border: 1px solid gray"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"draw"</span>&gt;</span>画图<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="js代码及详解"><a href="#js代码及详解" class="headerlink" title="js代码及详解"></a>js代码及详解</h2><h3 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h3><ul><li>在上代码之前， 先来说一下流程</li><li>我们想要参照img元素中的图片资源，利用canvas来将其画出来<ul><li>那么首先我们就需要找到img元素中的图片，</li><li>其次还要有canvas画图的对象，</li><li>然后获得canvas的Context</li><li>最后配置Context的环境将img图片画出来</li></ul></li><li>总体简单来说就这四步，下面直接上代码，然后再解释：</li></ul><h3 id="js代码"><a href="#js代码" class="headerlink" title="js代码"></a>js代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"ckbtn"</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">"img"</span>);</span><br><span class="line">        <span class="keyword">var</span> cv = <span class="built_in">document</span>.getElementById(<span class="string">'canvas1'</span>);</span><br><span class="line">        <span class="keyword">var</span> ct = cv.getContext(<span class="string">"2d"</span>);</span><br><span class="line">        ct.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">400</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="js代码详细解释（以及踩过的坑和未踩过的坑）"><a href="#js代码详细解释（以及踩过的坑和未踩过的坑）" class="headerlink" title="js代码详细解释（以及踩过的坑和未踩过的坑）"></a>js代码详细解释（以及踩过的坑和未踩过的坑）</h3><ul><li><p>注意点1、window.onload</p><ul><li>这个window.onload不用多解释，就是在页面加载完成之后再执行funciton中的这段代码</li><li>为什么一定要这么做呢？</li><li>那是因为我们现在使用的页面元素，如果没有这个onload保证页面先加载完成，有可能会出现这种情况：<ul><li>canvas元素找不到，所以我们获取其dom对象的时候有可能会出现undefined</li><li>如果canvas出现undefined的话，那么我们必然无法获得该画布下的Context，也就无法实现画图功能</li><li>除此之外，运气好，我们canvas画布放的比较靠前，能够找得到，不过我们知道，图片属于外部静态资源，加载可能没有html原生代码快，这个时候，如果我们图片没有加载完成，也可能会出现画图失败<ul><li>举个例子，假如有一个画家，他要为一个人画一幅像，但是不巧的是，这个人突然临时有事，不能准时到，那么在这个人还没有到达之前，这个画家怎么去画这幅画？他拿什么做参考呢？</li></ul></li><li>再者呢，我们又要绑定按钮，所以onload最好是加上</li></ul></li><li>这里说了那么多，我们能够知道，如果我们看着代码没有错误，并且没有报错，那么很可能是图片没有加载完成，导致没法画出图片（之后还有一个可能的原因，在注意点2）</li></ul></li><li><p>注意点2、canvas元素</p><ul><li>这里要注意的是，我们所说的canvas画图，其实canvas只是一个画布,隐约记得曾经学的时候，好像还有画笔什么来着，记不清了，不纠结了、</li><li>真正实现画图功能的，是画笔而不是画布，而之前说的Context，是一种环境，<ul><li>这里打个比方，canvas是画布，就是画家使用的画板，就是我们要画出的画的容器</li><li>那个画笔是什么来着，就是用来进行绘画的，之前说的能够手工绘画也是控制画笔在页面上进行绘画</li><li>而context，是环境，就好比我们画家用画笔在画布上绘画所需要的因素，在这里我个人将它理解为了画家，因为context提供了画图很多方法来满足画图的需要。就像一个画家一样具备的能力</li><li>这里简单展示一下context，关于context这个对象具体的代码有点多，有兴趣的可以自己研究</li></ul></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getContext(<span class="string">contextId:</span> <span class="string">"2d"</span>, contextAttributes?: Canvas2DContextAttributes): CanvasRenderingContext2D | <span class="literal">null</span>;</span><br><span class="line">getContext(<span class="string">contextId:</span> <span class="string">"webgl"</span> | <span class="string">"experimental-webgl"</span>, contextAttributes?: WebGLContextAttributes): WebGLRenderingContext | <span class="literal">null</span>;</span><br><span class="line">getContext(<span class="string">contextId:</span> string, contextAttributes?: &#123;&#125;): CanvasRenderingContext2D | WebGLRenderingContext | <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li>这里并不是很详细地解释了canvas，所以我们知道，canvas是容器，这里也会有一个小问题，不知道有没有人遇到过。（在做摄像头拍照的时候遇到了小问题，所以回头研究了canvas）<ul><li>如果我们为了美观，不展示canvas来占空间，而设置为了display:none，那么会发生什么情况？</li><li>另外，如果我们设置了canvas的长宽都为0，会是什么情况？</li></ul></li><li>对于以上两点，在下面会案例展示结果，先猜一下吧</li></ul></li><li><p>注意点3、2维和3维画图</p><ul><li><p>通过上面的getContext()方法，能够看得出来，我们假如传入的是“2d”这个字符串，那么就会获得CanvasRenderingContext2D这个对象</p></li><li><p>在没有看过这些代码之前，我也曾一度认为，有2d就有3d，果断丢个”3d”参数进去，哈哈，获得null，那么我们肯定觉得不合理，有2d画图就应该能画3d的啊，其实webgl就是用来画3d的，不过我不会，也不了解</p></li><li><p>不过有一点需要注意了，接下来图文解释更清晰</p><ul><li><p>首先我获得canvas之后，通过传入参数3d</p></li><li><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">cv</span> = document.getElementById('canvas1');</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="built_in">cv</span>)</span><br><span class="line">        <span class="built_in">var</span> ct = <span class="built_in">cv</span>.getContext(<span class="string">"3d"</span>);</span><br><span class="line">        console.<span class="built_in">log</span>(ct)</span><br></pre></td></tr></table></figure></li><li><p>获得的结果为null</p></li><li><p><img src="/2018/11/19/前端画图Canvas简单运用/0.png" alt=""></p></li><li><p>然而我们如果传入的是”2d”或者”webgl”的话，确实能够获得context的</p></li><li><p><img src="/2018/11/19/前端画图Canvas简单运用/2d.png" alt=""></p></li><li><p><img src="/2018/11/19/前端画图Canvas简单运用/webgl.png" alt=""></p></li><li><p>注意了：如果我们先入参2d获得返回对象保存在一个变量中，然后再入参webgl保存在另一个变量中，会是什么结果？</p></li><li><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">cv</span> = document.getElementById('canvas1');</span><br><span class="line">       console.<span class="built_in">log</span>(<span class="built_in">cv</span>)</span><br><span class="line">       <span class="built_in">var</span> ct2d = <span class="built_in">cv</span>.getContext(<span class="string">"2d"</span>);</span><br><span class="line">       <span class="built_in">var</span> ctwebgl = <span class="built_in">cv</span>.getContext(<span class="string">"webgl"</span>)</span><br><span class="line">       console.<span class="built_in">log</span>(<span class="string">"ct2d:"</span>+ct2d)</span><br><span class="line">       console.<span class="built_in">log</span>(<span class="string">"ctwebgl:"</span>+ctwebgl)</span><br></pre></td></tr></table></figure> <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 结果就是先获得的context占据这个画布，再设置另一个则没用了，直接为null。而官方原注释并没有解释为何，我们可以从官方注释中得到的信息，就是：</span><br><span class="line"></span><br><span class="line">- 返回一个对象，该对象提供绘制和操作文档中画布元素上的图像和图形的方法和属性。上下文对象包括关于颜色、线宽、字体和其他可以在画布上绘制的图形参数的信息。</span><br><span class="line"></span><br><span class="line">    @param上下文要创建的画布类型的标识符(ID)。Internet Explorer <span class="number">9</span>和Internet Explorer <span class="number">10</span>仅支持使用canvas.getContext(“<span class="number">2</span>d”)的<span class="number">2</span>d环境;IE11预览还支持<span class="number">3</span>d或WebGL上下文使用canvas.getContext(“实验- WebGL”);</span><br><span class="line"></span><br><span class="line">- 好像并没有什么文字能解释为什么只能获得一次？那么我们就只能从代码中分析了，请移至注意点<span class="number">2</span>查看代码，这里不贴了</span><br><span class="line"></span><br><span class="line">- w3school中也没有过多解释，不过这里依然不妨碍理解，这个方法大致为以下情况：</span><br><span class="line"></span><br><span class="line">- 根据入参来匹配<span class="number">2</span>d或者webgl，如果是，那么会先去看contextAttributes，如果已经有值了（上次一调用之后会将<span class="number">2</span>d或者webgl相应对象存下来，猜测），那么直接返回null，这就导致如果第一次已经拿到<span class="number">2</span>d的对象了，那么下面再入参webgl调用，获得的就是null，而为什么不是返回上一次的，就是函数返回值的问题吧，看前两个getContext，返回值要么是对应的<span class="number">2</span>d或webgl对象，要么是null。这就是说参数匹配到之后，就会执行相应的函数，而<span class="string">"2d"</span>只会返回<span class="number">2</span>d对象或者null，webgl也是一样。最后一个方法，是在参数不匹配<span class="number">2</span>d或者webgl的时候，会先去返回<span class="number">2</span>d，如果没有，再考虑webgl，最后二者都没有，就返回null</span><br><span class="line"></span><br><span class="line">- 其实，之上一点的看法，最后理解根本无法实践，因为按照最后的说法，我们必须要传一个参数过去，而如果我们先传过去<span class="number">2</span>d，那么获得<span class="number">2</span>d对象，这时候再去调用getContext实践，不好意思，之前已经设置过<span class="number">2</span>d了，其他的我不会给你了。就好比一个画板，其中A画家先去使用了，那么不好意思，不管你后来再来的其他任何人，都不会得到使用权。不过如果再次传入<span class="number">2</span>d，还是能够获得<span class="number">2</span>d对象，这个只能解释为A画家中途休息，休息完之后依旧拥有该画板的使用权。以至于最后的猜想也没法实现验证。因为我除了传入<span class="number">2</span>d参数，其他任何参数都会直接获得null</span><br><span class="line"></span><br><span class="line">- 而且这看到的只是interface中的代码，没有具体实现的逻辑代码，一切靠猜测，所以可能会很大的冲突，不过结果肯定是一样的，因为就是通过结果来进行推测的逻辑。如果有人比较了解这方面的东西，希望能够告知以便相互学习</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>注意点4：这里不叫注意点，应该是知识点</p><ul><li><p>drawImage（r,x,y,w,h）参数：</p><ul><li>r：代表的是图像源头</li><li>x：表示在画布中x坐标轴的偏移量</li><li>y：y坐标轴偏移量</li><li>w：画出的图片的宽度</li><li><p>h：高度</p><pre><code>、结果实例    </code></pre></li></ul></li></ul></li></ul><h2 id="参照页面img元素画图"><a href="#参照页面img元素画图" class="headerlink" title="参照页面img元素画图"></a>参照页面img元素画图</h2><ul><li>这里就丢两张图， 反正该解释的上面已经解释了</li><li><img src="/2018/11/19/前端画图Canvas简单运用/draw0.png" alt=""></li><li><img src="/2018/11/19/前端画图Canvas简单运用/draw1.png" alt=""></li></ul><h2 id="不参照页面img元素画图"><a href="#不参照页面img元素画图" class="headerlink" title="不参照页面img元素画图"></a>不参照页面img元素画图</h2><ul><li><p>在前面说过，我们不将图片展示在页面上来将图片画出来，不过我们要遵循的步骤依旧是一样的</p></li><li><p>只不过第一步找参考图片不是在页面中寻找了，而是在js代码中，也就是我们要手动创建一个img元素dom对象，然后指定其图片</p></li><li><p>代码：</p></li><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>)</span><br><span class="line">       img.src=<span class="string">"../imgs/0.png"</span></span><br><span class="line">       <span class="built_in">document</span>.getElementById(<span class="string">"draw"</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">var</span> cv = <span class="built_in">document</span>.getElementById(<span class="string">'canvas1'</span>);</span><br><span class="line">           <span class="keyword">var</span> ct = cv.getContext(<span class="string">"2d"</span>);</span><br><span class="line">           ct.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></li><li><p>结果图：</p></li><li><p><img src="/2018/11/19/前端画图Canvas简单运用/draw2.png" alt=""></p></li><li><p>以上展示了如何利用canvas画图，其中有理解错误的地方，也就这样了。下面来看一下怎么将这张canvas中的图片保存下来，这个后面会用到</p></li></ul><h1 id="四、canvas补充"><a href="#四、canvas补充" class="headerlink" title="四、canvas补充"></a>四、canvas补充</h1><ul><li>上面说到的两个问题，在这里进行补充示例说明结果</li></ul><h2 id="问题1：canvas设置为display-none的情况会如何"><a href="#问题1：canvas设置为display-none的情况会如何" class="headerlink" title="问题1：canvas设置为display:none的情况会如何"></a>问题1：canvas设置为display:none的情况会如何</h2><ul><li><p>首先看一下代码：</p></li><li><p>html：直接设置canvas样式为display:none</p></li><li><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas <span class="attribute">height</span>=<span class="string">"400"</span> <span class="attribute">width</span>=<span class="string">"200"</span> <span class="attribute">id</span>=<span class="string">"canvas1"</span> <span class="attribute">style</span>=<span class="string">"border: 1px solid gray;display:none;"</span>&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;button <span class="attribute">id</span>=<span class="string">"draw"</span>&gt;画图&lt;/button&gt;</span><br><span class="line">&lt;button <span class="attribute">id</span>=<span class="string">"show"</span>&gt;展示&lt;/button&gt;</span><br></pre></td></tr></table></figure></li><li><p>结果可想而知，页面上什么都没有只有两个个按钮</p></li><li><p><img src="/2018/11/19/前端画图Canvas简单运用/test0.png" alt=""></p></li><li><p>js代码：思路是，点击画图将图片画到canvas中，在点击展示改变canvas的样式为block，看看有没有图片</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//画图按钮</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>)</span><br><span class="line">img.src=<span class="string">"../imgs/0.png"</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"draw"</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cv = <span class="built_in">document</span>.getElementById(<span class="string">'canvas1'</span>);</span><br><span class="line">    <span class="keyword">var</span> ct = cv.getContext(<span class="string">"2d"</span>);</span><br><span class="line">    ct.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//展示按钮</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"show"</span>).addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"canvas1"</span>).style.display= <span class="string">'block'</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>结果：</p></li><li><p><img src="/2018/11/19/前端画图Canvas简单运用/test1.png" alt=""></p></li><li><p>啊哈，有图片耶！那么我们来看看第二种情况</p></li></ul><h2 id="问题2：canvas设置为长宽都为0的情况会如何"><a href="#问题2：canvas设置为长宽都为0的情况会如何" class="headerlink" title="问题2：canvas设置为长宽都为0的情况会如何"></a>问题2：canvas设置为长宽都为0的情况会如何</h2><ul><li><p>思路同上一个，直接贴代码和效果</p></li><li><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas <span class="attribute">height</span>=<span class="string">"0"</span> <span class="attribute">width</span>=<span class="string">"0"</span> <span class="attribute">id</span>=<span class="string">"canvas1"</span> <span class="attribute">style</span>=<span class="string">"border: 1px solid gray;"</span>&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;button <span class="attribute">id</span>=<span class="string">"draw"</span>&gt;画图&lt;/button&gt;</span><br><span class="line">&lt;button <span class="attribute">id</span>=<span class="string">"show"</span>&gt;展示&lt;/button&gt;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//画图按钮</span></span><br><span class="line">      <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>)</span><br><span class="line">      img.src = <span class="string">"../imgs/0.png"</span></span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">"draw"</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> cv = <span class="built_in">document</span>.getElementById(<span class="string">'canvas1'</span>);</span><br><span class="line">          <span class="keyword">var</span> ct = cv.getContext(<span class="string">"2d"</span>);</span><br><span class="line">          ct.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">//展示按钮</span></span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">"show"</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">document</span>.getElementById(<span class="string">"canvas1"</span>).style.width = <span class="string">'200px'</span>;</span><br><span class="line">          <span class="built_in">document</span>.getElementById(<span class="string">"canvas1"</span>).style.height = <span class="string">'400px'</span>;</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure></li><li><p><img src="/2018/11/19/前端画图Canvas简单运用/test2.png" alt=""></p></li><li><p>没有图片唉！</p></li></ul><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>我们将canvas设置为display:none，但是该元素还是存在页面中的，并且占有一定的面积，只是因为设置为不显示，所以视觉上并没有占用页面的空间。</li><li>之前说过，canvas是画布，画图是将图片画在canvas元素上，那么既然存在，不管别人看不看得到，我们画图的时候没有影响</li><li>而将canvas宽高设置为0，那么该元素虽然依旧存在页面中，但是一个没有任何大小的元素，真正的意义是依旧存在页面中吗？谁能将一幅画画在面积为0的画板上呢？</li><li>所以，对于canvas的理解，就是这样，它就是一个容器，就是用来存放画出来的图像的一个容器。</li></ul><h1 id="五、canvas图片下载"><a href="#五、canvas图片下载" class="headerlink" title="五、canvas图片下载"></a>五、canvas图片下载</h1><ul><li>针对与摄像头拍照，我们需要将”拍”的照片保存下来，其实就是将canvas中画出来的图像保存下来，</li><li>然后目前的情况也就是我们只是拥有一个存在于页面有展示效果的视觉图像而已，以及一个保存这个图像的元素</li><li>那么我们如何将这个元素中的画面以图片文件形式保存下来呢？</li><li>其实很简单，有以下几步</li></ul><p>##　１、获得图片文件形式</p><ul><li><p>文件，其实也是一组数据，我们只要拿到这组数据就能实现文件下载</p><ul><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">'canvas1'</span>);</span><br><span class="line">  <span class="comment">//获得图片的base64加密字符串</span></span><br><span class="line">  <span class="keyword">var</span> imgdata = ctx.toDataURL(<span class="string">"image/png"</span>, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过ctx.toDataURL方法能够将canvas元素中的图像元素转成文件数据路径</p></li></ul></li><li><p>接下来，有了文件数据路径。我们可以通过a标签来进行下载该文件</p><ul><li><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置文件名字，并生成a标签链接文件直接执行鼠标点击事件进行下载</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">type</span> = <span class="string">'jpg'</span></span><br><span class="line"><span class="keyword">var</span> filename = <span class="string">'canvas画图.'</span> + <span class="keyword">type</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line"><span class="comment">//设置a链接元素为文件数据路径，点击时候就能直接下载</span></span><br><span class="line">a.href = imgdata;</span><br><span class="line">a.download = filename;</span><br><span class="line"><span class="comment">//然后生成鼠标点击事件</span></span><br><span class="line"><span class="comment">// a.click()</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">'MouseEvents'</span>);</span><br><span class="line">event.initMouseEvent(<span class="string">'click'</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="built_in">window</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//执行a标签元素的鼠标点击事件，就相当于是在页面中用鼠标点击了a链接，实现下载</span></span><br><span class="line">a.dispatchEvent(event);</span><br></pre></td></tr></table></figure></li><li><p>说明一下：其实从10行开始到结束的代码，效果等同于第九行的a.click()，就是为了能够不实用鼠标点击页面元素而实现a的点击事件</p></li><li><p><img src="/2018/11/19/前端画图Canvas简单运用/down0.png" alt=""></p></li><li><p><img src="/2018/11/19/前端画图Canvas简单运用/down1.png" alt=""></p></li><li><p>到此，我们就把canvas中的图像保存下来了，有人应该注意到，png格式，对于没有被填充的canvas范围，在图片中是透明背景。</p></li><li><p>除了png格式，还支持jpg、bmp、gif等格式，视自己的需求来吧</p></li></ul></li></ul><h1 id="六、摄像头拍照"><a href="#六、摄像头拍照" class="headerlink" title="六、摄像头拍照"></a>六、摄像头拍照</h1><ul><li>其实摄像头拍照功能，我们也能够利用canvas画图来实现</li><li>按照我们之前说的，利用canvas只要能够将画面元素拿到，就能够将该元素区域中的图像画到canvas中，然后下载</li><li>上面已经说了后面的步骤，所以我们要利用摄像头中拍照，那么到目前我们要解决的事情就只有两个了：<ul><li>1、拿到摄像头中拍摄到的画面展示在页面中</li><li>2、将页面中展示摄像头页面的元素获取到，给canvas画下来</li></ul></li></ul><h2 id="打开摄像头"><a href="#打开摄像头" class="headerlink" title="打开摄像头"></a>打开摄像头</h2><h3 id="先贴代码，然后再解释"><a href="#先贴代码，然后再解释" class="headerlink" title="先贴代码，然后再解释"></a>先贴代码，然后再解释</h3><ul><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">navigator.mediaDevices.getUserMedia(&#123;</span><br><span class="line">                    <span class="string">"video"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(stream);</span><br><span class="line">                    $<span class="keyword">this</span>.MediaStreamTrack = <span class="keyword">typeof</span> stream.stop === <span class="string">'function'</span> ? stream : stream.getTracks()[<span class="number">1</span>];</span><br><span class="line">                    $<span class="keyword">this</span>.video.srcObject = stream;</span><br><span class="line">                    $<span class="keyword">this</span>.video.play();</span><br><span class="line">                &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(err);</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><h4 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h4><ul><li><p>Navigator 对象包含有关浏览器的信息 ，</p></li><li><p>注释：没有应用于 navigator 对象的公开标准，不过所有浏览器都支持该对象 </p></li><li><p>描述：Navigator 对象包含的属性描述了正在使用的浏览器。可以使用这些属性进行平台专用的配置。</p><p>虽然这个对象的名称显而易见的是 Netscape 的 Navigator 浏览器，但其他实现了 JavaScript 的浏览器也支持这个对象。</p><p>Navigator 对象的实例是唯一的，可以用 Window 对象的 navigator 属性来引用它。</p><p>对于这个对象，可以去网上查查，今天我们关注的并不是它</p></li></ul><h4 id="mediaDevices"><a href="#mediaDevices" class="headerlink" title="mediaDevices"></a>mediaDevices</h4><ul><li><p>上面说的Navigator对象很牛逼，牛逼到我们能够获得当前所使用环境的很多信息，包括浏览器，当前系统等等</p></li><li><p>而mediaDevices，则是一个API接口，该接口提供了访问链接媒体输入的设备，如我们使用的摄像头、照相机和麦克风，以及屏幕共享等。 这些媒体输入设备,都能通过该接口来访问链接以便调用</p></li><li><p>链接可以去网站上看看详细的文档资料</p><p>​    <a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/</a></p><p>进去后点击左上角技术&gt;&gt;&gt;API/dom  </p><p>能够查看所有的API文档，然后找到mediaDevices和Navigator自行学习</p></li><li><p>有了mediaDevices，只是给我们提供了媒体输入设备链接，而我们要使用设备，还需要一个方法，没错，就是代码中的getUserMedia()</p></li></ul><h4 id="mediaDevices-getUserMedia"><a href="#mediaDevices-getUserMedia" class="headerlink" title="mediaDevices.getUserMedia()"></a>mediaDevices.getUserMedia()</h4><ul><li><p>该方法会使用户给予使用媒体输入的许可 ，媒体输入会产生一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaStream" target="_blank" rel="noopener"><code>MediaStream</code></a>，里面包含了请求的媒体类型的轨道 。</p></li><li><p>MediaStream是一个流，这个流可以包括视频轨道（来自硬件或者虚拟视频源，比如相机、视频采集设备和屏幕共享服务等等 ）、音频轨道（同样来自硬件或虚拟音频源，比如麦克风、A/D转换器等等 ），也可能是其他轨道</p></li><li><p>这个函数的参数也比较简单，就是一个对象，这个对象就是表示我们要请求使用的媒体</p><ul><li><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;</span> <span class="attr">audio:</span> <span class="literal">true</span><span class="string">,</span> <span class="attr">video:</span> <span class="literal">true</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>上面这个代码表示没有任何要求，只要使用音频和视频的媒体</p></li><li><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="attr">  audio:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">  video:</span> <span class="string">&#123;</span> <span class="attr">width:</span> <span class="number">1280</span><span class="string">,</span> <span class="attr">height:</span> <span class="number">720</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>而这上面代码是说，我要使用音频和视频媒体输入设备，但是视频设配我要1280x720的分辨率</p></li><li><p>等等，这些参数我们可以灵活使用，而这些东西在上面分享的url里面都有，可以自行去看文档学习</p></li></ul></li><li><p>说完参数，那么来看一下返回值：Promise</p><ul><li>其实这个对象没多大深度，就是表示异步操作最终完成或者失败的对象 </li><li>也就是说，我们请求使用设备，成功了，这个对象就表示成功了，失败了，就表示失败了</li><li>它的本质就是一个绑定了回调函数的对象，而不是将回调函数传入函数内部</li><li>所以我们用.then(function(){})来执行请求设备许可后的处理方法</li><li>而如果请求失败或者设备不可用。会回调<code>PermissionDeniedError</code>  或者<code>NotFoundError</code>  ，我们用链式调用.catch(function(){})来处理异常</li><li>注意：有可能这个对象既不返回允许，也不返回拒绝，因为用户不是百分百会选择允许使用或者拒绝使用，也可能用户什么都不选</li><li>好了，闲话不多说，简单聊一聊，具体的去看文档资料学习吧</li><li>接下来说一下获得使用设备的许可之后，我们怎么做</li></ul></li></ul><h4 id="Promise-then-function-回调"><a href="#Promise-then-function-回调" class="headerlink" title="Promise.then(function(){})回调"></a>Promise.then(function(){})回调</h4><ul><li>刚刚说过，在then绑定一个回调函数，可以用来处理获得许可后的方法，那么我们就来看一下这里的代码</li><li>这里，表示我们取得使用权，那么我们就只需要处理反馈给我们的stream(流)就可以了</li><li>然后，我们获得视频轨道（后面我们需要关闭摄像头的），当然，在代码中我们为了严谨，还是做了一步判断，就简单来谈一下吧<ul><li>$this.MediaStreamTrack = typeof stream.stop === ‘function’ ? stream : stream.getTracks()[1];</li><li>这个我们先判断返回的流stream是不是一个函数，如果是的话，那么有可能这个流里面包含的不仅仅是一个视频轨道，所以在这进行了判断，更为严谨。三元表达式就不解释了吧。</li></ul></li><li>处理完stream之后，就非常简单了，我们想要在页面上展示视频，就是使用video，那么通过document获得页面元素video的dom对象video（因为懒得想名字了，就直接var video了。别误会它是什么东西，就是通过id获取的页面元素）</li><li>$this.video.srcObject = stream;</li><li>然后，就给video这个对象的srcObject赋值为当前的stream，完美搞定<ul><li>这里需要注意一下，有的帖子中写的是video.src = stream，可坑死了</li><li>因为之前没写过，所以刚开始就直接赋值的别人的代码，结果没画面，但是摄像头打开了</li><li>就是因为属性不是src，而是srcObject</li><li>于是乎，就去了上边链接的网站上看了很久文档，才慢慢搞明白怎么回事，然后自己封装成了自己的组件，以备不时之需，嘿嘿嘿</li></ul></li><li>虽说路径已经配好了，不过不觉得还差点什么吗？没错，video没有开始播放啊，不解释了，.play()</li></ul><h2 id="拍照"><a href="#拍照" class="headerlink" title="拍照"></a>拍照</h2><ul><li><p>ok，摄像头画面我们有了，那么就该”拍照”了吧，为什么把拍照两个字用引号引起来？还不懂吗？因为压根就不是拍照，而是canvas画图</p></li><li><p>这一步就非常简单了，照旧，在页面上添加一个 拍照 按钮，然后点击事件里面代码如下：</p><ul><li><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">this</span>.context.drawImage($<span class="keyword">this</span>.video, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">400</span>);</span><br></pre></td></tr></table></figure></li><li><p>一行代码搞定，就是直接将video像之前的img一样，直接放进去就OK了</p></li></ul></li></ul><h2 id="关闭摄像头"><a href="#关闭摄像头" class="headerlink" title="关闭摄像头"></a>关闭摄像头</h2><ul><li>记得关闭摄像头</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">this</span>.MediaStreamTrack.<span class="built_in">stop</span>();</span><br></pre></td></tr></table></figure><h2 id="问题点"><a href="#问题点" class="headerlink" title="问题点"></a>问题点</h2><h3 id="画面出不来"><a href="#画面出不来" class="headerlink" title="画面出不来"></a>画面出不来</h3><ul><li><p>别急别急，有可能是浏览器不兼容的问题</p></li><li><p>那么我们通过Navigator.mediaDevices来请求摄像头，可能因为浏览器问题而出现错误，别急，我们还有另一种办法</p></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">navigator.getMedia(&#123;</span><br><span class="line">                    <span class="string">"video"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(stream);</span><br><span class="line">                    $<span class="keyword">this</span>.MediaStreamTrack = stream.getTracks()[<span class="number">1</span>];</span><br><span class="line">                    $<span class="keyword">this</span>.video.srcObject = (<span class="built_in">window</span>.webkitURL).createObjectURL(stream);</span><br><span class="line">                    $<span class="keyword">this</span>.video.play();</span><br><span class="line">                &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(err);</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure></li><li><p>不过这种就是会返回一个函数</p></li></ul><h3 id="拍照无效果？"><a href="#拍照无效果？" class="headerlink" title="拍照无效果？"></a>拍照无效果？</h3><ul><li>这个不解释了，有这个问题很大部分应该就是画图中出现的那两个问题吧，如果当时你不知道为什么会出现那两种情况，那么当你做到摄像头拍照的时候就有可能会遇到了</li><li>好了，这个不解释，但是下面我们来完善一下页面，并且看看为什么会出现之前提出的两个问题</li></ul><h1 id="七、完善"><a href="#七、完善" class="headerlink" title="七、完善"></a>七、完善</h1><h2 id="页面效果完善"><a href="#页面效果完善" class="headerlink" title="页面效果完善"></a>页面效果完善</h2><ul><li>嘿嘿，说到这，我要提要求了，我们一般摄像头拍摄，是不是有需要弹出层的？有需要将影像固定在某个区域的，反正肯定不会是在页面最左上角吧？那样丑死了。</li><li>ok，那么我们就来看一下吧。最简单的思路就是，将video元素和canvas元素共同放在同一个容器中，这样不管需求想要将影像在哪呈现，只要把这个容器拿过去就OK了，里面什么都不需要动。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> id=<span class="string">"camera"</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> id=<span class="string">"contentHolder"</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">video</span> id=<span class="string">"video"</span> <span class="attribute">width</span>=<span class="string">"640"</span> height=<span class="string">"480"</span> autoplay&gt;&lt;/video&gt;</span><br><span class="line">&lt;<span class="selector-tag">canvas</span>  id=<span class="string">"canvas"</span> <span class="attribute">width</span>=<span class="string">"640"</span> height=<span class="string">"480"</span>&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> id=<span class="string">"buttons"</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">button</span> id=<span class="string">"btn_snap"</span> class=<span class="string">"btn btn_blue"</span>&gt;拍照&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li><p>ok，我的页面（老脸很红，这明明是朋友发来的页面）时这个样子滴，一个大的容器id = “camera”，而里面分两块div，一个是contentHolder用来呈现影响video以及拍照后保存画面的vanvas，另一个是存放按钮</p></li><li><p>我草，为什么会这样</p><p><img src="/2018/11/19/前端画图Canvas简单运用/h0.png" alt=""></p><ul><li>为什么？</li></ul><p><img src="/2018/11/19/前端画图Canvas简单运用/h1.png" alt=""></p></li></ul><ul><li>现在能够看到，原来是canvas，当初我们实验的时候没考虑过页面美化的问题吧？那么这个canvas怎么办？</li><li>很简单啦，将canvas设置为none不就行了？</li><li>但是，千万别傻傻地将canvas设置宽高为0，然后再改回来，这样没法画图的，上面的实验也说过了</li></ul><h2 id="js完善"><a href="#js完善" class="headerlink" title="js完善"></a>js完善</h2><ul><li><p>ok，如果按照之前设置为none之后，那么后面可能会没有画面，这个没关系，还记的之前的canvas补充里面的实验吗？就那么解决</p></li><li><p>但是还是有点担心，在将canvas设置为display:block之前，千万别忘记吧video设置为display:none，因为我们的容器只能同时容纳其中一个的大小，是为了美观，同时也是为了造成一种假象，那就是视频和拍照都在同一个容器里面，其实是两个元素（video和canvas）进行切换的</p></li><li><p>代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">this</span>.video.style.display = <span class="string">"none"</span>;</span><br><span class="line">$<span class="keyword">this</span>.canvas.style.display = <span class="string">"block"</span>;</span><br><span class="line">$<span class="keyword">this</span>.context.drawImage($<span class="keyword">this</span>.video, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">400</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul><li>最后就是个人封装的组件，代码就不贴在这了，单独贴到一个文章中吧</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;朋友遇到的情况，属于前端的问题，是需要打开摄像头来拍照，关于这个问题，他找到了我让我来帮他解决，不过由于我的前端
      
    
    </summary>
    
      <category term="前端" scheme="https://it233.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://it233.github.io/categories/%E5%89%8D%E7%AB%AF/js/"/>
    
    
      <category term="实录" scheme="https://it233.github.io/tags/%E5%AE%9E%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>java详解jvm工作原理和流程</title>
    <link href="https://it233.github.io/2018/11/15/java%E8%AF%A6%E8%A7%A3jvm%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%81%E7%A8%8B/"/>
    <id>https://it233.github.io/2018/11/15/java详解jvm工作原理和流程/</id>
    <published>2018-11-15T07:39:33.000Z</published>
    <updated>2018-11-16T02:00:52.069Z</updated>
    
    <content type="html"><![CDATA[<p>【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！</p><hr><p>[TOC]</p><h1 id="一、浅说java"><a href="#一、浅说java" class="headerlink" title="一、浅说java"></a>一、浅说java</h1><p>说起java,人们首先想到的是java编程语言,然而事实上,Java是一种技术,它由四方面组成:</p><ul><li>java编程语言</li><li>java类文件格式</li><li>java虚拟机</li><li>java应用程序接口(Java API)</li></ul><p>其关系如:</p><p><img src="/2018/11/15/java详解jvm工作原理和流程/java关系.png" alt=""></p><p>java平台由Java虚拟机和Java应用程序接口搭建,java语言则是进入这个平台的通道,用Java语言编写并编译的程序可以运行在这个平台上.</p><p>这个平台结构:</p><p><img src="/2018/11/15/java详解jvm工作原理和流程/平台结构.png" alt=""></p><p>运行期环境代表着Java平台,开发人员编写Java代码(.java文件),然后将之编译成字节码(.class)文件,在然后字节码被装入内存,一旦字节码进入虚拟机,它就会被解释器解释执行,或者是被即时代码发生器有选择的转换成机器码执行. </p><p>java程序经过一次编译之后，将java代码编译为字节码也就是class文件，然后在不同的操作系统上依靠不同的java虚拟机进行解释，最后再转换为不同平台的机器码，最终得到执行。这样我们是不是可以推演，如果要在mac系统上运行，是不是只需要安装mac java虚拟机就行了。 </p><p>JVM在它的生命周期中有一个明确的任务,那就是运行java程序,因此当Java程序员启动的时候,就产生JVM的一个实例;当程序运行结束的时候,该实例也就跟着消失了 </p><p>在Java平台的结构中,可以看出,Java虚拟机(JVM)处在核心的位置,是程序与底层操作系统和硬件无关的一个关键.下方是移植接口. </p><p>移植接口由两部分组成：适配器 和 Java操作系统</p><p>其中依赖于平台的部分被称为适配器</p><p>JVM通过移植接口在具体的平台和操作系统上实现;在JVM的上方是Java的基本类库和扩展类库以及他们的API,利用Java API编写的应用程序(application)和小程序(java applet)可以在任何Java平台上运行而无需考虑底层平台,就是因为有Java虚拟机(JVM实现了程序与操作系统的分离,从而实现了Java的平台无关性)</p><h1 id="二、JVM基本概念和运行过程"><a href="#二、JVM基本概念和运行过程" class="headerlink" title="二、JVM基本概念和运行过程"></a>二、JVM基本概念和运行过程</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念:"></a>1.基本概念:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JVM是可运行Java代码的假象计算机（虚拟计算机）</span><br></pre></td></tr></table></figure><p>JVM包括：</p><ul><li>一套字节码指令集</li><li>一组寄存器</li><li>一个栈</li><li>一个垃圾回收</li><li>堆</li><li>一个存储方法域</li></ul><p>JVM是运行在操作系统之上的,它与硬件没有直接的交互 </p><h2 id="2-运行过程"><a href="#2-运行过程" class="headerlink" title="2.运行过程"></a>2.运行过程</h2><p>Java源文件 通过 编译器 能够产生相应的 字节码文件(.Class文件) ,而字节码文件又通过 Java虚拟机中的解释器 编译成 特定机器上的机器码</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">java源文件</span>  <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;  <span class="comment">编译器</span>  <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;  <span class="comment">字节码文件</span></span><br><span class="line"><span class="comment">字节码文件</span>  <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">JVM</span>  <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;  <span class="comment">机器码</span></span><br></pre></td></tr></table></figure><p>每一种平台 的 解释器是不同的, 但是实现的 虚拟机 是 相同 的,这也就是Java为什么能够 跨平台 的原因了 </p><p>当一个 程序从开始运行 这时 虚拟机 就开始 实例化 了,  多个程序 启动就会存在 多个虚拟机实例. 程序 退出或关闭, 则虚拟机 实例消亡 ,  </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">注意:</span></span><br><span class="line">多个虚拟机实例之间数据不能共享</span><br></pre></td></tr></table></figure><h2 id="3-三种JVM"><a href="#3-三种JVM" class="headerlink" title="3.三种JVM:"></a>3.三种JVM:</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- Sun 公司的 HotSpot</span><br><span class="line">- BEA 公司的 JRockit</span><br><span class="line">- IBM 公司的 J9 JVM</span><br><span class="line"></span><br><span class="line">在 JDK1.7 及其以前我们所使用的都是 Sun 公司的 HotSpot, 但是由于 Sun公司 和 BEA公司都被 oracle 收购</span><br><span class="line"></span><br><span class="line">jdk1.8 将采用 Sun 公司的<span class="built_in"> HotSpot </span>和 BEA 公司的 JRockit 两个JVM中 精华 形成  jdk1.8的JVM</span><br></pre></td></tr></table></figure><h1 id="三、JVM的体系结构"><a href="#三、JVM的体系结构" class="headerlink" title="三、JVM的体系结构"></a>三、JVM的体系结构</h1><p><img src="/2018/11/15/java详解jvm工作原理和流程/jvm结构图1.png" alt=""></p><p><img src="/2018/11/15/java详解jvm工作原理和流程/jvm结构图2.png" alt=""></p><h2 id="1-Class-Loader类加载器"><a href="#1-Class-Loader类加载器" class="headerlink" title="1.Class Loader类加载器"></a>1.Class Loader类加载器</h2><p>负责加载.class文件,class文件在文件开头有特定的文件标示,并且ClassLoader负责class文件的加载等.但是至于它是否可以运行,则由Execution Engine(执行引擎)决定 </p><ul><li>定位和导入 二进制.class文件</li><li>验证 导入类的正确性</li><li>为类 分配 初始化 内存</li><li>帮助 解析 符号引用</li></ul><h2 id="2-Native-Interface-本地接口"><a href="#2-Native-Interface-本地接口" class="headerlink" title="2.Native Interface 本地接口"></a>2.Native Interface 本地接口</h2><p>本地接口的作用是 融合不同的编程语言为Java所用, 它的 初衷 是融合 C/C++ , Java诞生的时候C/C++横行的时候,想要立足,必须调用C/C++程序, 于是就在内存中专门开辟了一块区域处理标记为 native的代码.</p><p>具体做法: Native Method Stack中登记native 方法,在Execution Engine执行的时候加载native libraies(本地方法库)</p><p>不过目前该方法使用的越来越少了,除非是与硬件有关的应用,</p><p>如:</p><p>通过Java程序驱动打印机,或者Java系统管理生产设备,在企业级应用中已经比较少见</p><p>因为现在的 异构领域空间 的通信很发达 ,比如:可以使用 Socket通信, 也可以使用 Web Service等</p><h2 id="3-Excution-Engine-执行引擎"><a href="#3-Excution-Engine-执行引擎" class="headerlink" title="3.Excution Engine 执行引擎:"></a>3.Excution Engine 执行引擎:</h2><p>执行 包在 装载类 的方法中的 指令,也就是 方法</p><h2 id="4-Runtime-data-area-运行数据区"><a href="#4-Runtime-data-area-运行数据区" class="headerlink" title="4.Runtime data area 运行数据区:"></a>4.Runtime data area 运行数据区:</h2><p>虚拟机内存或者 JVM内存, 从整个 计算机内存中开辟 一块内存 存储 JVM用到的 对象,变量等</p><p>运行区数据又分很多小区,分别为：方法区  堆  虚拟机栈  本地方法栈 程序计数器 </p><h2 id="5-JVM数据运行区详解-栈管运行-堆管存储"><a href="#5-JVM数据运行区详解-栈管运行-堆管存储" class="headerlink" title="5.JVM数据运行区详解(栈管运行,堆管存储):"></a>5.JVM数据运行区详解(栈管运行,堆管存储):</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">说明: jvm调优主要就是 优化Heap堆和<span class="function"><span class="keyword">Method</span> <span class="title">Area</span>方法区</span></span><br></pre></td></tr></table></figure><p><img src="/2018/11/15/java详解jvm工作原理和流程/jvm数据运行区.png" alt=""></p><ul><li><p>方法区  Method Area </p><ul><li>方法区是各个线程共享的区域，</li><li>所有 字段  和 方法字节码 ,以及一些特殊方法如 构造函数, 接口代码 也在此定义.</li><li>简单说,所有 定义的方法的信息 都保存在该区域,属于 共享区间 </li><li>静态变量 + 常量 + 类信息 + 运行时常量池 存在方法区中 </li></ul></li><li><p>堆 </p><ul><li>java堆也是线程共享的区域，我们的类的实例就放在这个区域(而指向该实例变量的引用存在栈)，</li><li>可以想象你的一个系统会产生很多实例，因此java堆的空间也是最大的。</li><li>如果java堆空间不足了，程序会抛出OutOfMemoryError异常。 </li><li>也是 GC（垃圾回收机制） 主要的 回收区,  一个JVM 实例只存在 一个堆 类内存,堆内存的 大小 是可以 调节 的 </li></ul></li><li><p>虚拟机栈  VM Stack  </p><ul><li><p>栈是什么 ：栈也叫 栈内存, 主管Java 程序的运行, 是在  线程创建时 创建, 他的生命期是跟随 线程的生命期, 线程结束 栈内存也就 释放,  对于栈来说 不存在垃圾回收问题, 只要线程已结束该栈就over,生命周期和线程一致, 是 线程私有的 </p></li><li><p>基本类型 的变量和 对象的引用 变量都是在函数的 栈内存中分配 </p></li><li><p>栈存储什么：栈帧中主要保存 3类数据:</p><ul><li>本地变量(Local Variables): 输入参数和输出参数以及方法内的变量</li><li>栈操作( Operand Stack ): 记录出栈,入栈的操作</li><li>栈帧数据( Frame Data ): 包括类文件,方法等等</li></ul></li><li><p>栈运行原理</p><ul><li>栈中的 数据 都是以 栈帧的格式 存在, 栈帧是一个 内存区块, 是一个 数据集, 是一个有关 方法 和运行期 数据 的 数据集</li><li>当一个方法A被调用时就产生了一个栈帧F1,并被压入到栈中,A方法有调用了B方法,于是产生栈帧F2也被压入栈,B方法有调用了C方法,于是产生的栈帧F3也被压入栈……依次执行完毕后,先弹出后进……F3,再弹出F2,F1 </li><li>遵循 先进后出/后进先出 原则  </li></ul></li><li><p>就是说，java栈是每个线程私有的区域，它的生命周期与线程相同，一个线程对应一个java栈，每执行一个方法就会往栈中压入一个元素，这个元素叫“栈帧”，而栈帧中包括了方法中的局部变量、用于存放中间状态值的操作栈，这里面有很多细节。如果java栈空间不足了，程序会抛出StackOverflowError异常，想一想什么情况下会容易产生这个错误，对，递归，递归如果深度很深，就会执行大量的方法，方法越多java栈的占用空间越大。 </p></li></ul></li><li><p>本地方法栈  Native Method Stack </p><ul><li>本地方法栈角色和java栈类似，只不过它是用来表示执行本地方法的，它的具体做法是Native Method Stack中登记native方法，本地方法栈存放的方法调用本地方法接口，在Execution Engine执行时候加载native libraies ，最终调用本地方法库，实现与操作系统、硬件交互的目的。 </li></ul></li><li><p>程序计数器</p><ul><li>PC寄存器（有的这么叫，这里提一下），说到这里我们的类已经加载了，实例对象、方法、静态变量都去了自己该去的地方，那么问题来了，程序该怎么执行，哪个方法先执行，哪个方法后执行，这些指令执行的顺序就是PC寄存器在管，它的作用就是控制程序指令的执行顺序 （Register，也是记录，登记，寄存的意思，就是用来管理的）</li><li>每个线程都一个 程序计算器, 就是一个 指针, 指向  方法区中的 方法字节码 (下一个将要执行的指令代码),由  执行引擎读取  下一条指令,是一个 非常小 的内存空间,几乎可以 忽略不计 </li></ul></li></ul><h2 id="6-堆内存"><a href="#6-堆内存" class="headerlink" title="6.堆内存"></a>6.堆内存</h2><p>  堆内存分为3部分: </p><p>  <img src="/2018/11/15/java详解jvm工作原理和流程/堆内存.png" alt=""></p><p>  1.新生区</p><ul><li>新生区是 类 的 诞生,成长,消亡 的区域.</li><li>一个 类 在这里 产生,应用, 最后被 垃圾回收器收集,结束生命</li><li><p>新生区又分为两部分:</p><ul><li>伊甸区(Eden space) :所有的类都是在伊甸区被new出来的 </li><li>幸存者区(Survivor Space) :有两个,0区和1区 <ul><li>当伊甸区的空间用完时,程序有需要创建对象,JVM的垃圾回收器将对伊甸区进行垃圾回收(Minor GC),将伊甸区中的剩余对象移动到幸存0区, </li><li>若0取也满了,对该区域进行垃圾回收,然后移动到1区 </li><li>1区满了移动到养老区(Tenure Generation Space) </li><li>养老区满了,这时候将产生Major GC(FullGC),进行养老区的内存清理. </li><li>若养老区执行Full GC之后发现依然无法进行对象的保存,会产生OOM异常(OutOfMemoryError,内存溢出) </li><li>所以，如果出现java.lang.OutOfMemoryError:Java heap space异常,说明Java虚拟机的堆内存不够 ，原因有二：<ul><li>Java虚拟机的堆内存 设置 不够,可以通过参数 -Xms,  -Xmx  调整 (jvm调优方面会说)</li><li>代码中创建了 大量大对象,并且长时间 不能被 垃圾收集器 收集(存在被引用) </li></ul></li></ul></li></ul><p>2.养老区</p></li><li><p>用于保存从新生区筛选出来的Java对象,一般 池对象  都在这个区域活跃 </p></li><li>年老代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在） </li><li>内存大小相对会比较大，垃圾回收也相对没有那么频繁（譬如可能几个小时一次） </li><li>年老代主要采用压缩的方式来避免内存碎片（将存活对象移动到内存片的一边，也就是内存整理）。</li><li><p>当然，有些垃圾回收器（譬如CMS垃圾回收器）出于效率的原因，可能会不进行压缩。 （这些调优篇细讲）</p><p>3.永久区（Permanent Space ）</p></li><li><p>是一个 常驻内存区域 , 用于存放 JDK自身 所携带的 class,interface的元数据 </p></li><li>也就是说它存储的是 运行环境必须 的类信息,被装载进此区域的数据是 不会被  垃圾回收器 回收 掉的 </li><li>关闭JVM 才会释放  此区域所占用的内存 </li><li>如果出现java.lang.OutOfMemoryError:PermGen space,说明是Java虚拟机对永久代Perm内存设置不够 ，原因也有两点：<ul><li>程序启动需要加载大量的第三方jar包. 如:在一个tomcat下部署了太多的应用 </li><li>大量动态反射生成的类不断被加载,最终导致Perm区被占满 </li></ul></li><li>关于永久区的个版本：<ul><li>jdk1.6之前:常量池分配在永久带</li><li>jdk1.7:有,但已经逐步”去永久带”</li><li>jdk1.8之后:无(java.lang.OutOfMemoryError:PermGen space这种错误将不会出现在JDK1.8中)</li><li>下面两张图片解释一下</li></ul></li></ul><p><img src="/2018/11/15/java详解jvm工作原理和流程/永久区1.png" alt=""></p><p><img src="/2018/11/15/java详解jvm工作原理和流程/元空间.png" alt=""></p><h1 id="四、-方法区和堆内存的异议"><a href="#四、-方法区和堆内存的异议" class="headerlink" title="四、 方法区和堆内存的异议:"></a>四、 方法区和堆内存的异议:</h1><p>实际而言,方法区和堆一样,是各个线程共享的内存区域,它用于存储虚拟机加载的: </p><p>类信息+普通常量+静态常量+编译器变异后的代码</p><p>虽然JVM规范将方法区描述为堆的一个逻辑部分,但它却还有一个别名叫做Non-Heap(非堆),目的就是要和堆分开.</p><p>对于HotSpot虚拟机,很多开发者习惯将方法区称之为”永久代(Parmanent Gen)”,但严格本质上说两者不同,或者说使用永久代来实现方法区而已,永久代是方法区的一个实现,jdk1.7的版本中,已经将原本放在永久代的字符串常量池移走</p><p>常量池(Constant Pool)是方法区的一部分,class文件除了有类的版本,字段,方法,接口等描述信息外,还有一项信息就是常量池,这部分内容将在类加载后进入方法区的运行时常量池中存放.</p><h1 id="五、简单补充"><a href="#五、简单补充" class="headerlink" title="五、简单补充"></a>五、简单补充</h1><p>堆内存调优简介 </p><p><img src="/2018/11/15/java详解jvm工作原理和流程/堆内存优化简介.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;一、浅说java&quot;&gt;&lt;a href=&quot;#一、浅说java&quot; class=&quot;he
      
    
    </summary>
    
      <category term="java" scheme="https://it233.github.io/categories/java/"/>
    
      <category term="jvm" scheme="https://it233.github.io/categories/java/jvm/"/>
    
    
      <category term="笔记" scheme="https://it233.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java中的关键字native</title>
    <link href="https://it233.github.io/2018/11/15/Java%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97native/"/>
    <id>https://it233.github.io/2018/11/15/Java中的关键字native/</id>
    <published>2018-11-15T02:55:05.000Z</published>
    <updated>2018-11-28T06:48:29.012Z</updated>
    
    <content type="html"><![CDATA[<p>【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！</p><hr><p>[TOC]</p><h1 id="一、简单介绍"><a href="#一、简单介绍" class="headerlink" title="一、简单介绍"></a>一、简单介绍</h1><p>native关键字</p><ul><li><p>众所周知，java是跨平台的语言，既然跨平台，就要牺牲对底层的控制，所以java对于底层的控制就依赖于其他语言的帮助，而这就是native的作用</p></li><li><p>native是用作java和其他语言进行协作时用的，也就是native后的方法的实现不是用java写的。既然不是java写的，那肯定看不到它的源码了</p></li><li><p>native修饰的方法时一个原生态方法,方法对应的实现不是在当前文件,而是在用其他语言(如C或者C++)实现的文件中.并且被编译成了dll文件。</p></li><li>这些方法的实现体在dll文件中，jdk的源码中并不包含，所以是看不到的。对于不同的平台，他们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的</li><li>Java语言本身不能对操作系统底层进行访问和操作,但是可通过JNI接口调用其他语言来实现对底层的访问.</li><li>JNI是Java本机接口(Java Native Interface),是一个本机编程接口,是Java软件开发发工具箱(java Software Development Kit, SDK)的一部分.JNI允许Java代码使用以其他语言编写的代码和代码库.</li><li>Invocation API(JNI的一部分)可以用来将Java虚拟机(JVM)嵌入到本机应用程序中,从而允许程序员代码内部调用java代码</li><li>所以，native的意思就是通知操作系统，我需要这个方法，而你操作系统需要给我实现，我需要使用。而java只需要调用操作系统的方法就行了</li><li>java不是完美的，java的运行速度上比传统的C语言慢许多，java无法直接访问到底层操作系统等缺点。当然，解决方法就是上面说的利用native方法来扩展java程序的功能。以下有实践步骤：是之前做笔记的时候尝试的：</li></ul><h1 id="二、实践理解"><a href="#二、实践理解" class="headerlink" title="二、实践理解"></a>二、实践理解</h1><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用java调用<span class="keyword">C</span>的<span class="string">"sayHello"</span></span><br></pre></td></tr></table></figure><p>1.创建一个java类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloNative</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"HelloNative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"static-access"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> HelloNative().sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个sayHello()方法，native标识该方法的实现在非当前文件，在static静态快中加载的library(HelloNative)中</p><p>运行main()之后出现以下情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>报错信息时说找不到library(“HelloNative”)的路径，因为我们本地就没有这个文件</p><p>2.创建本地方法文件</p><p>我们将Java类HelloNative复制出来，（我给放在了D盘根目录，方便）</p><p>然后在控制台用javac命令将其编译成字节码文件，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">javac</span> <span class="selector-tag">HelloNative</span><span class="selector-class">.jave</span></span><br></pre></td></tr></table></figure><p>注意：如果命令输入目录与.java文件不在同一目录下，javac命令后的文件名要加路径，如图中d:\HelloNative.java：</p><p><img src="/2018/11/15/Java中的关键字native/cmd01.png" alt=""></p><p>然后在用havah编译，获得包含C声明头文件</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">javah HelloNative</span></span><br></pre></td></tr></table></figure><p>注意：在这里，我命令目录与文件目录不在同一路径，报错了，这个命令不会区别路径，而是在当前目录下找d:\HelloNative这个名字的文件，把d:\也当成文件名字的一部分</p><p>到此，我们一共有三个文件了：</p><p><img src="/2018/11/15/Java中的关键字native/files.png" alt=""></p><p>看一下.h文件的内容吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class HelloNative */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_HelloNative</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_HelloNative</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     HelloNative</span></span><br><span class="line"><span class="comment"> * Method:    sayHello</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_HelloNative_sayHello</span><br><span class="line">  (JNIEnv *, jclass);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>创建.c文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后运行gcc命令来生成dll共享库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>命令中的路径是电脑中jdk的安装路径\include</p><p>完成后这样就有5个文件了：</p><p><img src="/2018/11/15/Java中的关键字native/files5.png" alt=""></p><p>然后在用java命令运行一下java代码，就能成功在cmd通过java代码调用c的sayHello方法了</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">java HelloNative</span></span><br></pre></td></tr></table></figure><p>说明：</p><p>从gcc命令开始，没有图和真相了，那是因为我所有的笔记标签的文章都是回头看以前做的笔记的时候，重新整理记录一下，也有的是之前没有记录到的，整理的时候又重新学一遍；也有之前试验过但是现在环境不允许了。</p><p>不过又去了网上看了看帖子，别人的文章有的用的命令不一样，所以具体如何生成dll，尝试一下就行了，只要生成了dll就OK了</p><h1 id="三、步骤总结："><a href="#三、步骤总结：" class="headerlink" title="三、步骤总结："></a>三、步骤总结：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总结一下步骤吧：</span><br></pre></td></tr></table></figure><p>1 先创建java类，在类中加载需要的library，声明要调用的本地方法</p><p>2  使用javac命令编译.java文件，生成字节码文件.class</p><p>3  使用javah命令编译成.h文件，生成包含C声明头的文件</p><p>4  编写c文件（.c），然后通过gcc命令(或者vs C++环境下cl命令)生成dll</p><p>5  然后利用java命令运行Java代码检测是否成功</p><p>其实，上面的这个步骤是反着来的，是因为我们从java介入，往底层找的，真正的顺序应该是先写好的c方法生成dll共享库，然后jvm启动之后留在本地方法区中，随着我们写好java代码之后，如果需要用到本地方法，我们就去找相应的方法直接调用就行了(这部分可以简单看一下jvm方面的知识应该比较容易理解，好了，我再看看jvm的笔记)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【笔记】标签，是对于以前做的一些笔记的回顾，同时还有新的学习。有可能有些地方已经遗漏了，也可能有些地方无法确证，甚至有的地方理解有误！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;一、简单介绍&quot;&gt;&lt;a href=&quot;#一、简单介绍&quot; class=&quot;header
      
    
    </summary>
    
      <category term="java" scheme="https://it233.github.io/categories/java/"/>
    
      <category term="关键字" scheme="https://it233.github.io/categories/java/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    
      <category term="笔记" scheme="https://it233.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用JPA创建原生sql(不使用实体类)</title>
    <link href="https://it233.github.io/2018/11/13/%E4%BD%BF%E7%94%A8JPA%E5%88%9B%E5%BB%BA%E5%8E%9F%E7%94%9Fsql-%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BD%93%E7%B1%BB/"/>
    <id>https://it233.github.io/2018/11/13/使用JPA创建原生sql-不使用实体类/</id>
    <published>2018-11-13T05:19:38.000Z</published>
    <updated>2018-11-28T06:28:05.778Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一、描述"><a href="#一、描述" class="headerlink" title="一、描述"></a>一、描述</h1><ul><li><p>JPA很强大，嗯，没错，是很强大！</p><pre><code>它是通过JDK5.0注解或者XML描述对象-关系表的映射关系，并能够将在运行中的实体对象持久化到数据库中。</code></pre></li><li><p>并且它也是面向对象查询，也就是将实体类与数据库的表映射，即使不会数据库的开发者，只要能看懂java的类，只要能熟练使用jpa，也能很便捷地操作数据库</p></li><li><p>当然，映射类有其好处，也有弊端。假如说，某个场景下，我需要查询多个表中的数据，并且每个表中只有一到两个字段有用，而整张表的字段又很多，所以有时候就不需要将每个表都完整映射成实体类（不然的话，每次查询就要多查询很多无用的垃圾信息）</p></li><li><p>今天遇到了这种场景，由于是多表联查，但是只需要其中各一个字段，其余的每个表十几个字段都没用。所以就不需要把每张表的数据都查询出来。而个人对于jpa也不熟练，所以踩了很多坑。下面就此记录：</p></li></ul><h1 id="二、实录"><a href="#二、实录" class="headerlink" title="二、实录"></a>二、实录</h1><pre><code>（踩坑全过程，实力坑自己！Pain and happiness!想直接看结果，直接拉下去别看这段了）</code></pre><h3 id="想法1、"><a href="#想法1、" class="headerlink" title="想法1、"></a>想法1、</h3><p>返回map，不用实体类</p><p>1.dao层（Repository）</p><ul><li>就是控制sql语句对数据库进行增删改查。</li><li><p>这里的接口很容易写，只需要继承JpaRepository&lt;entity,object&gt;接口就可以了<br>#<br>  这里需要注意：<br>  1.entity，必须是被管理的类，也就是与数据库进行映射的实体类</p><p>  所以，就坑在这了，一直报错说Repository什么什么类型必须是被映射管理的，而map却不是。奶奶的，继续想办法</p><h3 id="想法2、"><a href="#想法2、" class="headerlink" title="想法2、"></a>想法2、</h3></li></ul><p>创建实体类（不过由于不懂，所以这里没有进行关系映射，就是一个单纯的javaBean，不用仔细说了失败！）</p><p>​    注意：<br>    1.实体类必须与数据库映射才算被映射管理（@Entity注解）</p><pre><code>继续尝试</code></pre><h3 id="想法3、"><a href="#想法3、" class="headerlink" title="想法3、"></a>想法3、</h3><p>映射实体类(但是这次也只写了部分字段，自己需要的)</p><p>​    注意：</p><ul><li>加上注解标明映射之后，又特么脑残踩了个雷（鄙视自己一秒钟）<ul><li>对于这个，说一下吧，由于最初没打算映射，并且需要的数据是多个表的，所以类名就自己起的名字。好家伙，提示table_name没有被映射过！我嘞个擦。所以在@Entity注解加上name属性：</li><li>@Entity(name=”table_name”)最初的时候加错了，写成实体类的名字了，尴尬！这里其实要写表的名字，表明该实体类与那张表映射</li></ul></li><li>与数据库映射的类必须有@Id标明主键(失败一次！吼，不想解释了)</li><li>这一点忍无可忍！错误信息说，表中为not null的字段，必须在实体类中映射！也就是实体类中必须有非空字段的属性！！！<ul><li>吼吼吼！！我连吼三次可以了吧！那我跟映射全部字段有什么区别呢？还是初衷吗？</li></ul></li><li>以上一环扣一环之后，想要按照之前想法，实体类，拜拜！</li><li>经过以上绕的弯路，所以就又绕回来了。哼哼！于是乎：老子不用实体类了，也不继承JpaRepository。</li></ul><h3 id="想法4、"><a href="#想法4、" class="headerlink" title="想法4、"></a>想法4、</h3><p>注解托管Repository！</p><pre><code>奈斯！启动刚开始没报错，之前报错貌似跳过去了！突然之间，XXXXXX that could not be found，我真xxxx了，然后去网上找解决方法，要吐血！各种各样的方法，没用！直到我看到一个帖子：</code></pre><p><img src="/2018/11/13/使用JPA创建原生sql-不使用实体类/1.png" alt="帖子截图"></p><pre><code>一口老血啊！果断不找了！（别学我，因为刚刚在找这个帖子的时候，无意间瞥见另一个帖子，解决方案是：在Application启动类中加上注解：@EnableJpaRepositories(&quot;com.example.repository&quot;)来说明要扫描的类，虽然之前也在启动类中加过注释，但我也记不清这个到底有没有尝试过了，感觉很靠谱，这里说一下！失败了也别来找我,也有可能环境不同）所以！这是一个死循环啊，想要用dao层Repository，OK的，继承JPARepository吧，等等，我jpa有条件的，entity呢？ 好，给你！慢着，我entity不干，先给cp一个数据库表吧，我可不打酱油的！唉，给你cp个表吧，停！cp随便你，但是我有孩子，得带过去，你去问问entity同不同意！尼玛，可怕！！！于是，果断放弃了从dao层入手。</code></pre><h1 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h1><ul><li><p>JPA很强大，嗯，没错，是很强大！</p><p>  又是这句话，没错，我们如果映射实体类的话，那么目前的情况就感觉无用数据太多，而且累赘，要映射好几张表<br>  但是别怕，jpa不但能面向对象查询，还支持原生sql，能够让我们根据自己的想法来实现</p></li><li><p>第一种：使用注解@Query(value=”sqlString”)</p></li><li><p>第二种：entityManager.createNativeQuery(sqlString)</p><p>  第一种，注解在dao层的方法上，由于我自动装配出问题了，并且及早地放弃了，所以没用，</p><p>  第二种，上代码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Query query = entityManager.createNativeQuery(<span class="string">"select * from user where id = ?"</span>);</span><br><span class="line">query.setParameter(<span class="number">1</span>,<span class="string">"g10001"</span>);</span><br><span class="line">List list = query.getResultList();</span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   map.put(<span class="string">"name1"</span>,objs.get(<span class="number">0</span>)[<span class="number">0</span>].toString());</span><br><span class="line">   map.put(<span class="string">"name2"</span>,objs.get(<span class="number">0</span>)[<span class="number">1</span>].toString());......</span><br></pre></td></tr></table></figure><p>搞定！list是List&lt;Object[]&gt;类型，里面放的就是一条条数据，而Object[]数组里面是一条数据中的所有字段。</p><p>不过又见几个坑，是网上的帖子，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object os : list)&#123;</span><br><span class="line">Map map = (Map)os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我只求数组（实际上是Object类型的数组）强转Map这波操作！！！！没别的要求</p><h1 id="四、"><a href="#四、" class="headerlink" title="四、"></a>四、</h1><pre><code>诙谐的话语，搞笑而又逗逼！就跟老朋友聊骚，听老朋友牢骚。轻松吗？</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;一、描述&quot;&gt;&lt;a href=&quot;#一、描述&quot; class=&quot;headerlink&quot; title=&quot;一、描述&quot;&gt;&lt;/a&gt;一、描述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JPA很强大，嗯，没错，是很强大！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;它是通过JDK
      
    
    </summary>
    
      <category term="java" scheme="https://it233.github.io/categories/java/"/>
    
      <category term="框架" scheme="https://it233.github.io/categories/java/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="JPA" scheme="https://it233.github.io/categories/java/%E6%A1%86%E6%9E%B6/JPA/"/>
    
    
      <category term="实录" scheme="https://it233.github.io/tags/%E5%AE%9E%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql建表时设置日期默认值及默认修改时间</title>
    <link href="https://it233.github.io/2018/11/12/mysql%E5%BB%BA%E8%A1%A8%E6%97%B6%E8%AE%BE%E7%BD%AE%E6%97%A5%E6%9C%9F%E9%BB%98%E8%AE%A4%E5%80%BC%E5%8F%8A%E9%BB%98%E8%AE%A4%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4/"/>
    <id>https://it233.github.io/2018/11/12/mysql建表时设置日期默认值及默认修改时间/</id>
    <published>2018-11-12T03:10:06.000Z</published>
    <updated>2018-12-06T09:42:05.230Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一、简单说明"><a href="#一、简单说明" class="headerlink" title="一、简单说明"></a>一、简单说明</h1><pre><code>在做项目的时候，在数据库中基本上都会有关于日期的问题。其中不乏包括日期格式、运算、比较等等。不过这些都很常见了，今天要记录的点，非常简单，不过可能也是很多情况下忽略的东西。关于这次记录的东西，就是mysql中时间格式的默认值。很多时候，我们都会对一条数据的相关时间进行记录，比如创建日期，修改日期等等最常见的。而处理这些日期的大部分方法，一般是在后台中获取当前的时间，然后随着数据插入到表中进行保存。下面，要说的是用mysql自带的方法来实现。（如果觉得没多大意义的话，请止步到此吧，如果想了解一下，请继续）</code></pre><h1 id="二、图文示例"><a href="#二、图文示例" class="headerlink" title="二、图文示例"></a>二、图文示例</h1><pre><code>这里使用的版本是MySQL 5.6</code></pre><h3 id="1-mysql的日期和时间类型（这里会展示一下各种时间格式，不想看的跳过）"><a href="#1-mysql的日期和时间类型（这里会展示一下各种时间格式，不想看的跳过）" class="headerlink" title="1.mysql的日期和时间类型（这里会展示一下各种时间格式，不想看的跳过）"></a>1.mysql的日期和时间类型（这里会展示一下各种时间格式，不想看的跳过）</h3><pre><code>先来看一下mysql中的日期和时间类型，以及其值的样子</code></pre><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql日期和时间类型.png" alt="mysql的日期和时间类型"></p><pre><code>- 在图中我们能够看到，我给所有的日期和时间类型赋值都是年/月/日 时:分:秒.毫秒- 而最终查询出来的日期格式如列表展示，不同的类型，格式也不同- 其中year类型只能赋值并保存年份，不过这个字段的赋值有点有意思的地方</code></pre><h4 id="1-1-year类型"><a href="#1-1-year类型" class="headerlink" title="1.1 year类型"></a>1.1 year类型</h4><pre><code>我们先来看看不同的赋值的结果</code></pre><p>1.首先赋值0</p><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql-year-0.png" alt="mysql-year-0"></p><p>2.然后1</p><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql-year-1.png" alt="mysql-year-0"></p><pre><code>应该有人应该猜出来了吧,不过我很好奇的是，这个赋值到底范围是多少，于是在这个过程中又遇到了有趣的事情</code></pre><p>3.然后：</p><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql-year-69.png" alt="mysql-year-69.png"></p><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql-year-70.png" alt="mysql-year-70.png"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">到这里就能看出来，mysql日期虽然年份能够不用写完整的<span class="number">4</span>位，但是对于只写两位数，mysql中还是有点范围的<span class="number">70</span>表示<span class="number">1970</span>，而<span class="number">0</span>表示的是<span class="number">2000</span>，很显然，最多就是<span class="number">99</span>表示<span class="number">1999</span>了，然后从<span class="number">1</span><span class="number">-69</span>表示的是<span class="number">2001</span><span class="number">-2069</span>，所以mysql非完整的年份默认值范围<span class="number">0</span><span class="number">-99</span></span><br></pre></td></tr></table></figure><p>4.完整年份最大值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不要问我怎么来的，我无聊</span><br></pre></td></tr></table></figure><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql-time-maxvalue.png" alt="mysql-time-maxvalue.png"></p><h3 id="2-正题：设置默认时间"><a href="#2-正题：设置默认时间" class="headerlink" title="2.正题：设置默认时间"></a>2.正题：设置默认时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个设置是创建该数据的当前时间</span><br></pre></td></tr></table></figure><p>1.使用函数now()</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql中有函数可以在sql语句中直接使用（废话不解释了），<span class="built_in">now</span>()都不陌生</span><br></pre></td></tr></table></figure><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql-default-now.png" alt="mysql-default-now.png"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不过支持<span class="built_in">now</span>()函数的只有datetime和timestamp两种类型，其他三种都不支持</span><br></pre></td></tr></table></figure><p>2.current_（cur系列）</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们可以利用<span class="keyword">default</span> current_timestamp为timestamp类型的设置默认值</span><br><span class="line"></span><br><span class="line">不过很无奈的是，mysql中有current_date和current_time等，但是我这个版本却不能用，</span><br></pre></td></tr></table></figure><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/mysql-default-cur.png" alt="cur.png"></p><p>3.自动记录修改时间</p><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/default-update-insert.png" alt="default-update-insert.png"></p><p><img src="/2018/11/12/mysql建表时设置日期默认值及默认修改时间/default-update.png" alt="default-update.png"></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在这里能够看到，<span class="built_in">id</span>为<span class="number">1</span>的这条数据时间变成了执行update时候的时间</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于前两天接了新项目，所以写了一半就停下来了，今天有点时间，想着就写完它。勉强看，也算给自己做个记录</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;一、简单说明&quot;&gt;&lt;a href=&quot;#一、简单说明&quot; class=&quot;headerlink&quot; title=&quot;一、简单说明&quot;&gt;&lt;/a&gt;一、简单说明&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;在做项目的时候，在数据库中基本上都会有关于日期的问题。其中不乏包括
      
    
    </summary>
    
      <category term="DB" scheme="https://it233.github.io/categories/DB/"/>
    
      <category term="MySQL" scheme="https://it233.github.io/categories/DB/MySQL/"/>
    
    
      <category term="mysql" scheme="https://it233.github.io/tags/mysql/"/>
    
      <category term="日期" scheme="https://it233.github.io/tags/%E6%97%A5%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://it233.github.io/2018/11/09/hello-world/"/>
    <id>https://it233.github.io/2018/11/09/hello-world/</id>
    <published>2018-11-09T09:28:16.849Z</published>
    <updated>2018-11-09T07:30:41.525Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="其他" scheme="https://it233.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="其他" scheme="https://it233.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
</feed>
