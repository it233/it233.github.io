<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java中的关键字native]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F15%2FJava%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97native%2F</url>
    <content type="text"><![CDATA[#一、简单介绍 native关键字 总所周知，java是跨平台的语言，既然跨平台，就要牺牲对底层的控制，所以java对于底层的控制就依赖于其他语言的帮助，而这就是native的作用 native是用作java和其他语言进行协作时用的，也就是native后的方法的实现不是用java写的。既然不是java写的，那肯定看不到它的源码了 native修饰的方法时一个原生态方法,方法对应的实现不是在当前文件,而是在用其他语言(如C或者C++)实现的文件中.并且被编译成了dll文件。 这些方法的实现体在dll文件中，jdk的源码中并不包含，所以是看不到的。对于不同的平台，他们也是不同的。这也是java的底层机制，实际上java就是在不同的平台上调用不同的native方法实现对操作系统的访问的 Java语言本身不能对操作系统底层进行访问和操作,但是可通过JNI接口调用其他语言来实现对底层的访问. JNI是Java本机接口(Java Native Interface),是一个本机编程接口,是Java软件开发发工具箱(java Software Development Kit, SDK)的一部分.JNI允许Java代码使用以其他语言编写的代码和代码库. Invocation API(JNI的一部分)可以用来将Java虚拟机(JVM)嵌入到本机应用程序中,从而允许程序员代码内部调用java代码 所以，native的意思就是通知操作系统，我需要这个方法，而你操作系统需要给我实现，我需要使用。而java只需要调用操作系统的方法就行了 java不是完美的，java的运行速度上比传统的C语言慢许多，java无法直接访问到底层操作系统等缺点。当然，解决方法就是上面说的利用native方法来扩展java程序的功能。以下有实践步骤：是之前做笔记的时候尝试的： #二、实践理解 1使用java调用C的"sayHello" 1.创建一个java类 123456789101112public class HelloNative &#123; static&#123; System.loadLibrary("HelloNative"); &#125; public static native void sayHello(); @SuppressWarnings("static-access") public static void main(String[] args) &#123; new HelloNative().sayHello(); &#125;&#125; 这里有一个sayHello()方法，native标识该方法的实现在非当前文件，在static静态快中加载的library(HelloNative)中 运行main()之后出现以下情况 12 报错信息时说找不到library(“HelloNative”)的路径，因为我们本地就没有这个文件 2.创建本地方法文件 我们将Java类HelloNative复制出来，（我给放在了D盘根目录，方便） 然后在控制台用javac命令将其编译成字节码文件， 1javac HelloNative.jave 注意：如果命令输入目录与.java文件不在同一目录下，javac命令后的文件名要加路径，如图中d:\HelloNative.java： 然后在用havah编译，获得包含C声明头文件 1javah HelloNative 注意：在这里，我命令目录与文件目录不在同一路径，报错了，这个命令不会区别路径，而是在当前目录下找d:\HelloNative这个名字的文件，把d:\也当成文件名字的一部分 到此，我们一共有三个文件了： 看一下.h文件的内容吧： 123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class HelloNative */#ifndef _Included_HelloNative#define _Included_HelloNative#ifdef __cplusplusextern "C" &#123;#endif/* * Class: HelloNative * Method: sayHello * Signature: ()V */JNIEXPORT void JNICALL Java_HelloNative_sayHello (JNIEnv *, jclass);#ifdef __cplusplus&#125;#endif#endif 创建.c文件： 12 然后运行gcc命令来生成dll共享库 12 命令中的路径是电脑中jdk的安装路径\include 完成后这样就有5个文件了： 然后在用java命令运行一下java代码，就能成功在cmd通过java代码调用c的sayHello方法了 1java HelloNative 说明： 从gcc命令开始，没有图和真相了，那是因为我所有的笔记标签的文章都是回头看以前做的笔记的时候，重新整理记录一下，也有的是之前没有记录到的，整理的时候又重新学一遍；也有之前试验过但是现在环境不允许了。 就像这篇文章，以前做的时候就稀里糊涂的，不明所以，就连步骤都是直接抄录别人的，也只是弄懂了java中native关键字是什么意思，后面调用c也一知半解！现在也顶多知道了怎么回事，但是c我一点也不懂，所以暂时就这样吧，凑合着看，然后多点空间自己研究，也是一种学习！]]></content>
      <categories>
        <category>java</category>
        <category>关键字</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用JPA创建原生sql(不使用实体类)]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F13%2F%E4%BD%BF%E7%94%A8JPA%E5%88%9B%E5%BB%BA%E5%8E%9F%E7%94%9Fsql-%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BD%93%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[#一、描述 JPA很强大，嗯，没错，是很强大！ 它是通过JDK5.0注解或者XML描述对象-关系表的映射关系，并能够将在运行中的实体对象持久化到数据库中。 并且它也是面向对象查询，也就是将实体类与数据库的表映射，即使不会数据库的开发者，只要能看懂java的类，只要能熟练使用jpa，也能很便捷地操作数据库 当然，映射类有其好处，也有弊端。假如说，某个场景下，我需要查询多个表中的数据，并且每个表中只有一到两个字段有用，而整张表的字段又很多，所以有时候就不需要将每个表都完整映射成实体类（不然的话，每次查询就要多查询很多无用的垃圾信息） 今天遇到了这种场景，由于是多表联查，但是只需要其中各一个字段，其余的每个表十几个字段都没用。所以就不需要把每张表的数据都查询出来。而个人对于jpa也不熟练，所以踩了很多坑。下面就此记录： #二、实录 （踩坑全过程，实力坑自己！Pain and happiness!想直接看结果，直接拉下去别看这段了） ###想法1、返回map，不用实体类 1.dao层（Repository） 就是控制sql语句对数据库进行增删改查。 这里的接口很容易写，只需要继承JpaRepository&lt;entity,object&gt;接口就可以了# 这里需要注意： 1.entity，必须是被管理的类，也就是与数据库进行映射的实体类 所以，就坑在这了，一直报错说Repository什么什么类型必须是被映射管理的，而map却不是。奶奶的，继续想办法###想法2、创建实体类（不过由于不懂，所以这里没有进行关系映射，就是一个单纯的javaBean，不用仔细说了失败！）# 注意： 1.实体类必须与数据库映射才算被映射管理（@Entity注解） 继续尝试 ###想法3、映射实体类(但是这次也只写了部分字段，自己需要的)# 注意： 1.加上注解标明映射之后，又特么脑残踩了个雷（鄙视自己一秒钟） 对于这个，说一下吧，由于最初没打算映射，并且需要的数据是多个表的，所以类名就自己起的名字。好家伙，提示table_name没有被映射过！我嘞个擦。所以在@Entity注解加上name属性： @Entity(name=&quot;table_name&quot;)最初的时候加错了，写成实体类的名字了，尴尬！这里其实要写表的名字，表明该实体类与那张表映射 2.与数据库映射的类必须有@Id标明主键(失败一次！吼，不想解释了) 3.这一点忍无可忍！错误信息说，表中为not null的字段，必须在实体类中映射！也就是实体类中必须有非空字段的属性！！！ 吼吼吼！！我连吼三次可以了吧！那我跟映射全部字段有什么区别呢？还是初衷吗？ 5.4都没有哪来的5？就是说，以上一环扣一环之后，想要按照之前想法，实体类，拜拜！ # 经过以上绕的弯路，所以就又绕回来了。哼哼！于是乎：老子不用实体类了，也不继承JpaRepository。 ###想法4、注解托管Repository！ 奈斯！启动刚开始没报错，之前报错貌似跳过去了！突然之间，XXXXXX that could not be found，我真xxxx了，然后去网上找解决方法，要吐血！各种各样的方法，没用！直到我看到一个帖子： 一口老血啊！果断不找了！ （别学我，因为刚刚在找这个帖子的时候，无意间瞥见另一个帖子， 解决方案是：在Application启动类中加上注解：@EnableJpaRepositories(&quot;com.example.repository&quot;)来说明要扫描的类， 虽然之前也在启动类中加过注释，但我也记不清这个到底有没有尝试过了， 感觉很靠谱，这里说一下！失败了也别来找我,也有可能环境不同） # 所以！这是一个死循环啊，想要用dao层Repository，OK的，继承JPARepository吧， 等等，我jpa有条件的，entity呢？ 好，给你！ 慢着，我entity不干，先给cp一个数据库表吧，我可不打酱油的！唉，给你cp个表吧， 停！cp随便你，但是我有孩子，得带过去，你去问问entity同不同意！ 尼玛，可怕！！！ # 于是，果断放弃了从dao层入手。 #三、解决方案 JPA很强大，嗯，没错，是很强大！# 又是这句话，没错，我们如果映射实体类的话，那么目前的情况就感觉无用数据太多，而且累赘，要映射好几张表 但是别怕，jpa不但能面向对象查询，还支持原生sql，能够让我们根据自己的想法来实现 第一种：使用注解@Query(value=”sqlString”) 第二种：entityManager.createNativeQuery(sqlString) # 第一种，注解在dao层的方法上，由于我自动装配出问题了，并且及早地放弃了，所以没用， 第二种，上代码 123456Query query = entityManager.createNativeQuery("select * from user where id = ?");query.setParameter(1,"g10001");List list = query.getResultList();Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put("name1",objs.get(0)[0].toString()); map.put("name2",objs.get(0)[1].toString());...... 搞定！list是List&lt;Object[]&gt;类型，里面放的就是一条条数据，而Object[]数组里面是一条数据中的所有字段。 不过又见几个坑，是网上的帖子，代码如下： 123for(Object os : list)&#123; Map map = (Map)os;&#125; 我只求数组（实际上是Object类型的数组）强转Map这波操作！！！！没别的要求 #四、 诙谐的话语，搞笑而又逗逼！就跟老朋友聊骚，听老朋友牢骚。轻松吗？]]></content>
      <categories>
        <category>java</category>
        <category>框架</category>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>实录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql建表时设置日期默认值及默认修改时间]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F12%2Fmysql%E5%BB%BA%E8%A1%A8%E6%97%B6%E8%AE%BE%E7%BD%AE%E6%97%A5%E6%9C%9F%E9%BB%98%E8%AE%A4%E5%80%BC%E5%8F%8A%E9%BB%98%E8%AE%A4%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[#一、简单说明 在做项目的时候，在数据库中基本上都会有关于日期的问题。其中不乏包括日期格式、运算、比较等等。不过这些都很常见了，今天要记录的点，非常简单，不过可能也是很多情况下忽略的东西。 关于这次记录的东西，就是mysql中时间格式的默认值。 很多时候，我们都会对一条数据的相关时间进行记录，比如创建日期，修改日期等等最常见的。而处理这些日期的大部分方法，一般是在后台中获取当前的时间，然后随着数据插入到表中进行保存。 下面，要说的是用mysql自带的方法来实现。（如果觉得没多大意义的话，请止步到此吧，如果想了解一下，请继续） #二、图文示例 这里使用的版本是MySQL 5.6 ###1.mysql的日期和时间类型（这里会展示一下各种时间格式，不想看的跳过） 先来看一下mysql中的日期和时间类型，以及其值的样子 - 在图中我们能够看到，我给所有的日期和时间类型赋值都是年/月/日 时:分:秒.毫秒 - 而最终查询出来的日期格式如列表展示，不同的类型，格式也不同 - 其中year类型只能赋值并保存年份，不过这个字段的赋值有点有意思的地方 ####1.1 year类型 我们先来看看不同的赋值的结果 1.首先赋值0 2.然后1 应该有人应该猜出来了吧,不过我很好奇的是，这个赋值到底范围是多少，于是在这个过程中又遇到了有趣的事情 3.然后： 1到这里就能看出来，mysql日期虽然年份能够不用写完整的4位，但是对于只写两位数，mysql中还是有点范围的70表示1970，而0表示的是2000，很显然，最多就是99表示1999了，然后从1-69表示的是2001-2069，所以mysql非完整的年份默认值范围0-99 4.完整年份最大值 1不要问我怎么来的，我无聊 ###2.正题：设置默认时间 1这个设置是创建该数据的当前时间 1.使用函数now() 1mysql中有函数可以在sql语句中直接使用（废话不解释了），now()都不陌生 1不过支持now()函数的只有datetime和timestamp两种类型，其他三种都不支持 2.current_（cur系列） 123我们可以利用default current_timestamp为timestamp类型的设置默认值不过很无奈的是，mysql中有current_date和current_time等，但是我这个版本却不能用， 3.自动记录修改时间 1在这里能够看到，id为1的这条数据时间变成了执行update时候的时间 1由于前两天接了新项目，所以写了一半就停下来了，今天有点时间，想着就写完它。勉强看，也算给自己昨个记录]]></content>
      <categories>
        <category>DB</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>日期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
