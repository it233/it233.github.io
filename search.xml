<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用JPA创建原生sql(不使用实体类)]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F13%2F%E4%BD%BF%E7%94%A8JPA%E5%88%9B%E5%BB%BA%E5%8E%9F%E7%94%9Fsql-%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BD%93%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[#一、描述 JPA很强大，嗯，没错，是很强大！ 它是通过JDK5.0注解或者XML描述对象-关系表的映射关系，并能够将在运行中的实体对象持久化到数据库中。 并且它也是面向对象查询，也就是将实体类与数据库的表映射，即使不会数据库的开发者，只要能看懂java的类，只要能熟练使用jpa，也能很便捷地操作数据库 当然，映射类有其好处，也有弊端。假如说，某个场景下，我需要查询多个表中的数据，并且每个表中只有一到两个字段有用，而整张表的字段又很多，所以有时候就不需要将每个表都完整映射成实体类（不然的话，每次查询就要多查询很多无用的垃圾信息） 今天遇到了这种场景，由于是多表联查，但是只需要其中各一个字段，其余的每个表十几个字段都没用。所以就不需要把每张表的数据都查询出来。而个人对于jpa也不熟练，所以踩了很多坑。下面就此记录： #二、实录 （踩坑全过程，实力坑自己！Pain and happiness!想直接看结果，直接拉下去别看这段了） ###想法1、返回map，不用实体类 1.dao层（Repository） 就是控制sql语句对数据库进行增删改查。 这里的接口很容易写，只需要继承JpaRepository&lt;entity,object&gt;接口就可以了# 这里需要注意： 1.entity，必须是被管理的类，也就是与数据库进行映射的实体类 所以，就坑在这了，一直报错说Repository什么什么类型必须是被映射管理的，而map却不是。奶奶的，继续想办法###想法2、创建实体类（不过由于不懂，所以这里没有进行关系映射，就是一个单纯的javaBean，不用仔细说了失败！）# 注意： 1.实体类必须与数据库映射才算被映射管理（@Entity注解） 继续尝试 ###想法3、映射实体类(但是这次也只写了部分字段，自己需要的)# 注意： 1.加上注解标明映射之后，又特么脑残踩了个雷（鄙视自己一秒钟） 对于这个，说一下吧，由于最初没打算映射，并且需要的数据是多个表的，所以类名就自己起的名字。好家伙，提示table_name没有被映射过！我嘞个擦。所以在@Entity注解加上name属性： @Entity(name=&quot;table_name&quot;)最初的时候加错了，写成实体类的名字了，尴尬！这里其实要写表的名字，表明该实体类与那张表映射 2.与数据库映射的类必须有@Id标明主键(失败一次！吼，不想解释了) 3.这一点忍无可忍！错误信息说，表中为not null的字段，必须在实体类中映射！也就是实体类中必须有非空字段的属性！！！ 吼吼吼！！我连吼三次可以了吧！那我跟映射全部字段有什么区别呢？还是初衷吗？ 5.4都没有哪来的5？就是说，以上一环扣一环之后，想要按照之前想法，实体类，拜拜！ # 经过以上绕的弯路，所以就又绕回来了。哼哼！于是乎：老子不用实体类了，也不继承JpaRepository。 ###想法4、注解托管Repository！ 奈斯！启动刚开始没报错，之前报错貌似跳过去了！突然之间，XXXXXX that could not be found，我真xxxx了，然后去网上找解决方法，要吐血！各种各样的方法，没用！直到我看到一个帖子： 一口老血啊！果断不找了！ （别学我，因为刚刚在找这个帖子的时候，无意间瞥见另一个帖子， 解决方案是：在Application启动类中加上注解：@EnableJpaRepositories(&quot;com.example.repository&quot;)来说明要扫描的类， 虽然之前也在启动类中加过注释，但我也记不清这个到底有没有尝试过了， 感觉很靠谱，这里说一下！失败了也别来找我,也有可能环境不同） # 所以！这是一个死循环啊，想要用dao层Repository，OK的，继承JPARepository吧， 等等，我jpa有条件的，entity呢？ 好，给你！ 慢着，我entity不干，先给cp一个数据库表吧，我可不打酱油的！唉，给你cp个表吧， 停！cp随便你，但是我有孩子，得带过去，你去问问entity同不同意！ 尼玛，可怕！！！ # 于是，果断放弃了从dao层入手。 #三、解决方案 JPA很强大，嗯，没错，是很强大！# 又是这句话，没错，我们如果映射实体类的话，那么目前的情况就感觉无用数据太多，而且累赘，要映射好几张表 但是别怕，jpa不但能面向对象查询，还支持原生sql，能够让我们根据自己的想法来实现 第一种：使用注解@Query(value=”sqlString”) 第二种：entityManager.createNativeQuery(sqlString) # 第一种，注解在dao层的方法上，由于我自动装配出问题了，并且及早地放弃了，所以没用， 第二种，上代码 123456Query query = entityManager.createNativeQuery("select * from user where id = ?");query.setParameter(1,"g10001");List list = query.getResultList();Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put("name1",objs.get(0)[0].toString()); map.put("name2",objs.get(0)[1].toString());...... 搞定！list是List&lt;Object[]&gt;类型，里面放的就是一条条数据，而Object[]数组里面是一条数据中的所有字段。 不过又见几个坑，是网上的帖子，代码如下： 123for(Object os : list)&#123; Map map = (Map)os;&#125; 我只求数组（实际上是Object类型的数组）强转Map这波操作！！！！没别的要求 #四、 诙谐的话语，搞笑而又逗逼！就跟老朋友聊骚，听老朋友牢骚。轻松吗？]]></content>
      <categories>
        <category>java</category>
        <category>框架</category>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>实录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql建表时设置日期默认值及默认修改时间]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F12%2Fmysql%E5%BB%BA%E8%A1%A8%E6%97%B6%E8%AE%BE%E7%BD%AE%E6%97%A5%E6%9C%9F%E9%BB%98%E8%AE%A4%E5%80%BC%E5%8F%8A%E9%BB%98%E8%AE%A4%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[#一、简单说明 在做项目的时候，在数据库中基本上都会有关于日期的问题。其中不乏包括日期格式、运算、比较等等。不过这些都很常见了，今天要记录的点，非常简单，不过可能也是很多情况下忽略的东西。 关于这次记录的东西，就是mysql中时间格式的默认值。 很多时候，我们都会对一条数据的相关时间进行记录，比如创建日期，修改日期等等最常见的。而处理这些日期的大部分方法，一般是在后台中获取当前的时间，然后随着数据插入到表中进行保存。 下面，要说的是用mysql自带的方法来实现。（如果觉得没多大意义的话，请止步到此吧，如果想了解一下，请继续） #二、图文示例 这里使用的版本是MySQL 5.6 ###1.mysql的日期和时间类型 先来看一下mysql中的日期和时间类型，以及其值的样子 - 在图中我们能够看到，我给所有的日期和时间类型赋值都是年/月/日 时:分:秒.毫秒 - 而最终查询出来的日期格式如列表展示，不同的类型，格式也不同 - 其中year类型只能赋值并保存年份，不过这个字段的赋值有点有意思的地方 ####1.1 year类型 我们先来看看不同的赋值的结果 1.首先赋值0 2.然后1 应该有人应该猜出来了吧,不过我很好奇的是，]]></content>
      <categories>
        <category>DB</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>日期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test04]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F09%2Ftest04%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[test02]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F09%2Ftest02%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[test01]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F09%2Ftest01%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Fit233.github.io%2F2018%2F11%2F09%2Ftest%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
